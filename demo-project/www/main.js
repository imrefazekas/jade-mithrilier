/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};

/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {

/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;

/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};

/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);

/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;

/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}


/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;

/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;

/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "./";

/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports, __webpack_require__) {

	/*
	var m = require('mithril');

	var mapObject = require('jade-mithrilier').mapObject();
	var Person = require('./models/Person');

	var _ = require('lodash');

	var modelName = 'Person';
	var context = {
		emailSelected: function(){}
	};
	var mvc = {
		model: Person.dataModel,
		controller: mapObject( modelName, Person.validation ),
		view: function(ctrl) {
			return m("div", {
				"className": "section"
			}, [m("text", {
				"className": "h6"
			}, ["Sign up"]), m("br", {
				"className": ""
			}, []), m("input", {
				value: ctrl[modelName].name(),
				oninput: m.withAttr('value', ctrl[modelName].name),
				"type": "text",
				"id": "join_name",
				"placeholder": "Your name",
				"data-bind": "name",
				"className": "c_ds_blue hN text-center"
			}, []), m("br", {
				"className": ""
			}, []), m("input", {
				value: ctrl[modelName].email(),
				oninput: m.withAttr('value', ctrl[modelName].email),
				"type": "text",
				"id": "join_email",
				"placeholder": "Your email address",
				"data-bind": "email",
				"className": "c_ds_blue hN text-center"
			}, []), m("br", {
				"className": ""
			}, []), m("text", {
				"className": ""
			}, ["Accept?"]), m("input", {
				value: ctrl[modelName].terms(),
				onclick: m.withAttr('checked', ctrl[modelName].terms),
				checked: ctrl[modelName].terms(),
				"type": "checkbox",
				"data-bind": "terms",
				"className": "checkbox"
			}, []), m("br", {
				"className": ""
			}, []), m("br", {
				"className": ""
			}, []), m("br", {
				"className": ""
			}, []), m("text", {
				textContent: ctrl[modelName].name(),
				"data-value": "name",
				"className": ""
			}, ["Addresses:"]), m("br", {
				"className": ""
			}, []), m("select", {
				"data-each": "emails",
				"data-event-change": "emailSelected",
				"className": ""
			}, ctrl[modelName].emails.map(function(item, index, array) {
				return [m("option", {
					textContent: item(),
					"data-value": "$item",
					"data-attr": "{ value: $item() }",
					"className": ""
				}, [])];
			})), m("div", {
				"data-each": "addresses",
				"className": "row-section"
			}, ctrl[modelName].addresses.map(function(item, index, array) {
				return [m("div", {
					"className": "row"
				}, [m("input", {
					value: item.city(),
					oninput: m.withAttr('value', item.city),
					"type": "text",
					"placeholder": "Your city",
					"data-bind": "city",
					"className": "c_ds_blue hN text-center"
				}, []), m("br", {
					"className": ""
				}, []), m("input", {
					value: item.street(),
					oninput: m.withAttr('value', item.street),
					"type": "text",
					"placeholder": "Your street",
					"data-bind": "street",
					"className": "c_ds_blue hN text-center"
				}, []), m("br", {
					"className": ""
				}, []), m("input", {
					value: item.active(),
					onclick: m.withAttr('checked', item.active),
					checked: item.active(),
					"type": "checkbox",
					"data-bind": "active",
					"className": "checkbox"
				}, []), m("br", {
					"className": ""
				}, []) ])];
			}))]);
		}
	};

	m.mount( document.getElementsByClassName('half1')[0], m.component(mvc, Person.dataModel) );
	m.mount( document.getElementsByClassName('half2')[0], m.component(mvc, Person.dataModel) );
	*/




	var Vanilla = __webpack_require__(1);
	var EventEmitter = __webpack_require__(2).EventEmitter;
	var m = __webpack_require__(3);

	var updateModel = __webpack_require__(5).updateModel;


	function ViewModel(){
		EventEmitter.call( this );
	}
	ViewModel.prototype = new EventEmitter();

	var viewModel = ViewModel.prototype;
	viewModel.clearElement = function( element ){
		Vanilla.removeClass(element, 'validation-error');
		Vanilla.removeClass(element, 'validation-success');
	};
	viewModel.invalidElement = function( element, errors ){
		Vanilla.addClass(element, 'validation-error');
	};
	viewModel.validElement = function( element ){
		Vanilla.addClass(element, 'validation-success');
	};
	viewModel.emailSelected = function(){
		console.log('?????', arguments);
	};
	viewModel.clicked = function(){
		console.log('Clicked!');
	};

	var self = new ViewModel();

	function createModelContext( context, modelName ){
		if( !context[ modelName ] ){
			context[ modelName ] = {
				model: __webpack_require__(50)("./" + modelName),
				vcs: []
			};
			self.emit('init' + modelName + 'Model', context[ modelName ].model);
			context[ 'get' + modelName] = function(){
				if( context[ modelName ].vcs.length === 0 ) throw new Error('No view has been initiated.');
				return context[ modelName ].vcs[0].controller.toJS();
			};
		}
	}

	self.on('initPersonModel', function( model ){
		console.log('Person model read.');
	});
	self.on('initContentViewModel', function( model ){
		console.log('Person model used for Content.');
	});
	var first = true;
	self.on('initContentController', function( controller ){
		if( !first ) return;

		console.log('Controller for model Person made.');
		//m.stopComputation();
		controller.cleanAddresses();
		controller.addToAddresses();
		controller.addToAddresses( { city: 'Vicity', street: 'Valahol' } );
		controller.addToEmails( 'imre@be.hu' );
		controller.addToEmails( 'peter@be.fr' );
		controller.addToEmails( 'steve@be.uk' );
		//m.startComputation();

		first = false;
	});

	var context = __webpack_require__(52);
	context.keys().forEach( function(key){
		var modelLoader = context(key);
		var viewName = key.match(/\w+/)[0];
		var mounters = document.querySelectorAll('[data-mount=\"' + viewName + '\"]');
		Array.prototype.forEach.call(mounters, function(element, i){
			var modelName = element.getAttribute('data-model') || viewName;

			createModelContext( self, modelName );

			modelLoader.mount( self[ modelName ].model, self, viewName, modelName, element );
		} );
	} );

	window.Demo = self;

	/*
			self.Person.controller.cleanAddresses();
			self.Person.controller.addToAddresses();
			self.Person.controller.addToAddresses( { city: 'Vicity', street: 'Valahol' } );
			self.Person.controller.addToEmails( 'imre@be.hu' );
			self.Person.controller.addToEmails( 'peter@be.fr' );
			self.Person.controller.addToEmails( 'steve@be.uk' );
			*/

	/*
	if( elements.length === 1 ){
		self.clearElement = function( element ){
			Vanilla.removeClass(element, 'validation-error');
			Vanilla.removeClass(element, 'validation-success');
		};
		self.invalidElement = function( element, errors ){
			Vanilla.addClass(element, 'validation-error');
		};
		self.validElement = function( element ){
			Vanilla.addClass(element, 'validation-success');
		};

		self.emailSelected = function(){
			console.log('?????', arguments);
		};

		var ViewModel = mitrilied.mount( Model, self, modelName, elements[0] );
		self.Person.controller.cleanAddresses();
		self.Person.controller.addToAddresses();
		self.Person.controller.addToAddresses( { city: 'Vicity', street: 'Valahol' } );
		self.Person.controller.addToEmails( 'imre@be.hu' );
		self.Person.controller.addToEmails( 'peter@be.fr' );
		self.Person.controller.addToEmails( 'steve@be.uk' );
		self[ 'get' + modelName] = function(){
			return self[ modelName ].controller.toJS();
		};
	}

	*/


/***/ },
/* 1 */
/***/ function(module, exports) {

	var index = 0;
	module.exports = {
		addClass: function( el, className ){
			if (el.classList)
				el.classList.add(className);
			else
				el.className += ' ' + className;
			return this;
		},
		removeClass: function( el, className ){
			if (el.classList)
				el.classList.remove(className);
			else
				el.className = el.className.replace(new RegExp('(^|\\b)' + className.split(' ').join('|') + '(\\b|$)', 'gi'), ' ');
			return this;
		}
	};


/***/ },
/* 2 */
/***/ function(module, exports) {

	// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.

	function EventEmitter() {
	  this._events = this._events || {};
	  this._maxListeners = this._maxListeners || undefined;
	}
	module.exports = EventEmitter;

	// Backwards-compat with node 0.10.x
	EventEmitter.EventEmitter = EventEmitter;

	EventEmitter.prototype._events = undefined;
	EventEmitter.prototype._maxListeners = undefined;

	// By default EventEmitters will print a warning if more than 10 listeners are
	// added to it. This is a useful default which helps finding memory leaks.
	EventEmitter.defaultMaxListeners = 10;

	// Obviously not all Emitters should be limited to 10. This function allows
	// that to be increased. Set to zero for unlimited.
	EventEmitter.prototype.setMaxListeners = function(n) {
	  if (!isNumber(n) || n < 0 || isNaN(n))
	    throw TypeError('n must be a positive number');
	  this._maxListeners = n;
	  return this;
	};

	EventEmitter.prototype.emit = function(type) {
	  var er, handler, len, args, i, listeners;

	  if (!this._events)
	    this._events = {};

	  // If there is no 'error' event listener then throw.
	  if (type === 'error') {
	    if (!this._events.error ||
	        (isObject(this._events.error) && !this._events.error.length)) {
	      er = arguments[1];
	      if (er instanceof Error) {
	        throw er; // Unhandled 'error' event
	      }
	      throw TypeError('Uncaught, unspecified "error" event.');
	    }
	  }

	  handler = this._events[type];

	  if (isUndefined(handler))
	    return false;

	  if (isFunction(handler)) {
	    switch (arguments.length) {
	      // fast cases
	      case 1:
	        handler.call(this);
	        break;
	      case 2:
	        handler.call(this, arguments[1]);
	        break;
	      case 3:
	        handler.call(this, arguments[1], arguments[2]);
	        break;
	      // slower
	      default:
	        args = Array.prototype.slice.call(arguments, 1);
	        handler.apply(this, args);
	    }
	  } else if (isObject(handler)) {
	    args = Array.prototype.slice.call(arguments, 1);
	    listeners = handler.slice();
	    len = listeners.length;
	    for (i = 0; i < len; i++)
	      listeners[i].apply(this, args);
	  }

	  return true;
	};

	EventEmitter.prototype.addListener = function(type, listener) {
	  var m;

	  if (!isFunction(listener))
	    throw TypeError('listener must be a function');

	  if (!this._events)
	    this._events = {};

	  // To avoid recursion in the case that type === "newListener"! Before
	  // adding it to the listeners, first emit "newListener".
	  if (this._events.newListener)
	    this.emit('newListener', type,
	              isFunction(listener.listener) ?
	              listener.listener : listener);

	  if (!this._events[type])
	    // Optimize the case of one listener. Don't need the extra array object.
	    this._events[type] = listener;
	  else if (isObject(this._events[type]))
	    // If we've already got an array, just append.
	    this._events[type].push(listener);
	  else
	    // Adding the second element, need to change to array.
	    this._events[type] = [this._events[type], listener];

	  // Check for listener leak
	  if (isObject(this._events[type]) && !this._events[type].warned) {
	    if (!isUndefined(this._maxListeners)) {
	      m = this._maxListeners;
	    } else {
	      m = EventEmitter.defaultMaxListeners;
	    }

	    if (m && m > 0 && this._events[type].length > m) {
	      this._events[type].warned = true;
	      console.error('(node) warning: possible EventEmitter memory ' +
	                    'leak detected. %d listeners added. ' +
	                    'Use emitter.setMaxListeners() to increase limit.',
	                    this._events[type].length);
	      if (typeof console.trace === 'function') {
	        // not supported in IE 10
	        console.trace();
	      }
	    }
	  }

	  return this;
	};

	EventEmitter.prototype.on = EventEmitter.prototype.addListener;

	EventEmitter.prototype.once = function(type, listener) {
	  if (!isFunction(listener))
	    throw TypeError('listener must be a function');

	  var fired = false;

	  function g() {
	    this.removeListener(type, g);

	    if (!fired) {
	      fired = true;
	      listener.apply(this, arguments);
	    }
	  }

	  g.listener = listener;
	  this.on(type, g);

	  return this;
	};

	// emits a 'removeListener' event iff the listener was removed
	EventEmitter.prototype.removeListener = function(type, listener) {
	  var list, position, length, i;

	  if (!isFunction(listener))
	    throw TypeError('listener must be a function');

	  if (!this._events || !this._events[type])
	    return this;

	  list = this._events[type];
	  length = list.length;
	  position = -1;

	  if (list === listener ||
	      (isFunction(list.listener) && list.listener === listener)) {
	    delete this._events[type];
	    if (this._events.removeListener)
	      this.emit('removeListener', type, listener);

	  } else if (isObject(list)) {
	    for (i = length; i-- > 0;) {
	      if (list[i] === listener ||
	          (list[i].listener && list[i].listener === listener)) {
	        position = i;
	        break;
	      }
	    }

	    if (position < 0)
	      return this;

	    if (list.length === 1) {
	      list.length = 0;
	      delete this._events[type];
	    } else {
	      list.splice(position, 1);
	    }

	    if (this._events.removeListener)
	      this.emit('removeListener', type, listener);
	  }

	  return this;
	};

	EventEmitter.prototype.removeAllListeners = function(type) {
	  var key, listeners;

	  if (!this._events)
	    return this;

	  // not listening for removeListener, no need to emit
	  if (!this._events.removeListener) {
	    if (arguments.length === 0)
	      this._events = {};
	    else if (this._events[type])
	      delete this._events[type];
	    return this;
	  }

	  // emit removeListener for all listeners on all events
	  if (arguments.length === 0) {
	    for (key in this._events) {
	      if (key === 'removeListener') continue;
	      this.removeAllListeners(key);
	    }
	    this.removeAllListeners('removeListener');
	    this._events = {};
	    return this;
	  }

	  listeners = this._events[type];

	  if (isFunction(listeners)) {
	    this.removeListener(type, listeners);
	  } else if (listeners) {
	    // LIFO order
	    while (listeners.length)
	      this.removeListener(type, listeners[listeners.length - 1]);
	  }
	  delete this._events[type];

	  return this;
	};

	EventEmitter.prototype.listeners = function(type) {
	  var ret;
	  if (!this._events || !this._events[type])
	    ret = [];
	  else if (isFunction(this._events[type]))
	    ret = [this._events[type]];
	  else
	    ret = this._events[type].slice();
	  return ret;
	};

	EventEmitter.prototype.listenerCount = function(type) {
	  if (this._events) {
	    var evlistener = this._events[type];

	    if (isFunction(evlistener))
	      return 1;
	    else if (evlistener)
	      return evlistener.length;
	  }
	  return 0;
	};

	EventEmitter.listenerCount = function(emitter, type) {
	  return emitter.listenerCount(type);
	};

	function isFunction(arg) {
	  return typeof arg === 'function';
	}

	function isNumber(arg) {
	  return typeof arg === 'number';
	}

	function isObject(arg) {
	  return typeof arg === 'object' && arg !== null;
	}

	function isUndefined(arg) {
	  return arg === void 0;
	}


/***/ },
/* 3 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/* WEBPACK VAR INJECTION */(function(module) {var m = (function app(window, undefined) {
		var OBJECT = "[object Object]", ARRAY = "[object Array]", STRING = "[object String]", FUNCTION = "function";
		var type = {}.toString;
		var parser = /(?:(^|#|\.)([^#\.\[\]]+))|(\[.+?\])/g, attrParser = /\[(.+?)(?:=("|'|)(.*?)\2)?\]/;
		var voidElements = /^(AREA|BASE|BR|COL|COMMAND|EMBED|HR|IMG|INPUT|KEYGEN|LINK|META|PARAM|SOURCE|TRACK|WBR)$/;
		var noop = function() {}

		// caching commonly used variables
		var $document, $location, $requestAnimationFrame, $cancelAnimationFrame;

		// self invoking function needed because of the way mocks work
		function initialize(window){
			$document = window.document;
			$location = window.location;
			$cancelAnimationFrame = window.cancelAnimationFrame || window.clearTimeout;
			$requestAnimationFrame = window.requestAnimationFrame || window.setTimeout;
		}

		initialize(window);


		/**
		 * @typedef {String} Tag
		 * A string that looks like -> div.classname#id[param=one][param2=two]
		 * Which describes a DOM node
		 */

		/**
		 *
		 * @param {Tag} The DOM node tag
		 * @param {Object=[]} optional key-value pairs to be mapped to DOM attrs
		 * @param {...mNode=[]} Zero or more Mithril child nodes. Can be an array, or splat (optional)
		 *
		 */
		function m() {
			var args = [].slice.call(arguments);
			var hasAttrs = args[1] != null && type.call(args[1]) === OBJECT && !("tag" in args[1] || "view" in args[1]) && !("subtree" in args[1]);
			var attrs = hasAttrs ? args[1] : {};
			var classAttrName = "class" in attrs ? "class" : "className";
			var cell = {tag: "div", attrs: {}};
			var match, classes = [];
			if (type.call(args[0]) != STRING) throw new Error("selector in m(selector, attrs, children) should be a string")
			while (match = parser.exec(args[0])) {
				if (match[1] === "" && match[2]) cell.tag = match[2];
				else if (match[1] === "#") cell.attrs.id = match[2];
				else if (match[1] === ".") classes.push(match[2]);
				else if (match[3][0] === "[") {
					var pair = attrParser.exec(match[3]);
					cell.attrs[pair[1]] = pair[3] || (pair[2] ? "" :true)
				}
			}

			var children = hasAttrs ? args.slice(2) : args.slice(1);
			if (children.length === 1 && type.call(children[0]) === ARRAY) {
				cell.children = children[0]
			}
			else {
				cell.children = children
			}

			for (var attrName in attrs) {
				if (attrs.hasOwnProperty(attrName)) {
					if (attrName === classAttrName && attrs[attrName] != null && attrs[attrName] !== "") {
						classes.push(attrs[attrName])
						cell.attrs[attrName] = "" //create key in correct iteration order
					}
					else cell.attrs[attrName] = attrs[attrName]
				}
			}
			if (classes.length > 0) cell.attrs[classAttrName] = classes.join(" ");

			return cell
		}
		function build(parentElement, parentTag, parentCache, parentIndex, data, cached, shouldReattach, index, editable, namespace, configs) {
			//`build` is a recursive function that manages creation/diffing/removal of DOM elements based on comparison between `data` and `cached`
			//the diff algorithm can be summarized as this:
			//1 - compare `data` and `cached`
			//2 - if they are different, copy `data` to `cached` and update the DOM based on what the difference is
			//3 - recursively apply this algorithm for every array and for the children of every virtual element

			//the `cached` data structure is essentially the same as the previous redraw's `data` data structure, with a few additions:
			//- `cached` always has a property called `nodes`, which is a list of DOM elements that correspond to the data represented by the respective virtual element
			//- in order to support attaching `nodes` as a property of `cached`, `cached` is *always* a non-primitive object, i.e. if the data was a string, then cached is a String instance. If data was `null` or `undefined`, cached is `new String("")`
			//- `cached also has a `configContext` property, which is the state storage object exposed by config(element, isInitialized, context)
			//- when `cached` is an Object, it represents a virtual element; when it's an Array, it represents a list of elements; when it's a String, Number or Boolean, it represents a text node

			//`parentElement` is a DOM element used for W3C DOM API calls
			//`parentTag` is only used for handling a corner case for textarea values
			//`parentCache` is used to remove nodes in some multi-node cases
			//`parentIndex` and `index` are used to figure out the offset of nodes. They're artifacts from before arrays started being flattened and are likely refactorable
			//`data` and `cached` are, respectively, the new and old nodes being diffed
			//`shouldReattach` is a flag indicating whether a parent node was recreated (if so, and if this node is reused, then this node must reattach itself to the new parent)
			//`editable` is a flag that indicates whether an ancestor is contenteditable
			//`namespace` indicates the closest HTML namespace as it cascades down from an ancestor
			//`configs` is a list of config functions to run after the topmost `build` call finishes running

			//there's logic that relies on the assumption that null and undefined data are equivalent to empty strings
			//- this prevents lifecycle surprises from procedural helpers that mix implicit and explicit return statements (e.g. function foo() {if (cond) return m("div")}
			//- it simplifies diffing code
			//data.toString() might throw or return null if data is the return value of Console.log in Firefox (behavior depends on version)
			try {if (data == null || data.toString() == null) data = "";} catch (e) {data = ""}
			if (data.subtree === "retain") return cached;
			var cachedType = type.call(cached), dataType = type.call(data);
			if (cached == null || cachedType !== dataType) {
				if (cached != null) {
					if (parentCache && parentCache.nodes) {
						var offset = index - parentIndex;
						var end = offset + (dataType === ARRAY ? data : cached.nodes).length;
						clear(parentCache.nodes.slice(offset, end), parentCache.slice(offset, end))
					}
					else if (cached.nodes) clear(cached.nodes, cached)
				}
				cached = new data.constructor;
				if (cached.tag) cached = {}; //if constructor creates a virtual dom element, use a blank object as the base cached node instead of copying the virtual el (#277)
				cached.nodes = []
			}

			if (dataType === ARRAY) {
				//recursively flatten array
				for (var i = 0, len = data.length; i < len; i++) {
					if (type.call(data[i]) === ARRAY) {
						data = data.concat.apply([], data);
						i-- //check current index again and flatten until there are no more nested arrays at that index
						len = data.length
					}
				}

				var nodes = [], intact = cached.length === data.length, subArrayCount = 0;

				//keys algorithm: sort elements without recreating them if keys are present
				//1) create a map of all existing keys, and mark all for deletion
				//2) add new keys to map and mark them for addition
				//3) if key exists in new list, change action from deletion to a move
				//4) for each key, handle its corresponding action as marked in previous steps
				var DELETION = 1, INSERTION = 2 , MOVE = 3;
				var existing = {}, shouldMaintainIdentities = false;
				for (var i = 0; i < cached.length; i++) {
					if (cached[i] && cached[i].attrs && cached[i].attrs.key != null) {
						shouldMaintainIdentities = true;
						existing[cached[i].attrs.key] = {action: DELETION, index: i}
					}
				}

				var guid = 0
				for (var i = 0, len = data.length; i < len; i++) {
					if (data[i] && data[i].attrs && data[i].attrs.key != null) {
						for (var j = 0, len = data.length; j < len; j++) {
							if (data[j] && data[j].attrs && data[j].attrs.key == null) data[j].attrs.key = "__mithril__" + guid++
						}
						break
					}
				}

				if (shouldMaintainIdentities) {
					var keysDiffer = false
					if (data.length != cached.length) keysDiffer = true
					else for (var i = 0, cachedCell, dataCell; cachedCell = cached[i], dataCell = data[i]; i++) {
						if (cachedCell.attrs && dataCell.attrs && cachedCell.attrs.key != dataCell.attrs.key) {
							keysDiffer = true
							break
						}
					}

					if (keysDiffer) {
						for (var i = 0, len = data.length; i < len; i++) {
							if (data[i] && data[i].attrs) {
								if (data[i].attrs.key != null) {
									var key = data[i].attrs.key;
									if (!existing[key]) existing[key] = {action: INSERTION, index: i};
									else existing[key] = {
										action: MOVE,
										index: i,
										from: existing[key].index,
										element: cached.nodes[existing[key].index] || $document.createElement("div")
									}
								}
							}
						}
						var actions = []
						for (var prop in existing) actions.push(existing[prop])
						var changes = actions.sort(sortChanges);
						var newCached = new Array(cached.length)
						newCached.nodes = cached.nodes.slice()

						for (var i = 0, change; change = changes[i]; i++) {
							if (change.action === DELETION) {
								clear(cached[change.index].nodes, cached[change.index]);
								newCached.splice(change.index, 1)
							}
							if (change.action === INSERTION) {
								var dummy = $document.createElement("div");
								dummy.key = data[change.index].attrs.key;
								parentElement.insertBefore(dummy, parentElement.childNodes[change.index] || null);
								newCached.splice(change.index, 0, {attrs: {key: data[change.index].attrs.key}, nodes: [dummy]})
								newCached.nodes[change.index] = dummy
							}

							if (change.action === MOVE) {
								if (parentElement.childNodes[change.index] !== change.element && change.element !== null) {
									parentElement.insertBefore(change.element, parentElement.childNodes[change.index] || null)
								}
								newCached[change.index] = cached[change.from]
								newCached.nodes[change.index] = change.element
							}
						}
						cached = newCached;
					}
				}
				//end key algorithm

				for (var i = 0, cacheCount = 0, len = data.length; i < len; i++) {
					//diff each item in the array
					var item = build(parentElement, parentTag, cached, index, data[i], cached[cacheCount], shouldReattach, index + subArrayCount || subArrayCount, editable, namespace, configs);
					if (item === undefined) continue;
					if (!item.nodes.intact) intact = false;
					if (item.$trusted) {
						//fix offset of next element if item was a trusted string w/ more than one html element
						//the first clause in the regexp matches elements
						//the second clause (after the pipe) matches text nodes
						subArrayCount += (item.match(/<[^\/]|\>\s*[^<]/g) || [0]).length
					}
					else subArrayCount += type.call(item) === ARRAY ? item.length : 1;
					cached[cacheCount++] = item
				}
				if (!intact) {
					//diff the array itself

					//update the list of DOM nodes by collecting the nodes from each item
					for (var i = 0, len = data.length; i < len; i++) {
						if (cached[i] != null) nodes.push.apply(nodes, cached[i].nodes)
					}
					//remove items from the end of the array if the new array is shorter than the old one
					//if errors ever happen here, the issue is most likely a bug in the construction of the `cached` data structure somewhere earlier in the program
					for (var i = 0, node; node = cached.nodes[i]; i++) {
						if (node.parentNode != null && nodes.indexOf(node) < 0) clear([node], [cached[i]])
					}
					if (data.length < cached.length) cached.length = data.length;
					cached.nodes = nodes
				}
			}
			else if (data != null && dataType === OBJECT) {
				var views = [], controllers = []
				while (data.view) {
					var view = data.view.$original || data.view
					var controllerIndex = m.redraw.strategy() == "diff" && cached.views ? cached.views.indexOf(view) : -1
					var controller = controllerIndex > -1 ? cached.controllers[controllerIndex] : new (data.controller || noop)
					var key = data && data.attrs && data.attrs.key
					data = pendingRequests == 0 || (cached && cached.controllers && cached.controllers.indexOf(controller) > -1) ? data.view(controller) : {tag: "placeholder"}
					if (data.subtree === "retain") return cached;
					if (key) {
						if (!data.attrs) data.attrs = {}
						data.attrs.key = key
					}
					if (controller.onunload) unloaders.push({controller: controller, handler: controller.onunload})
					views.push(view)
					controllers.push(controller)
				}
				if (!data.tag && controllers.length) throw new Error("Component template must return a virtual element, not an array, string, etc.")
				if (!data.attrs) data.attrs = {};
				if (!cached.attrs) cached.attrs = {};

				var dataAttrKeys = Object.keys(data.attrs)
				var hasKeys = dataAttrKeys.length > ("key" in data.attrs ? 1 : 0)
				//if an element is different enough from the one in cache, recreate it
				if (data.tag != cached.tag || dataAttrKeys.sort().join() != Object.keys(cached.attrs).sort().join() || data.attrs.id != cached.attrs.id || data.attrs.key != cached.attrs.key || (m.redraw.strategy() == "all" && (!cached.configContext || cached.configContext.retain !== true)) || (m.redraw.strategy() == "diff" && cached.configContext && cached.configContext.retain === false)) {
					if (cached.nodes.length) clear(cached.nodes);
					if (cached.configContext && typeof cached.configContext.onunload === FUNCTION) cached.configContext.onunload()
					if (cached.controllers) {
						for (var i = 0, controller; controller = cached.controllers[i]; i++) {
							if (typeof controller.onunload === FUNCTION) controller.onunload({preventDefault: noop})
						}
					}
				}
				if (type.call(data.tag) != STRING) return;

				var node, isNew = cached.nodes.length === 0;
				if (data.attrs.xmlns) namespace = data.attrs.xmlns;
				else if (data.tag === "svg") namespace = "http://www.w3.org/2000/svg";
				else if (data.tag === "math") namespace = "http://www.w3.org/1998/Math/MathML";

				if (isNew) {
					if (data.attrs.is) node = namespace === undefined ? $document.createElement(data.tag, data.attrs.is) : $document.createElementNS(namespace, data.tag, data.attrs.is);
					else node = namespace === undefined ? $document.createElement(data.tag) : $document.createElementNS(namespace, data.tag);
					cached = {
						tag: data.tag,
						//set attributes first, then create children
						attrs: hasKeys ? setAttributes(node, data.tag, data.attrs, {}, namespace) : data.attrs,
						children: data.children != null && data.children.length > 0 ?
							build(node, data.tag, undefined, undefined, data.children, cached.children, true, 0, data.attrs.contenteditable ? node : editable, namespace, configs) :
							data.children,
						nodes: [node]
					};
					if (controllers.length) {
						cached.views = views
						cached.controllers = controllers
						for (var i = 0, controller; controller = controllers[i]; i++) {
							if (controller.onunload && controller.onunload.$old) controller.onunload = controller.onunload.$old
							if (pendingRequests && controller.onunload) {
								var onunload = controller.onunload
								controller.onunload = noop
								controller.onunload.$old = onunload
							}
						}
					}

					if (cached.children && !cached.children.nodes) cached.children.nodes = [];
					//edge case: setting value on <select> doesn't work before children exist, so set it again after children have been created
					if (data.tag === "select" && "value" in data.attrs) setAttributes(node, data.tag, {value: data.attrs.value}, {}, namespace);
					parentElement.insertBefore(node, parentElement.childNodes[index] || null)
				}
				else {
					node = cached.nodes[0];
					if (hasKeys) setAttributes(node, data.tag, data.attrs, cached.attrs, namespace);
					cached.children = build(node, data.tag, undefined, undefined, data.children, cached.children, false, 0, data.attrs.contenteditable ? node : editable, namespace, configs);
					cached.nodes.intact = true;
					if (controllers.length) {
						cached.views = views
						cached.controllers = controllers
					}
					if (shouldReattach === true && node != null) parentElement.insertBefore(node, parentElement.childNodes[index] || null)
				}
				//schedule configs to be called. They are called after `build` finishes running
				if (typeof data.attrs["config"] === FUNCTION) {
					var context = cached.configContext = cached.configContext || {};

					// bind
					var callback = function(data, args) {
						return function() {
							return data.attrs["config"].apply(data, args)
						}
					};
					configs.push(callback(data, [node, !isNew, context, cached]))
				}
			}
			else if (typeof data != FUNCTION) {
				//handle text nodes
				var nodes;
				if (cached.nodes.length === 0) {
					if (data.$trusted) {
						nodes = injectHTML(parentElement, index, data)
					}
					else {
						nodes = [$document.createTextNode(data)];
						if (!parentElement.nodeName.match(voidElements)) parentElement.insertBefore(nodes[0], parentElement.childNodes[index] || null)
					}
					cached = "string number boolean".indexOf(typeof data) > -1 ? new data.constructor(data) : data;
					cached.nodes = nodes
				}
				else if (cached.valueOf() !== data.valueOf() || shouldReattach === true) {
					nodes = cached.nodes;
					if (!editable || editable !== $document.activeElement) {
						if (data.$trusted) {
							clear(nodes, cached);
							nodes = injectHTML(parentElement, index, data)
						}
						else {
							//corner case: replacing the nodeValue of a text node that is a child of a textarea/contenteditable doesn't work
							//we need to update the value property of the parent textarea or the innerHTML of the contenteditable element instead
							if (parentTag === "textarea") parentElement.value = data;
							else if (editable) editable.innerHTML = data;
							else {
								if (nodes[0].nodeType === 1 || nodes.length > 1) { //was a trusted string
									clear(cached.nodes, cached);
									nodes = [$document.createTextNode(data)]
								}
								parentElement.insertBefore(nodes[0], parentElement.childNodes[index] || null);
								nodes[0].nodeValue = data
							}
						}
					}
					cached = new data.constructor(data);
					cached.nodes = nodes
				}
				else cached.nodes.intact = true
			}

			return cached
		}
		function sortChanges(a, b) {return a.action - b.action || a.index - b.index}
		function setAttributes(node, tag, dataAttrs, cachedAttrs, namespace) {
			for (var attrName in dataAttrs) {
				var dataAttr = dataAttrs[attrName];
				var cachedAttr = cachedAttrs[attrName];
				if (!(attrName in cachedAttrs) || (cachedAttr !== dataAttr)) {
					cachedAttrs[attrName] = dataAttr;
					try {
						//`config` isn't a real attributes, so ignore it
						if (attrName === "config" || attrName == "key") continue;
						//hook event handlers to the auto-redrawing system
						else if (typeof dataAttr === FUNCTION && attrName.indexOf("on") === 0) {
							node[attrName] = autoredraw(dataAttr, node)
						}
						//handle `style: {...}`
						else if (attrName === "style" && dataAttr != null && type.call(dataAttr) === OBJECT) {
							for (var rule in dataAttr) {
								if (cachedAttr == null || cachedAttr[rule] !== dataAttr[rule]) node.style[rule] = dataAttr[rule]
							}
							for (var rule in cachedAttr) {
								if (!(rule in dataAttr)) node.style[rule] = ""
							}
						}
						//handle SVG
						else if (namespace != null) {
							if (attrName === "href") node.setAttributeNS("http://www.w3.org/1999/xlink", "href", dataAttr);
							else if (attrName === "className") node.setAttribute("class", dataAttr);
							else node.setAttribute(attrName, dataAttr)
						}
						//handle cases that are properties (but ignore cases where we should use setAttribute instead)
						//- list and form are typically used as strings, but are DOM element references in js
						//- when using CSS selectors (e.g. `m("[style='']")`), style is used as a string, but it's an object in js
						else if (attrName in node && !(attrName === "list" || attrName === "style" || attrName === "form" || attrName === "type" || attrName === "width" || attrName === "height")) {
							//#348 don't set the value if not needed otherwise cursor placement breaks in Chrome
							if (tag !== "input" || node[attrName] !== dataAttr) node[attrName] = dataAttr
						}
						else node.setAttribute(attrName, dataAttr)
					}
					catch (e) {
						//swallow IE's invalid argument errors to mimic HTML's fallback-to-doing-nothing-on-invalid-attributes behavior
						if (e.message.indexOf("Invalid argument") < 0) throw e
					}
				}
				//#348 dataAttr may not be a string, so use loose comparison (double equal) instead of strict (triple equal)
				else if (attrName === "value" && tag === "input" && node.value != dataAttr) {
					node.value = dataAttr
				}
			}
			return cachedAttrs
		}
		function clear(nodes, cached) {
			for (var i = nodes.length - 1; i > -1; i--) {
				if (nodes[i] && nodes[i].parentNode) {
					try {nodes[i].parentNode.removeChild(nodes[i])}
					catch (e) {} //ignore if this fails due to order of events (see http://stackoverflow.com/questions/21926083/failed-to-execute-removechild-on-node)
					cached = [].concat(cached);
					if (cached[i]) unload(cached[i])
				}
			}
			if (nodes.length != 0) nodes.length = 0
		}
		function unload(cached) {
			if (cached.configContext && typeof cached.configContext.onunload === FUNCTION) {
				cached.configContext.onunload();
				cached.configContext.onunload = null
			}
			if (cached.controllers) {
				for (var i = 0, controller; controller = cached.controllers[i]; i++) {
					if (typeof controller.onunload === FUNCTION) controller.onunload({preventDefault: noop});
				}
			}
			if (cached.children) {
				if (type.call(cached.children) === ARRAY) {
					for (var i = 0, child; child = cached.children[i]; i++) unload(child)
				}
				else if (cached.children.tag) unload(cached.children)
			}
		}
		function injectHTML(parentElement, index, data) {
			var nextSibling = parentElement.childNodes[index];
			if (nextSibling) {
				var isElement = nextSibling.nodeType != 1;
				var placeholder = $document.createElement("span");
				if (isElement) {
					parentElement.insertBefore(placeholder, nextSibling || null);
					placeholder.insertAdjacentHTML("beforebegin", data);
					parentElement.removeChild(placeholder)
				}
				else nextSibling.insertAdjacentHTML("beforebegin", data)
			}
			else parentElement.insertAdjacentHTML("beforeend", data);
			var nodes = [];
			while (parentElement.childNodes[index] !== nextSibling) {
				nodes.push(parentElement.childNodes[index]);
				index++
			}
			return nodes
		}
		function autoredraw(callback, object) {
			return function(e) {
				e = e || event;
				m.redraw.strategy("diff");
				m.startComputation();
				try {return callback.call(object, e)}
				finally {
					endFirstComputation()
				}
			}
		}

		var html;
		var documentNode = {
			appendChild: function(node) {
				if (html === undefined) html = $document.createElement("html");
				if ($document.documentElement && $document.documentElement !== node) {
					$document.replaceChild(node, $document.documentElement)
				}
				else $document.appendChild(node);
				this.childNodes = $document.childNodes
			},
			insertBefore: function(node) {
				this.appendChild(node)
			},
			childNodes: []
		};
		var nodeCache = [], cellCache = {};
		m.render = function(root, cell, forceRecreation) {
			var configs = [];
			if (!root) throw new Error("Ensure the DOM element being passed to m.route/m.mount/m.render is not undefined.");
			var id = getCellCacheKey(root);
			var isDocumentRoot = root === $document;
			var node = isDocumentRoot || root === $document.documentElement ? documentNode : root;
			if (isDocumentRoot && cell.tag != "html") cell = {tag: "html", attrs: {}, children: cell};
			if (cellCache[id] === undefined) clear(node.childNodes);
			if (forceRecreation === true) reset(root);
			cellCache[id] = build(node, null, undefined, undefined, cell, cellCache[id], false, 0, null, undefined, configs);
			for (var i = 0, len = configs.length; i < len; i++) configs[i]()
		};
		function getCellCacheKey(element) {
			var index = nodeCache.indexOf(element);
			return index < 0 ? nodeCache.push(element) - 1 : index
		}

		m.trust = function(value) {
			value = new String(value);
			value.$trusted = true;
			return value
		};

		function gettersetter(store) {
			var prop = function() {
				if (arguments.length) store = arguments[0];
				return store
			};

			prop.toJSON = function() {
				return store
			};

			return prop
		}

		m.prop = function (store) {
			//note: using non-strict equality check here because we're checking if store is null OR undefined
			if (((store != null && type.call(store) === OBJECT) || typeof store === FUNCTION) && typeof store.then === FUNCTION) {
				return propify(store)
			}

			return gettersetter(store)
		};

		var roots = [], components = [], controllers = [], lastRedrawId = null, lastRedrawCallTime = 0, computePreRedrawHook = null, computePostRedrawHook = null, prevented = false, topComponent, unloaders = [];
		var FRAME_BUDGET = 16; //60 frames per second = 1 call per 16 ms
		function parameterize(component, args) {
			var controller = function() {
				return (component.controller || noop).apply(this, args) || this
			}
			var view = function(ctrl) {
				if (arguments.length > 1) args = args.concat([].slice.call(arguments, 1))
				return component.view.apply(component, args ? [ctrl].concat(args) : [ctrl])
			}
			view.$original = component.view
			var output = {controller: controller, view: view}
			if (args[0] && args[0].key != null) output.attrs = {key: args[0].key}
			return output
		}
		m.component = function(component) {
			return parameterize(component, [].slice.call(arguments, 1))
		}
		m.mount = m.module = function(root, component) {
			if (!root) throw new Error("Please ensure the DOM element exists before rendering a template into it.");
			var index = roots.indexOf(root);
			if (index < 0) index = roots.length;

			var isPrevented = false;
			var event = {preventDefault: function() {
				isPrevented = true;
				computePreRedrawHook = computePostRedrawHook = null;
			}};
			for (var i = 0, unloader; unloader = unloaders[i]; i++) {
				unloader.handler.call(unloader.controller, event)
				unloader.controller.onunload = null
			}
			if (isPrevented) {
				for (var i = 0, unloader; unloader = unloaders[i]; i++) unloader.controller.onunload = unloader.handler
			}
			else unloaders = []

			if (controllers[index] && typeof controllers[index].onunload === FUNCTION) {
				controllers[index].onunload(event)
			}

			if (!isPrevented) {
				m.redraw.strategy("all");
				m.startComputation();
				roots[index] = root;
				if (arguments.length > 2) component = subcomponent(component, [].slice.call(arguments, 2))
				var currentComponent = topComponent = component = component || {controller: function() {}};
				var constructor = component.controller || noop
				var controller = new constructor;
				//controllers may call m.mount recursively (via m.route redirects, for example)
				//this conditional ensures only the last recursive m.mount call is applied
				if (currentComponent === topComponent) {
					controllers[index] = controller;
					components[index] = component
				}
				endFirstComputation();
				return controllers[index]
			}
		};
		var redrawing = false
		m.redraw = function(force) {
			if (redrawing) return
			redrawing = true
			//lastRedrawId is a positive number if a second redraw is requested before the next animation frame
			//lastRedrawID is null if it's the first redraw and not an event handler
			if (lastRedrawId && force !== true) {
				//when setTimeout: only reschedule redraw if time between now and previous redraw is bigger than a frame, otherwise keep currently scheduled timeout
				//when rAF: always reschedule redraw
				if ($requestAnimationFrame === window.requestAnimationFrame || new Date - lastRedrawCallTime > FRAME_BUDGET) {
					if (lastRedrawId > 0) $cancelAnimationFrame(lastRedrawId);
					lastRedrawId = $requestAnimationFrame(redraw, FRAME_BUDGET)
				}
			}
			else {
				redraw();
				lastRedrawId = $requestAnimationFrame(function() {lastRedrawId = null}, FRAME_BUDGET)
			}
			redrawing = false
		};
		m.redraw.strategy = m.prop();
		function redraw() {
			if (computePreRedrawHook) {
				computePreRedrawHook()
				computePreRedrawHook = null
			}
			for (var i = 0, root; root = roots[i]; i++) {
				if (controllers[i]) {
					var args = components[i].controller && components[i].controller.$$args ? [controllers[i]].concat(components[i].controller.$$args) : [controllers[i]]
					m.render(root, components[i].view ? components[i].view(controllers[i], args) : "")
				}
			}
			//after rendering within a routed context, we need to scroll back to the top, and fetch the document title for history.pushState
			if (computePostRedrawHook) {
				computePostRedrawHook();
				computePostRedrawHook = null
			}
			lastRedrawId = null;
			lastRedrawCallTime = new Date;
			m.redraw.strategy("diff")
		}

		var pendingRequests = 0;
		m.startComputation = function() {pendingRequests++};
		m.endComputation = function() {
			pendingRequests = Math.max(pendingRequests - 1, 0);
			if (pendingRequests === 0) m.redraw()
		};
		var endFirstComputation = function() {
			if (m.redraw.strategy() == "none") {
				pendingRequests--
				m.redraw.strategy("diff")
			}
			else m.endComputation();
		}

		m.withAttr = function(prop, withAttrCallback) {
			return function(e) {
				e = e || event;
				var currentTarget = e.currentTarget || this;
				withAttrCallback(prop in currentTarget ? currentTarget[prop] : currentTarget.getAttribute(prop))
			}
		};

		//routing
		var modes = {pathname: "", hash: "#", search: "?"};
		var redirect = noop, routeParams, currentRoute, isDefaultRoute = false;
		m.route = function() {
			//m.route()
			if (arguments.length === 0) return currentRoute;
			//m.route(el, defaultRoute, routes)
			else if (arguments.length === 3 && type.call(arguments[1]) === STRING) {
				var root = arguments[0], defaultRoute = arguments[1], router = arguments[2];
				redirect = function(source) {
					var path = currentRoute = normalizeRoute(source);
					if (!routeByValue(root, router, path)) {
						if (isDefaultRoute) throw new Error("Ensure the default route matches one of the routes defined in m.route")
						isDefaultRoute = true
						m.route(defaultRoute, true)
						isDefaultRoute = false
					}
				};
				var listener = m.route.mode === "hash" ? "onhashchange" : "onpopstate";
				window[listener] = function() {
					var path = $location[m.route.mode]
					if (m.route.mode === "pathname") path += $location.search
					if (currentRoute != normalizeRoute(path)) {
						redirect(path)
					}
				};
				computePreRedrawHook = setScroll;
				window[listener]()
			}
			//config: m.route
			else if (arguments[0].addEventListener || arguments[0].attachEvent) {
				var element = arguments[0];
				var isInitialized = arguments[1];
				var context = arguments[2];
				var vdom = arguments[3];
				element.href = (m.route.mode !== 'pathname' ? $location.pathname : '') + modes[m.route.mode] + vdom.attrs.href;
				if (element.addEventListener) {
					element.removeEventListener("click", routeUnobtrusive);
					element.addEventListener("click", routeUnobtrusive)
				}
				else {
					element.detachEvent("onclick", routeUnobtrusive);
					element.attachEvent("onclick", routeUnobtrusive)
				}
			}
			//m.route(route, params, shouldReplaceHistoryEntry)
			else if (type.call(arguments[0]) === STRING) {
				var oldRoute = currentRoute;
				currentRoute = arguments[0];
				var args = arguments[1] || {}
				var queryIndex = currentRoute.indexOf("?")
				var params = queryIndex > -1 ? parseQueryString(currentRoute.slice(queryIndex + 1)) : {}
				for (var i in args) params[i] = args[i]
				var querystring = buildQueryString(params)
				var currentPath = queryIndex > -1 ? currentRoute.slice(0, queryIndex) : currentRoute
				if (querystring) currentRoute = currentPath + (currentPath.indexOf("?") === -1 ? "?" : "&") + querystring;

				var shouldReplaceHistoryEntry = (arguments.length === 3 ? arguments[2] : arguments[1]) === true || oldRoute === arguments[0];

				if (window.history.pushState) {
					computePreRedrawHook = setScroll
					computePostRedrawHook = function() {
						window.history[shouldReplaceHistoryEntry ? "replaceState" : "pushState"](null, $document.title, modes[m.route.mode] + currentRoute);
					};
					redirect(modes[m.route.mode] + currentRoute)
				}
				else {
					$location[m.route.mode] = currentRoute
					redirect(modes[m.route.mode] + currentRoute)
				}
			}
		};
		m.route.param = function(key) {
			if (!routeParams) throw new Error("You must call m.route(element, defaultRoute, routes) before calling m.route.param()")
			return routeParams[key]
		};
		m.route.mode = "search";
		function normalizeRoute(route) {
			return route.slice(modes[m.route.mode].length)
		}
		function routeByValue(root, router, path) {
			routeParams = {};

			var queryStart = path.indexOf("?");
			if (queryStart !== -1) {
				routeParams = parseQueryString(path.substr(queryStart + 1, path.length));
				path = path.substr(0, queryStart)
			}

			// Get all routes and check if there's
			// an exact match for the current path
			var keys = Object.keys(router);
			var index = keys.indexOf(path);
			if(index !== -1){
				m.mount(root, router[keys [index]]);
				return true;
			}

			for (var route in router) {
				if (route === path) {
					m.mount(root, router[route]);
					return true
				}

				var matcher = new RegExp("^" + route.replace(/:[^\/]+?\.{3}/g, "(.*?)").replace(/:[^\/]+/g, "([^\\/]+)") + "\/?$");

				if (matcher.test(path)) {
					path.replace(matcher, function() {
						var keys = route.match(/:[^\/]+/g) || [];
						var values = [].slice.call(arguments, 1, -2);
						for (var i = 0, len = keys.length; i < len; i++) routeParams[keys[i].replace(/:|\./g, "")] = decodeURIComponent(values[i])
						m.mount(root, router[route])
					});
					return true
				}
			}
		}
		function routeUnobtrusive(e) {
			e = e || event;
			if (e.ctrlKey || e.metaKey || e.which === 2) return;
			if (e.preventDefault) e.preventDefault();
			else e.returnValue = false;
			var currentTarget = e.currentTarget || e.srcElement;
			var args = m.route.mode === "pathname" && currentTarget.search ? parseQueryString(currentTarget.search.slice(1)) : {};
			while (currentTarget && currentTarget.nodeName.toUpperCase() != "A") currentTarget = currentTarget.parentNode
			m.route(currentTarget[m.route.mode].slice(modes[m.route.mode].length), args)
		}
		function setScroll() {
			if (m.route.mode != "hash" && $location.hash) $location.hash = $location.hash;
			else window.scrollTo(0, 0)
		}
		function buildQueryString(object, prefix) {
			var duplicates = {}
			var str = []
			for (var prop in object) {
				var key = prefix ? prefix + "[" + prop + "]" : prop
				var value = object[prop]
				var valueType = type.call(value)
				var pair = (value === null) ? encodeURIComponent(key) :
					valueType === OBJECT ? buildQueryString(value, key) :
					valueType === ARRAY ? value.reduce(function(memo, item) {
						if (!duplicates[key]) duplicates[key] = {}
						if (!duplicates[key][item]) {
							duplicates[key][item] = true
							return memo.concat(encodeURIComponent(key) + "=" + encodeURIComponent(item))
						}
						return memo
					}, []).join("&") :
					encodeURIComponent(key) + "=" + encodeURIComponent(value)
				if (value !== undefined) str.push(pair)
			}
			return str.join("&")
		}
		function parseQueryString(str) {
			if (str.charAt(0) === "?") str = str.substring(1);

			var pairs = str.split("&"), params = {};
			for (var i = 0, len = pairs.length; i < len; i++) {
				var pair = pairs[i].split("=");
				var key = decodeURIComponent(pair[0])
				var value = pair.length == 2 ? decodeURIComponent(pair[1]) : null
				if (params[key] != null) {
					if (type.call(params[key]) !== ARRAY) params[key] = [params[key]]
					params[key].push(value)
				}
				else params[key] = value
			}
			return params
		}
		m.route.buildQueryString = buildQueryString
		m.route.parseQueryString = parseQueryString

		function reset(root) {
			var cacheKey = getCellCacheKey(root);
			clear(root.childNodes, cellCache[cacheKey]);
			cellCache[cacheKey] = undefined
		}

		m.deferred = function () {
			var deferred = new Deferred();
			deferred.promise = propify(deferred.promise);
			return deferred
		};
		function propify(promise, initialValue) {
			var prop = m.prop(initialValue);
			promise.then(prop);
			prop.then = function(resolve, reject) {
				return propify(promise.then(resolve, reject), initialValue)
			};
			return prop
		}
		//Promiz.mithril.js | Zolmeister | MIT
		//a modified version of Promiz.js, which does not conform to Promises/A+ for two reasons:
		//1) `then` callbacks are called synchronously (because setTimeout is too slow, and the setImmediate polyfill is too big
		//2) throwing subclasses of Error cause the error to be bubbled up instead of triggering rejection (because the spec does not account for the important use case of default browser error handling, i.e. message w/ line number)
		function Deferred(successCallback, failureCallback) {
			var RESOLVING = 1, REJECTING = 2, RESOLVED = 3, REJECTED = 4;
			var self = this, state = 0, promiseValue = 0, next = [];

			self["promise"] = {};

			self["resolve"] = function(value) {
				if (!state) {
					promiseValue = value;
					state = RESOLVING;

					fire()
				}
				return this
			};

			self["reject"] = function(value) {
				if (!state) {
					promiseValue = value;
					state = REJECTING;

					fire()
				}
				return this
			};

			self.promise["then"] = function(successCallback, failureCallback) {
				var deferred = new Deferred(successCallback, failureCallback);
				if (state === RESOLVED) {
					deferred.resolve(promiseValue)
				}
				else if (state === REJECTED) {
					deferred.reject(promiseValue)
				}
				else {
					next.push(deferred)
				}
				return deferred.promise
			};

			function finish(type) {
				state = type || REJECTED;
				next.map(function(deferred) {
					state === RESOLVED && deferred.resolve(promiseValue) || deferred.reject(promiseValue)
				})
			}

			function thennable(then, successCallback, failureCallback, notThennableCallback) {
				if (((promiseValue != null && type.call(promiseValue) === OBJECT) || typeof promiseValue === FUNCTION) && typeof then === FUNCTION) {
					try {
						// count protects against abuse calls from spec checker
						var count = 0;
						then.call(promiseValue, function(value) {
							if (count++) return;
							promiseValue = value;
							successCallback()
						}, function (value) {
							if (count++) return;
							promiseValue = value;
							failureCallback()
						})
					}
					catch (e) {
						m.deferred.onerror(e);
						promiseValue = e;
						failureCallback()
					}
				} else {
					notThennableCallback()
				}
			}

			function fire() {
				// check if it's a thenable
				var then;
				try {
					then = promiseValue && promiseValue.then
				}
				catch (e) {
					m.deferred.onerror(e);
					promiseValue = e;
					state = REJECTING;
					return fire()
				}
				thennable(then, function() {
					state = RESOLVING;
					fire()
				}, function() {
					state = REJECTING;
					fire()
				}, function() {
					try {
						if (state === RESOLVING && typeof successCallback === FUNCTION) {
							promiseValue = successCallback(promiseValue)
						}
						else if (state === REJECTING && typeof failureCallback === "function") {
							promiseValue = failureCallback(promiseValue);
							state = RESOLVING
						}
					}
					catch (e) {
						m.deferred.onerror(e);
						promiseValue = e;
						return finish()
					}

					if (promiseValue === self) {
						promiseValue = TypeError();
						finish()
					}
					else {
						thennable(then, function () {
							finish(RESOLVED)
						}, finish, function () {
							finish(state === RESOLVING && RESOLVED)
						})
					}
				})
			}
		}
		m.deferred.onerror = function(e) {
			if (type.call(e) === "[object Error]" && !e.constructor.toString().match(/ Error/)) throw e
		};

		m.sync = function(args) {
			var method = "resolve";
			function synchronizer(pos, resolved) {
				return function(value) {
					results[pos] = value;
					if (!resolved) method = "reject";
					if (--outstanding === 0) {
						deferred.promise(results);
						deferred[method](results)
					}
					return value
				}
			}

			var deferred = m.deferred();
			var outstanding = args.length;
			var results = new Array(outstanding);
			if (args.length > 0) {
				for (var i = 0; i < args.length; i++) {
					args[i].then(synchronizer(i, true), synchronizer(i, false))
				}
			}
			else deferred.resolve([]);

			return deferred.promise
		};
		function identity(value) {return value}

		function ajax(options) {
			if (options.dataType && options.dataType.toLowerCase() === "jsonp") {
				var callbackKey = "mithril_callback_" + new Date().getTime() + "_" + (Math.round(Math.random() * 1e16)).toString(36);
				var script = $document.createElement("script");

				window[callbackKey] = function(resp) {
					script.parentNode.removeChild(script);
					options.onload({
						type: "load",
						target: {
							responseText: resp
						}
					});
					window[callbackKey] = undefined
				};

				script.onerror = function(e) {
					script.parentNode.removeChild(script);

					options.onerror({
						type: "error",
						target: {
							status: 500,
							responseText: JSON.stringify({error: "Error making jsonp request"})
						}
					});
					window[callbackKey] = undefined;

					return false
				};

				script.onload = function(e) {
					return false
				};

				script.src = options.url
					+ (options.url.indexOf("?") > 0 ? "&" : "?")
					+ (options.callbackKey ? options.callbackKey : "callback")
					+ "=" + callbackKey
					+ "&" + buildQueryString(options.data || {});
				$document.body.appendChild(script)
			}
			else {
				var xhr = new window.XMLHttpRequest;
				xhr.open(options.method, options.url, true, options.user, options.password);
				xhr.onreadystatechange = function() {
					if (xhr.readyState === 4) {
						if (xhr.status >= 200 && xhr.status < 300) options.onload({type: "load", target: xhr});
						else options.onerror({type: "error", target: xhr})
					}
				};
				if (options.serialize === JSON.stringify && options.data && options.method !== "GET") {
					xhr.setRequestHeader("Content-Type", "application/json; charset=utf-8")
				}
				if (options.deserialize === JSON.parse) {
					xhr.setRequestHeader("Accept", "application/json, text/*");
				}
				if (typeof options.config === FUNCTION) {
					var maybeXhr = options.config(xhr, options);
					if (maybeXhr != null) xhr = maybeXhr
				}

				var data = options.method === "GET" || !options.data ? "" : options.data
				if (data && (type.call(data) != STRING && data.constructor != window.FormData)) {
					throw "Request data should be either be a string or FormData. Check the `serialize` option in `m.request`";
				}
				xhr.send(data);
				return xhr
			}
		}
		function bindData(xhrOptions, data, serialize) {
			if (xhrOptions.method === "GET" && xhrOptions.dataType != "jsonp") {
				var prefix = xhrOptions.url.indexOf("?") < 0 ? "?" : "&";
				var querystring = buildQueryString(data);
				xhrOptions.url = xhrOptions.url + (querystring ? prefix + querystring : "")
			}
			else xhrOptions.data = serialize(data);
			return xhrOptions
		}
		function parameterizeUrl(url, data) {
			var tokens = url.match(/:[a-z]\w+/gi);
			if (tokens && data) {
				for (var i = 0; i < tokens.length; i++) {
					var key = tokens[i].slice(1);
					url = url.replace(tokens[i], data[key]);
					delete data[key]
				}
			}
			return url
		}

		m.request = function(xhrOptions) {
			if (xhrOptions.background !== true) m.startComputation();
			var deferred = new Deferred();
			var isJSONP = xhrOptions.dataType && xhrOptions.dataType.toLowerCase() === "jsonp";
			var serialize = xhrOptions.serialize = isJSONP ? identity : xhrOptions.serialize || JSON.stringify;
			var deserialize = xhrOptions.deserialize = isJSONP ? identity : xhrOptions.deserialize || JSON.parse;
			var extract = isJSONP ? function(jsonp) {return jsonp.responseText} : xhrOptions.extract || function(xhr) {
				return xhr.responseText.length === 0 && deserialize === JSON.parse ? null : xhr.responseText
			};
			xhrOptions.method = (xhrOptions.method || 'GET').toUpperCase();
			xhrOptions.url = parameterizeUrl(xhrOptions.url, xhrOptions.data);
			xhrOptions = bindData(xhrOptions, xhrOptions.data, serialize);
			xhrOptions.onload = xhrOptions.onerror = function(e) {
				try {
					e = e || event;
					var unwrap = (e.type === "load" ? xhrOptions.unwrapSuccess : xhrOptions.unwrapError) || identity;
					var response = unwrap(deserialize(extract(e.target, xhrOptions)), e.target);
					if (e.type === "load") {
						if (type.call(response) === ARRAY && xhrOptions.type) {
							for (var i = 0; i < response.length; i++) response[i] = new xhrOptions.type(response[i])
						}
						else if (xhrOptions.type) response = new xhrOptions.type(response)
					}
					deferred[e.type === "load" ? "resolve" : "reject"](response)
				}
				catch (e) {
					m.deferred.onerror(e);
					deferred.reject(e)
				}
				if (xhrOptions.background !== true) m.endComputation()
			};
			ajax(xhrOptions);
			deferred.promise = propify(deferred.promise, xhrOptions.initialValue);
			return deferred.promise
		};

		//testing API
		m.deps = function(mock) {
			initialize(window = mock || window);
			return window;
		};
		//for internal testing only, do not use `m.deps.factory`
		m.deps.factory = app;

		return m
	})(typeof window != "undefined" ? window : {});

	if (typeof module != "undefined" && module !== null && module.exports) module.exports = m;
	else if (true) !(__WEBPACK_AMD_DEFINE_RESULT__ = function() {return m}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(4)(module)))

/***/ },
/* 4 */
/***/ function(module, exports) {

	module.exports = function(module) {
		if(!module.webpackPolyfill) {
			module.deprecate = function() {};
			module.paths = [];
			// module.parent = undefined by default
			module.children = [];
			module.webpackPolyfill = 1;
		}
		return module;
	}


/***/ },
/* 5 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(__dirname) {var compiler = __webpack_require__(6),
		jade = __webpack_require__(8),
		beautify = __webpack_require__(45).js_beautify,
		fs = __webpack_require__(49),
		path = __webpack_require__(32);

	function copyObject(source, props, object, respect) {
		object = object || { };

		var index = -1,
		length = props.length;

		while (++index < length) {
			var key = props[index];
			if( !respect || !object[key] )
				object[key] = source[key];
		}
		return object;
	}
	function assign( ){
		var obj = arguments[0];
		var args = Array.prototype.slice.call(arguments, 1);
		args.forEach(function( element ){
			copyObject( element, Object.keys(element), obj );
		});
		return obj;
	}

	module.exports = {
		compileJADE: function (markup, options) {
			options = options || {};
			options.compiler = compiler;

			var res = (options.prefix || '') + jade.render(markup, options) + (options.postfix || '');
			return options.pretty ? beautify( res, { indent_size: options.indent_size || 4, indent_char: options.indent_char || ' ' } ): res;
		},
		generateMithrilJS: function( jadeContent, jsTemplate, options ){
			options = options || {};

			jsTemplate = jsTemplate || fs.readFileSync( path.join( __dirname, 'Mithril.template' ), { encoding: 'utf8' });
			var jsParts = jsTemplate.split( options.token || '$$$$' );

			options = assign( { pretty: true, context: true, prefix: jsParts[0], postfix: jsParts[1], indent_size: 1, indent_char: '\t' }, options );

			var mithrilView = this.compileJADE( jadeContent, options );
			return mithrilView + '\n';
		}
	};

	/* WEBPACK VAR INJECTION */}.call(exports, "/"))

/***/ },
/* 6 */
/***/ function(module, exports, __webpack_require__) {

	var _ = __webpack_require__(7);

	var toPush = function (elements) {
		elements = Array.isArray( elements ) ? elements : [ elements ];
		return elements.map(function(element){
			return 'buf.push(' + JSON.stringify(element) + ');';
		}).join('\n');
	};

	var cleanString = function(string){
		if(!string) return string;
		if(!string.charAt) string = string + '';
		return string && (string.charAt(0) === '\'' || string.charAt(0) === '\"') ? string.substring(1, string.length-1) : string;
	};

	var quote = function(string){
		return string.replace(/\"/g, '\\\"').replace(/\'/g, '\\\'');
	};

	var nodeType = function(node){
		var types = node.attrs.filter( function(att){
			return att.name === 'type';
		} ).map( function( attr ){
			return attr.val;
		} );
		return types.length > 0 ? JSON.parse(types[0]) : null;
	};

	var getEventBindings = function( node ){
		var types = node.attrs.filter( function(att){
			return att.name.startsWith('data-event-');
		} );
		return types;
	};

	var hasBindingAttribute = function( node, bindingName ){
		var types =  node.attrs.filter( function(att){
			return att.name === bindingName;
		} );
		return types.length > 0;
	};

	var getBindingAttribute = function( node, bindingName ){
		var types = node.attrs.filter( function(att){
			return att.name === bindingName;
		} ).map( function( attr ){
			return attr.val;
		});
		return types.length > 0 ? JSON.parse( types[0] ) : null;
	};

	var referToPlain = '!';
	var referToRoot = '$';
	var itemReferer = 'item';
	var rootReferer = 'ctrl[ modelName ]';
	var referencePatter = /^[\w\.]+/g;
	var textElements = ['p', 'text', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'option'];

	var typesToIgnore = ['Comment', 'BlockComment'];

	function capitalizeFirstLetter(string) {
		return string.charAt(0).toUpperCase() + string.slice(1);
	}
	var Compiler = function (node, options) {
		var compiler = {
			code: [ ],

			visitBlock: function( node, bindingPath, inArray ){
				var self = this;
				(node.nodes || []).forEach( function(subnode){
					self.visit( subnode, bindingPath, inArray );
				} );
			},
			visitMemberBinding: function(node, bindingPath, inArray, bindName){
				var type = nodeType(node);
				if( (node.name !== 'input') || (type !=='checkbox') ) return;

				var self = this;
				var isReferringToRoot = bindName.charAt(0) === referToRoot;
				var binder = isReferringToRoot ? bindName.substring(1) : bindName;
				var reference = isReferringToRoot ? '' : (!inArray ? rootReferer : itemReferer) + '.';

				var capName = capitalizeFirstLetter( bindName );
				self.code.push( 'onclick: function(event){ var el = event.target; var op = el.checked?\'addTo\':\'removeFrom\'; ctrl[ op + \'' + capName + '\']( el.value || el.name, true); },' );
			},
			visitFieldBinding: function(node, bindingPath, inArray, bindName){
				var self = this;

				var isReferringToRoot = bindName.charAt(0) === referToRoot;
				var binder = isReferringToRoot ? bindName.substring(1) : bindName;
				var reference = isReferringToRoot ? '' : (!inArray ? rootReferer : itemReferer) + '.';

				var bindOperator = textElements.indexOf( node.name ) >= 0 ? 'textContent' : 'value';

				self.code.push( bindOperator + ': ' + reference + binder + '(),' );

				var type = nodeType(node);
				if( (node.name === 'input') && (type==='checkbox') ){
					self.code.push( 'onclick: m.withAttr(\'checked\', ' + reference + binder + ' ), checked: ' + reference + binder + '(),' );
				}
				else if( (node.name === 'input') || (node.name === 'textarea') ){
					self.code.push( 'oninput: m.withAttr(\'value\', ' + reference + binder + ' ),' );
				}
				else if( (node.name === 'select') ){
					self.code.push( 'onchange: m.withAttr(\'value\', ' + reference + binder + ' ),' );
				}
			},
			visitValueBinding: function(node, bindingPath, inArray, bindName){
				var self = this;

				var realRef = '';
				var plainJS = bindName.charAt( bindName.length-1 ) === referToPlain;
				if( plainJS )
					bindName = bindName.substring( 0, bindName.length-1 );
				if( bindName.indexOf('context') === 0 ){
					realRef = bindName;
				} else {
					var isReferringToRoot = bindName.charAt(0) === referToRoot;
					var binder = isReferringToRoot ? bindName.substring(1) : bindName;
					var reference = isReferringToRoot ? '' : (!inArray ? rootReferer : itemReferer) + '.';
					realRef = reference + binder + (plainJS?'':'()');
				}

				var bindOperator = textElements.indexOf( node.name ) >= 0 ? 'textContent' : 'value';
				self.code.push( bindOperator + ': ' + realRef + ',' );
			},
			visitAttributes: function( node, bindingPath, inArray, arrayBinding ){
				var self = this;

				self.code.push( ' { ');
				var fieldBinding = cleanString( getBindingAttribute( node, 'data-bind' ) );
				if( fieldBinding ){
					bindingPath = (bindingPath ? bindingPath + '.' : '') + fieldBinding;
					self.visitFieldBinding( node, bindingPath, inArray, fieldBinding );
				}
				var valueBinding = cleanString( getBindingAttribute( node, 'data-value' ) );
				if( valueBinding ){
					bindingPath = (bindingPath ? bindingPath + '.' : '') + valueBinding;
					self.visitValueBinding( node, bindingPath, inArray, valueBinding );
				}
				var memberBinding =  cleanString( getBindingAttribute( node, 'data-member' ) );
				if( memberBinding ){
					bindingPath = (bindingPath ? bindingPath + '.' : '') + memberBinding;
					self.visitMemberBinding( node, bindingPath, inArray, memberBinding );
				}

				var tapBinding = cleanString( getBindingAttribute( node, 'data-tap' ) );
				var visibilityBinding = cleanString( getBindingAttribute( node, 'data-visible' ) );
				var displayBinding = cleanString( getBindingAttribute( node, 'data-display' ) );
				var attributeBinding = cleanString( getBindingAttribute( node, 'data-attr' ) );
				var styleBinding = cleanString( getBindingAttribute( node, 'data-style' ) );
				var selectBinding = cleanString( getBindingAttribute( node, 'data-select' ) );
				var htmlBinding = cleanString( getBindingAttribute( node, 'data-html' ) );
				var eventBindings = getEventBindings( node );
				if( options.context && (arrayBinding || valueBinding || fieldBinding || memberBinding || tapBinding || visibilityBinding || displayBinding || attributeBinding || styleBinding || selectBinding || htmlBinding || eventBindings.length>0 ) ){
					var itemSpec = inArray ? 'array: array, item: item, index: index,' : ' ';
					var visiSpec = visibilityBinding ? "\'data-visible\': "+ JSON.stringify( visibilityBinding ) +"," : '';
					var displaySpec = displayBinding ? "\'data-display\': "+ JSON.stringify( displayBinding ) +"," : '';
					var attSpec = attributeBinding ? "\'data-attr\': "+ JSON.stringify( attributeBinding ) +"," : '';
					var styleSpec = styleBinding ? "\'data-style\': "+ JSON.stringify( styleBinding ) +"," : '';
					var selectSpec = selectBinding ? "\'data-select\': "+ JSON.stringify( selectBinding ) +"," : '';
					var htmlSpec = htmlBinding ? "\'data-html\': "+ JSON.stringify( htmlBinding ) +"," : '';
					var tapSpec = tapBinding ? "\'data-tap\': "+ JSON.stringify( tapBinding ) +"," : '';
					//var tapSpec = tapBinding ? "\'data-tap\':\'true\'," : '';
					var memberSpec = memberBinding ? "\'data-member\': "+ JSON.stringify( memberBinding ) +"," : '';
					var eventBindingCode = '';
					eventBindings.forEach( function(eventBinding){
						eventBindingCode = eventBindingCode.concat( "\'" + eventBinding.name + "\': " + eventBinding.val + "," );
					} );
					self.code.push( 'config: createConfig( ctrl, controlOptions, viewName, modelName, context, ' + rootReferer + ', \''+ bindingPath +'\', { ' + itemSpec + memberSpec + visiSpec + displaySpec +  attSpec + styleSpec + selectSpec + htmlSpec + tapSpec + eventBindingCode + ' V: ctrl._validation, clearElement: context.clearElement, invalidElement: context.invalidElement, validElement: context.validElement } ),' );
				}

				var classes = [], value;
				node.attrs.forEach(function(attribute){
					if( attribute.name === 'class' ){
						value = cleanString( attribute.val );
						classes.push( value );
					}
					else{
						value = _.isString( attribute.val ) ? cleanString( attribute.val ) : attribute.val;
						self.code.push( '\"' + attribute.name + '\"' + ': \"' + value + '\",' );
					}
				});
				self.code.push( '\"className\": ' + '\"' + classes.join(' ') + '\"' );
				self.code.push( ' }, ');
			},
			visitArrayBinding: function(node, bindingPath, inArray, bindName, filterBinding){
				var self = this;

				var realRef = '';
				if( bindName.indexOf('context') === 0 )
					realRef = bindName;
				else{
					var isReferringToRoot = bindName.charAt(0) === referToRoot;
					var binder = isReferringToRoot ? bindName.substring(1) : bindName;
					var reference = !inArray || isReferringToRoot ? rootReferer : itemReferer;
					realRef = reference + '.' + binder;
				}
				self.code.push(' ' + realRef + (filterBinding?'.filter( ctrl[modelName].'+filterBinding+' )':'') + '.map( function(item, index, array ) { return ');
			},
			visitTag: function( node, bindingPath, inArray ){
				var self = this;

				self.code.push( 'm ("', node.name, '",');

				var arrayBinding = cleanString( getBindingAttribute( node, 'data-each' ) );
				var filterBinding = cleanString( getBindingAttribute( node, 'data-filter' ) );
				var fieldBinding = cleanString( getBindingAttribute( node, 'data-bind' ) );
				if( arrayBinding ){
					bindingPath = (bindingPath ? bindingPath + '.' : '') + (fieldBinding || arrayBinding);
				}

				self.visitAttributes( node, bindingPath, inArray, arrayBinding );

				if( arrayBinding ){
					self.visitArrayBinding( node, bindingPath, inArray, arrayBinding, filterBinding );
					inArray = true;
				}

				var array = node.block.nodes || [];
				self.code.push( ' [ ');
				array.forEach( function(subnode){
					self.visit( subnode, bindingPath, inArray );
					if( (subnode !== node.block.nodes[ node.block.nodes.length-1 ]) && (typesToIgnore.indexOf( subnode.type )===-1) )
						self.code.push( ' , ');
				} );
				self.code.push( ' ] ');

				if( arrayBinding )
					self.code.push('; }) ');

				self.code.push( ')' );
			},
			visitText: function( node, bindingPath, inArray ){
				var self = this;
				self.code.push( '\"' + quote(node.val) + '\"' );
			},
			visit: function( node, bindingPath, inArray ){
				var self = this;
				if( !node.type ){
					if( !Array.isArray( node ) ) throw new Error( 'Unknown node', node );
					node.forEach( function(subnode){
						self['visit' + subnode.type]( subnode, bindingPath, inArray );
					} );
				}
				else
					self['visit' + node.type]( node, bindingPath, inArray );
			},
			compile: function () {
				var self = this;

				self.code.push( 'function(ctrl, mdl){ ' );
				self.code.push( 'ctrl.dateFormat = envOptions ? envOptions.dateFormat : \'DD.MM.YYYY\';' );
				if( options.context ){
					self.code.push( 'if ( firstRun ){' );
					self.code.push( 'context[modelName].vcs.push( { model: ctrl[modelName], controller: ctrl } );' );
					//self.code.push( 'context[name] = { model: ctrl[name], controller: ctrl };' );
					self.code.push( 'if (context && context.emit)' );
					self.code.push( 'context.emit( \'init\' + viewName + \'Controller\', ctrl, mdl );' );
					self.code.push( ' firstRun = false; }' );
				}

				self.code.push( 'return ' );

				self.visit( node, '', false );

				self.code.push( '; }\n' );

				return toPush( self.code );
			}
		};

		typesToIgnore.forEach(function( typeToIgnore ){
			compiler[ 'visit' + typeToIgnore ] = function( node, bindingPath, inArray ){
			};
		});

		return compiler;
	};

	module.exports = Compiler;


/***/ },
/* 7 */
/***/ function(module, exports) {

	var arrayTag = '[object Array]',
		boolTag = '[object Boolean]',
		dateTag = '[object Date]',
		errorTag = '[object Error]',
		funcTag = '[object Function]',
		numberTag = '[object Number]',
		objectTag = '[object Object]',
		regexpTag = '[object RegExp]',
		stringTag = '[object String]';

	var arrayProto = Array.prototype,
		objectProto = Object.prototype,
		stringProto = String.prototype;

	var objToString = objectProto.toString;
	var fnToString = Function.prototype.toString;
	var objCtorString = fnToString.call(Object);

	module.exports = {
		getPrototypeOf: Object.getPrototypeOf,
		isHostObject: function(value) {
			var result = false;
			if (value !== null && typeof value.toString != 'function') {
				try {
					result = !!(value + '');
				} catch (e) {}
			}
			return result;
		},
		isPlainObject: function(value) {
			if (!this.isObjectLike(value) || objToString.call(value) != objectTag || this.isHostObject(value)) {
				return false;
			}
			var proto = typeof value.constructor == 'function' ? this.getPrototypeOf(value) : objectProto;

			if (proto === null) {
				return true;
			}
			var Ctor = proto.constructor;
			return (typeof Ctor == 'function' && Ctor instanceof Ctor && fnToString.call(Ctor) == objCtorString);
		},
		isObjectLike: function(value) {
			return !!value && typeof value == 'object';
		},
		isArray: Array.isArray,
		isObject: function(value) {
			var type = typeof value;
			return !!value && (type == 'object' || type == 'function');
		},
		isError: function(value) {
			return this.isObjectLike(value) && typeof value.message == 'string' && objToString.call(value) == errorTag;
		},
		isNumber: function(value) {
			return typeof value == 'number' || (this.isObjectLike(value) && objToString.call(value) == numberTag);
		},
		isDate: function(value) {
			return this.isObjectLike(value) && objToString.call(value) == dateTag;
		},
		isFunction: function(value) {
			return this.isObject(value) && objToString.call(value) == funcTag;
		},
		isBoolean: function(value) {
			return value === true || value === false || (this.isObjectLike(value) && objToString.call(value) == boolTag);
		},
		isString: function(value) {
			return typeof value == 'string' || ( this.isObjectLike(value) && objToString.call(value) == stringTag);
		},
		isRegExp: function(value) {
			return this.isObject(value) && objToString.call(value) == regexpTag;
		}
	};


/***/ },
/* 8 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';

	/*!
	 * Jade
	 * Copyright(c) 2010 TJ Holowaychuk <tj@vision-media.ca>
	 * MIT Licensed
	 */

	/**
	 * Module dependencies.
	 */

	var Parser = __webpack_require__(10)
	  , Lexer = __webpack_require__(11)
	  , Compiler = __webpack_require__(37)
	  , runtime = __webpack_require__(39)
	  , addWith = __webpack_require__(41)
	  , fs = __webpack_require__(36)
	  , utils = __webpack_require__(12);

	/**
	 * Expose self closing tags.
	 */

	// FIXME: either stop exporting selfClosing in v2 or export the new object
	// form
	exports.selfClosing = Object.keys(__webpack_require__(40));

	/**
	 * Default supported doctypes.
	 */

	exports.doctypes = __webpack_require__(38);

	/**
	 * Text filters.
	 */

	exports.filters = __webpack_require__(31);

	/**
	 * Utilities.
	 */

	exports.utils = utils;

	/**
	 * Expose `Compiler`.
	 */

	exports.Compiler = Compiler;

	/**
	 * Expose `Parser`.
	 */

	exports.Parser = Parser;

	/**
	 * Expose `Lexer`.
	 */

	exports.Lexer = Lexer;

	/**
	 * Nodes.
	 */

	exports.nodes = __webpack_require__(14);

	/**
	 * Jade runtime helpers.
	 */

	exports.runtime = runtime;

	/**
	 * Template function cache.
	 */

	exports.cache = {};

	/**
	 * Parse the given `str` of jade and return a function body.
	 *
	 * @param {String} str
	 * @param {Object} options
	 * @return {Object}
	 * @api private
	 */

	function parse(str, options){

	  if (options.lexer) {
	    console.warn('Using `lexer` as a local in render() is deprecated and '
	               + 'will be interpreted as an option in Jade 2.0.0');
	  }

	  // Parse
	  var parser = new (options.parser || Parser)(str, options.filename, options);
	  var tokens;
	  try {
	    // Parse
	    tokens = parser.parse();
	  } catch (err) {
	    parser = parser.context();
	    runtime.rethrow(err, parser.filename, parser.lexer.lineno, parser.input);
	  }

	  // Compile
	  var compiler = new (options.compiler || Compiler)(tokens, options);
	  var js;
	  try {
	    js = compiler.compile();
	  } catch (err) {
	    if (err.line && (err.filename || !options.filename)) {
	      runtime.rethrow(err, err.filename, err.line, parser.input);
	    } else {
	      if (err instanceof Error) {
	        err.message += '\n\nPlease report this entire error and stack trace to https://github.com/jadejs/jade/issues';
	      }
	      throw err;
	    }
	  }

	  // Debug compiler
	  if (options.debug) {
	    console.error('\nCompiled Function:\n\n\u001b[90m%s\u001b[0m', js.replace(/^/gm, '  '));
	  }

	  var globals = [];

	  if (options.globals) {
	    globals = options.globals.slice();
	  }

	  globals.push('jade');
	  globals.push('jade_mixins');
	  globals.push('jade_interp');
	  globals.push('jade_debug');
	  globals.push('buf');

	  var body = ''
	    + 'var buf = [];\n'
	    + 'var jade_mixins = {};\n'
	    + 'var jade_interp;\n'
	    + (options.self
	      ? 'var self = locals || {};\n' + js
	      : addWith('locals || {}', '\n' + js, globals)) + ';'
	    + 'return buf.join("");';
	  return {body: body, dependencies: parser.dependencies};
	}

	/**
	 * Get the template from a string or a file, either compiled on-the-fly or
	 * read from cache (if enabled), and cache the template if needed.
	 *
	 * If `str` is not set, the file specified in `options.filename` will be read.
	 *
	 * If `options.cache` is true, this function reads the file from
	 * `options.filename` so it must be set prior to calling this function.
	 *
	 * @param {Object} options
	 * @param {String=} str
	 * @return {Function}
	 * @api private
	 */
	function handleTemplateCache (options, str) {
	  var key = options.filename;
	  if (options.cache && exports.cache[key]) {
	    return exports.cache[key];
	  } else {
	    if (str === undefined) str = fs.readFileSync(options.filename, 'utf8');
	    var templ = exports.compile(str, options);
	    if (options.cache) exports.cache[key] = templ;
	    return templ;
	  }
	}

	/**
	 * Compile a `Function` representation of the given jade `str`.
	 *
	 * Options:
	 *
	 *   - `compileDebug` when `false` debugging code is stripped from the compiled
	       template, when it is explicitly `true`, the source code is included in
	       the compiled template for better accuracy.
	 *   - `filename` used to improve errors when `compileDebug` is not `false` and to resolve imports/extends
	 *
	 * @param {String} str
	 * @param {Options} options
	 * @return {Function}
	 * @api public
	 */

	exports.compile = function(str, options){
	  var options = options || {}
	    , filename = options.filename
	      ? utils.stringify(options.filename)
	      : 'undefined'
	    , fn;

	  str = String(str);

	  var parsed = parse(str, options);
	  if (options.compileDebug !== false) {
	    fn = [
	        'var jade_debug = [ new jade.DebugItem( 1, ' + filename + ' ) ];'
	      , 'try {'
	      , parsed.body
	      , '} catch (err) {'
	      , '  jade.rethrow(err, jade_debug[0].filename, jade_debug[0].lineno' + (options.compileDebug === true ? ',' + utils.stringify(str) : '') + ');'
	      , '}'
	    ].join('\n');
	  } else {
	    fn = parsed.body;
	  }
	  fn = new Function('locals, jade', fn)
	  var res = function(locals){ return fn(locals, Object.create(runtime)) };
	  if (options.client) {
	    res.toString = function () {
	      var err = new Error('The `client` option is deprecated, use the `jade.compileClient` method instead');
	      err.name = 'Warning';
	      console.error(err.stack || /* istanbul ignore next */ err.message);
	      return exports.compileClient(str, options);
	    };
	  }
	  res.dependencies = parsed.dependencies;
	  return res;
	};

	/**
	 * Compile a JavaScript source representation of the given jade `str`.
	 *
	 * Options:
	 *
	 *   - `compileDebug` When it is `true`, the source code is included in
	 *     the compiled template for better error messages.
	 *   - `filename` used to improve errors when `compileDebug` is not `true` and to resolve imports/extends
	 *   - `name` the name of the resulting function (defaults to "template")
	 *
	 * @param {String} str
	 * @param {Options} options
	 * @return {Object}
	 * @api public
	 */

	exports.compileClientWithDependenciesTracked = function(str, options){
	  var options = options || {};
	  var name = options.name || 'template';
	  var filename = options.filename ? utils.stringify(options.filename) : 'undefined';
	  var fn;

	  str = String(str);
	  options.compileDebug = options.compileDebug ? true : false;
	  var parsed = parse(str, options);
	  if (options.compileDebug) {
	    fn = [
	        'var jade_debug = [ new jade.DebugItem( 1, ' + filename + ' ) ];'
	      , 'try {'
	      , parsed.body
	      , '} catch (err) {'
	      , '  jade.rethrow(err, jade_debug[0].filename, jade_debug[0].lineno, ' + utils.stringify(str) + ');'
	      , '}'
	    ].join('\n');
	  } else {
	    fn = parsed.body;
	  }

	  return {body: 'function ' + name + '(locals) {\n' + fn + '\n}', dependencies: parsed.dependencies};
	};

	/**
	 * Compile a JavaScript source representation of the given jade `str`.
	 *
	 * Options:
	 *
	 *   - `compileDebug` When it is `true`, the source code is included in
	 *     the compiled template for better error messages.
	 *   - `filename` used to improve errors when `compileDebug` is not `true` and to resolve imports/extends
	 *   - `name` the name of the resulting function (defaults to "template")
	 *
	 * @param {String} str
	 * @param {Options} options
	 * @return {String}
	 * @api public
	 */
	exports.compileClient = function (str, options) {
	  return exports.compileClientWithDependenciesTracked(str, options).body;
	};

	/**
	 * Compile a `Function` representation of the given jade file.
	 *
	 * Options:
	 *
	 *   - `compileDebug` when `false` debugging code is stripped from the compiled
	       template, when it is explicitly `true`, the source code is included in
	       the compiled template for better accuracy.
	 *
	 * @param {String} path
	 * @param {Options} options
	 * @return {Function}
	 * @api public
	 */
	exports.compileFile = function (path, options) {
	  options = options || {};
	  options.filename = path;
	  return handleTemplateCache(options);
	};

	/**
	 * Render the given `str` of jade.
	 *
	 * Options:
	 *
	 *   - `cache` enable template caching
	 *   - `filename` filename required for `include` / `extends` and caching
	 *
	 * @param {String} str
	 * @param {Object|Function} options or fn
	 * @param {Function|undefined} fn
	 * @returns {String}
	 * @api public
	 */

	exports.render = function(str, options, fn){
	  // support callback API
	  if ('function' == typeof options) {
	    fn = options, options = undefined;
	  }
	  if (typeof fn === 'function') {
	    var res
	    try {
	      res = exports.render(str, options);
	    } catch (ex) {
	      return fn(ex);
	    }
	    return fn(null, res);
	  }

	  options = options || {};

	  // cache requires .filename
	  if (options.cache && !options.filename) {
	    throw new Error('the "filename" option is required for caching');
	  }

	  return handleTemplateCache(options, str)(options);
	};

	/**
	 * Render a Jade file at the given `path`.
	 *
	 * @param {String} path
	 * @param {Object|Function} options or callback
	 * @param {Function|undefined} fn
	 * @returns {String}
	 * @api public
	 */

	exports.renderFile = function(path, options, fn){
	  // support callback API
	  if ('function' == typeof options) {
	    fn = options, options = undefined;
	  }
	  if (typeof fn === 'function') {
	    var res
	    try {
	      res = exports.renderFile(path, options);
	    } catch (ex) {
	      return fn(ex);
	    }
	    return fn(null, res);
	  }

	  options = options || {};

	  options.filename = path;
	  return handleTemplateCache(options)(options);
	};


	/**
	 * Compile a Jade file at the given `path` for use on the client.
	 *
	 * @param {String} path
	 * @param {Object} options
	 * @returns {String}
	 * @api public
	 */

	exports.compileFileClient = function(path, options){
	  var key = path + ':client';
	  options = options || {};

	  options.filename = path;

	  if (options.cache && exports.cache[key]) {
	    return exports.cache[key];
	  }

	  var str = fs.readFileSync(options.filename, 'utf8');
	  var out = exports.compileClient(str, options);
	  if (options.cache) exports.cache[key] = out;
	  return out;
	};

	/**
	 * Express support.
	 */

	exports.__express = function(path, options, fn) {
	  if(options.compileDebug == undefined && process.env.NODE_ENV === 'production') {
	    options.compileDebug = false;
	  }
	  exports.renderFile(path, options, fn);
	}

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(9)))

/***/ },
/* 9 */
/***/ function(module, exports) {

	// shim for using process in browser

	var process = module.exports = {};
	var queue = [];
	var draining = false;
	var currentQueue;
	var queueIndex = -1;

	function cleanUpNextTick() {
	    draining = false;
	    if (currentQueue.length) {
	        queue = currentQueue.concat(queue);
	    } else {
	        queueIndex = -1;
	    }
	    if (queue.length) {
	        drainQueue();
	    }
	}

	function drainQueue() {
	    if (draining) {
	        return;
	    }
	    var timeout = setTimeout(cleanUpNextTick);
	    draining = true;

	    var len = queue.length;
	    while(len) {
	        currentQueue = queue;
	        queue = [];
	        while (++queueIndex < len) {
	            if (currentQueue) {
	                currentQueue[queueIndex].run();
	            }
	        }
	        queueIndex = -1;
	        len = queue.length;
	    }
	    currentQueue = null;
	    draining = false;
	    clearTimeout(timeout);
	}

	process.nextTick = function (fun) {
	    var args = new Array(arguments.length - 1);
	    if (arguments.length > 1) {
	        for (var i = 1; i < arguments.length; i++) {
	            args[i - 1] = arguments[i];
	        }
	    }
	    queue.push(new Item(fun, args));
	    if (queue.length === 1 && !draining) {
	        setTimeout(drainQueue, 0);
	    }
	};

	// v8 likes predictible objects
	function Item(fun, array) {
	    this.fun = fun;
	    this.array = array;
	}
	Item.prototype.run = function () {
	    this.fun.apply(null, this.array);
	};
	process.title = 'browser';
	process.browser = true;
	process.env = {};
	process.argv = [];
	process.version = ''; // empty string to avoid regexp issues
	process.versions = {};

	function noop() {}

	process.on = noop;
	process.addListener = noop;
	process.once = noop;
	process.off = noop;
	process.removeListener = noop;
	process.removeAllListeners = noop;
	process.emit = noop;

	process.binding = function (name) {
	    throw new Error('process.binding is not supported');
	};

	process.cwd = function () { return '/' };
	process.chdir = function (dir) {
	    throw new Error('process.chdir is not supported');
	};
	process.umask = function() { return 0; };


/***/ },
/* 10 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var Lexer = __webpack_require__(11);
	var nodes = __webpack_require__(14);
	var utils = __webpack_require__(12);
	var filters = __webpack_require__(31);
	var path = __webpack_require__(32);
	var constantinople = __webpack_require__(33);
	var parseJSExpression = __webpack_require__(13).parseMax;
	var extname = path.extname;

	/**
	 * Initialize `Parser` with the given input `str` and `filename`.
	 *
	 * @param {String} str
	 * @param {String} filename
	 * @param {Object} options
	 * @api public
	 */

	var Parser = exports = module.exports = function Parser(str, filename, options){
	  //Strip any UTF-8 BOM off of the start of `str`, if it exists.
	  this.input = str.replace(/^\uFEFF/, '');
	  this.lexer = new Lexer(this.input, filename);
	  this.filename = filename;
	  this.blocks = {};
	  this.mixins = {};
	  this.options = options;
	  this.contexts = [this];
	  this.inMixin = 0;
	  this.dependencies = [];
	  this.inBlock = 0;
	};

	/**
	 * Parser prototype.
	 */

	Parser.prototype = {

	  /**
	   * Save original constructor
	   */

	  constructor: Parser,

	  /**
	   * Push `parser` onto the context stack,
	   * or pop and return a `Parser`.
	   */

	  context: function(parser){
	    if (parser) {
	      this.contexts.push(parser);
	    } else {
	      return this.contexts.pop();
	    }
	  },

	  /**
	   * Return the next token object.
	   *
	   * @return {Object}
	   * @api private
	   */

	  advance: function(){
	    return this.lexer.advance();
	  },

	  /**
	   * Single token lookahead.
	   *
	   * @return {Object}
	   * @api private
	   */

	  peek: function() {
	    return this.lookahead(1);
	  },

	  /**
	   * Return lexer lineno.
	   *
	   * @return {Number}
	   * @api private
	   */

	  line: function() {
	    return this.lexer.lineno;
	  },

	  /**
	   * `n` token lookahead.
	   *
	   * @param {Number} n
	   * @return {Object}
	   * @api private
	   */

	  lookahead: function(n){
	    return this.lexer.lookahead(n);
	  },

	  /**
	   * Parse input returning a string of js for evaluation.
	   *
	   * @return {String}
	   * @api public
	   */

	  parse: function(){
	    var block = new nodes.Block, parser;
	    block.line = 0;
	    block.filename = this.filename;

	    while ('eos' != this.peek().type) {
	      if ('newline' == this.peek().type) {
	        this.advance();
	      } else {
	        var next = this.peek();
	        var expr = this.parseExpr();
	        expr.filename = expr.filename || this.filename;
	        expr.line = next.line;
	        block.push(expr);
	      }
	    }

	    if (parser = this.extending) {
	      this.context(parser);
	      var ast = parser.parse();
	      this.context();

	      // hoist mixins
	      for (var name in this.mixins)
	        ast.unshift(this.mixins[name]);
	      return ast;
	    }

	    if (!this.extending && !this.included && Object.keys(this.blocks).length){
	      var blocks = [];
	      utils.walkAST(block, function (node) {
	        if (node.type === 'Block' && node.name) {
	          blocks.push(node.name);
	        }
	      });
	      Object.keys(this.blocks).forEach(function (name) {
	        if (blocks.indexOf(name) === -1 && !this.blocks[name].isSubBlock) {
	          console.warn('Warning: Unexpected block "'
	                       + name
	                       + '" '
	                       + ' on line '
	                       + this.blocks[name].line
	                       + ' of '
	                       + (this.blocks[name].filename)
	                       + '. This block is never used. This warning will be an error in v2.0.0');
	        }
	      }.bind(this));
	    }

	    return block;
	  },

	  /**
	   * Expect the given type, or throw an exception.
	   *
	   * @param {String} type
	   * @api private
	   */

	  expect: function(type){
	    if (this.peek().type === type) {
	      return this.advance();
	    } else {
	      throw new Error('expected "' + type + '", but got "' + this.peek().type + '"');
	    }
	  },

	  /**
	   * Accept the given `type`.
	   *
	   * @param {String} type
	   * @api private
	   */

	  accept: function(type){
	    if (this.peek().type === type) {
	      return this.advance();
	    }
	  },

	  /**
	   *   tag
	   * | doctype
	   * | mixin
	   * | include
	   * | filter
	   * | comment
	   * | text
	   * | each
	   * | code
	   * | yield
	   * | id
	   * | class
	   * | interpolation
	   */

	  parseExpr: function(){
	    switch (this.peek().type) {
	      case 'tag':
	        return this.parseTag();
	      case 'mixin':
	        return this.parseMixin();
	      case 'block':
	        return this.parseBlock();
	      case 'mixin-block':
	        return this.parseMixinBlock();
	      case 'case':
	        return this.parseCase();
	      case 'extends':
	        return this.parseExtends();
	      case 'include':
	        return this.parseInclude();
	      case 'doctype':
	        return this.parseDoctype();
	      case 'filter':
	        return this.parseFilter();
	      case 'comment':
	        return this.parseComment();
	      case 'text':
	        return this.parseText();
	      case 'each':
	        return this.parseEach();
	      case 'code':
	        return this.parseCode();
	      case 'blockCode':
	        return this.parseBlockCode();
	      case 'call':
	        return this.parseCall();
	      case 'interpolation':
	        return this.parseInterpolation();
	      case 'yield':
	        this.advance();
	        var block = new nodes.Block;
	        block.yield = true;
	        return block;
	      case 'id':
	      case 'class':
	        var tok = this.advance();
	        this.lexer.defer(this.lexer.tok('tag', 'div'));
	        this.lexer.defer(tok);
	        return this.parseExpr();
	      default:
	        throw new Error('unexpected token "' + this.peek().type + '"');
	    }
	  },

	  /**
	   * Text
	   */

	  parseText: function(){
	    var tok = this.expect('text');
	    var tokens = this.parseInlineTagsInText(tok.val);
	    if (tokens.length === 1) return tokens[0];
	    var node = new nodes.Block;
	    for (var i = 0; i < tokens.length; i++) {
	      node.push(tokens[i]);
	    };
	    return node;
	  },

	  /**
	   *   ':' expr
	   * | block
	   */

	  parseBlockExpansion: function(){
	    if (':' == this.peek().type) {
	      this.advance();
	      return new nodes.Block(this.parseExpr());
	    } else {
	      return this.block();
	    }
	  },

	  /**
	   * case
	   */

	  parseCase: function(){
	    var val = this.expect('case').val;
	    var node = new nodes.Case(val);
	    node.line = this.line();

	    var block = new nodes.Block;
	    block.line = this.line();
	    block.filename = this.filename;
	    this.expect('indent');
	    while ('outdent' != this.peek().type) {
	      switch (this.peek().type) {
	        case 'comment':
	        case 'newline':
	          this.advance();
	          break;
	        case 'when':
	          block.push(this.parseWhen());
	          break;
	        case 'default':
	          block.push(this.parseDefault());
	          break;
	        default:
	          throw new Error('Unexpected token "' + this.peek().type
	                          + '", expected "when", "default" or "newline"');
	      }
	    }
	    this.expect('outdent');

	    node.block = block;

	    return node;
	  },

	  /**
	   * when
	   */

	  parseWhen: function(){
	    var val = this.expect('when').val;
	    if (this.peek().type !== 'newline')
	      return new nodes.Case.When(val, this.parseBlockExpansion());
	    else
	      return new nodes.Case.When(val);
	  },

	  /**
	   * default
	   */

	  parseDefault: function(){
	    this.expect('default');
	    return new nodes.Case.When('default', this.parseBlockExpansion());
	  },

	  /**
	   * code
	   */

	  parseCode: function(afterIf){
	    var tok = this.expect('code');
	    var node = new nodes.Code(tok.val, tok.buffer, tok.escape);
	    var block;
	    node.line = this.line();

	    // throw an error if an else does not have an if
	    if (tok.isElse && !tok.hasIf) {
	      throw new Error('Unexpected else without if');
	    }

	    // handle block
	    block = 'indent' == this.peek().type;
	    if (block) {
	      node.block = this.block();
	    }

	    // handle missing block
	    if (tok.requiresBlock && !block) {
	      node.block = new nodes.Block();
	    }

	    // mark presense of if for future elses
	    if (tok.isIf && this.peek().isElse) {
	      this.peek().hasIf = true;
	    } else if (tok.isIf && this.peek().type === 'newline' && this.lookahead(2).isElse) {
	      this.lookahead(2).hasIf = true;
	    }

	    return node;
	  },

	  /**
	   * block code
	   */

	  parseBlockCode: function(){
	    var tok = this.expect('blockCode');
	    var node;
	    var body = this.peek();
	    var text;
	    if (body.type === 'pipeless-text') {
	      this.advance();
	      text = body.val.join('\n');
	    } else {
	      text = '';
	    }
	      node = new nodes.Code(text, false, false);
	      return node;
	  },

	  /**
	   * comment
	   */

	  parseComment: function(){
	    var tok = this.expect('comment');
	    var node;

	    var block;
	    if (block = this.parseTextBlock()) {
	      node = new nodes.BlockComment(tok.val, block, tok.buffer);
	    } else {
	      node = new nodes.Comment(tok.val, tok.buffer);
	    }

	    node.line = this.line();
	    return node;
	  },

	  /**
	   * doctype
	   */

	  parseDoctype: function(){
	    var tok = this.expect('doctype');
	    var node = new nodes.Doctype(tok.val);
	    node.line = this.line();
	    return node;
	  },

	  /**
	   * filter attrs? text-block
	   */

	  parseFilter: function(){
	    var tok = this.expect('filter');
	    var attrs = this.accept('attrs');
	    var block;

	    block = this.parseTextBlock() || new nodes.Block();

	    var options = {};
	    if (attrs) {
	      attrs.attrs.forEach(function (attribute) {
	        options[attribute.name] = constantinople.toConstant(attribute.val);
	      });
	    }

	    var node = new nodes.Filter(tok.val, block, options);
	    node.line = this.line();
	    return node;
	  },

	  /**
	   * each block
	   */

	  parseEach: function(){
	    var tok = this.expect('each');
	    var node = new nodes.Each(tok.code, tok.val, tok.key);
	    node.line = this.line();
	    node.block = this.block();
	    if (this.peek().type == 'code' && this.peek().val == 'else') {
	      this.advance();
	      node.alternative = this.block();
	    }
	    return node;
	  },

	  /**
	   * Resolves a path relative to the template for use in
	   * includes and extends
	   *
	   * @param {String}  path
	   * @param {String}  purpose  Used in error messages.
	   * @return {String}
	   * @api private
	   */

	  resolvePath: function (path, purpose) {
	    var p = __webpack_require__(32);
	    var dirname = p.dirname;
	    var basename = p.basename;
	    var join = p.join;

	    if (path[0] !== '/' && !this.filename)
	      throw new Error('the "filename" option is required to use "' + purpose + '" with "relative" paths');

	    if (path[0] === '/' && !this.options.basedir)
	      throw new Error('the "basedir" option is required to use "' + purpose + '" with "absolute" paths');

	    path = join(path[0] === '/' ? this.options.basedir : dirname(this.filename), path);

	    if (basename(path).indexOf('.') === -1) path += '.jade';

	    return path;
	  },

	  /**
	   * 'extends' name
	   */

	  parseExtends: function(){
	    var fs = __webpack_require__(36);

	    var path = this.resolvePath(this.expect('extends').val.trim(), 'extends');
	    if ('.jade' != path.substr(-5)) path += '.jade';

	    this.dependencies.push(path);
	    var str = fs.readFileSync(path, 'utf8');
	    var parser = new this.constructor(str, path, this.options);
	    parser.dependencies = this.dependencies;

	    parser.blocks = this.blocks;
	    parser.included = this.included;
	    parser.contexts = this.contexts;
	    this.extending = parser;

	    // TODO: null node
	    return new nodes.Literal('');
	  },

	  /**
	   * 'block' name block
	   */

	  parseBlock: function(){
	    var block = this.expect('block');
	    var mode = block.mode;
	    var name = block.val.trim();

	    var line = block.line;

	    this.inBlock++;
	    block = 'indent' == this.peek().type
	      ? this.block()
	      : new nodes.Block(new nodes.Literal(''));
	    this.inBlock--;
	    block.name = name;
	    block.line = line;

	    var prev = this.blocks[name] || {prepended: [], appended: []}
	    if (prev.mode === 'replace') return this.blocks[name] = prev;

	    var allNodes = prev.prepended.concat(block.nodes).concat(prev.appended);

	    switch (mode) {
	      case 'append':
	        prev.appended = prev.parser === this ?
	                        prev.appended.concat(block.nodes) :
	                        block.nodes.concat(prev.appended);
	        break;
	      case 'prepend':
	        prev.prepended = prev.parser === this ?
	                         block.nodes.concat(prev.prepended) :
	                         prev.prepended.concat(block.nodes);
	        break;
	    }
	    block.nodes = allNodes;
	    block.appended = prev.appended;
	    block.prepended = prev.prepended;
	    block.mode = mode;
	    block.parser = this;

	    block.isSubBlock = this.inBlock > 0;

	    return this.blocks[name] = block;
	  },

	  parseMixinBlock: function () {
	    var block = this.expect('mixin-block');
	    if (!this.inMixin) {
	      throw new Error('Anonymous blocks are not allowed unless they are part of a mixin.');
	    }
	    return new nodes.MixinBlock();
	  },

	  /**
	   * include block?
	   */

	  parseInclude: function(){
	    var fs = __webpack_require__(36);
	    var tok = this.expect('include');

	    var path = this.resolvePath(tok.val.trim(), 'include');
	    this.dependencies.push(path);
	    // has-filter
	    if (tok.filter) {
	      var str = fs.readFileSync(path, 'utf8').replace(/\r/g, '');
	      var options = {filename: path};
	      if (tok.attrs) {
	        tok.attrs.attrs.forEach(function (attribute) {
	          options[attribute.name] = constantinople.toConstant(attribute.val);
	        });
	      }
	      str = filters(tok.filter, str, options);
	      return new nodes.Literal(str);
	    }

	    // non-jade
	    if ('.jade' != path.substr(-5)) {
	      var str = fs.readFileSync(path, 'utf8').replace(/\r/g, '');
	      return new nodes.Literal(str);
	    }

	    var str = fs.readFileSync(path, 'utf8');
	    var parser = new this.constructor(str, path, this.options);
	    parser.dependencies = this.dependencies;

	    parser.blocks = utils.merge({}, this.blocks);
	    parser.included = true;

	    parser.mixins = this.mixins;

	    this.context(parser);
	    var ast = parser.parse();
	    this.context();
	    ast.filename = path;

	    if ('indent' == this.peek().type) {
	      ast.includeBlock().push(this.block());
	    }

	    return ast;
	  },

	  /**
	   * call ident block
	   */

	  parseCall: function(){
	    var tok = this.expect('call');
	    var name = tok.val;
	    var args = tok.args;
	    var mixin = new nodes.Mixin(name, args, new nodes.Block, true);

	    this.tag(mixin);
	    if (mixin.code) {
	      mixin.block.push(mixin.code);
	      mixin.code = null;
	    }
	    if (mixin.block.isEmpty()) mixin.block = null;
	    return mixin;
	  },

	  /**
	   * mixin block
	   */

	  parseMixin: function(){
	    var tok = this.expect('mixin');
	    var name = tok.val;
	    var args = tok.args;
	    var mixin;

	    // definition
	    if ('indent' == this.peek().type) {
	      this.inMixin++;
	      mixin = new nodes.Mixin(name, args, this.block(), false);
	      this.mixins[name] = mixin;
	      this.inMixin--;
	      return mixin;
	    // call
	    } else {
	      return new nodes.Mixin(name, args, null, true);
	    }
	  },

	  parseInlineTagsInText: function (str) {
	    var line = this.line();

	    var match = /(\\)?#\[((?:.|\n)*)$/.exec(str);
	    if (match) {
	      if (match[1]) { // escape
	        var text = new nodes.Text(str.substr(0, match.index) + '#[');
	        text.line = line;
	        var rest = this.parseInlineTagsInText(match[2]);
	        if (rest[0].type === 'Text') {
	          text.val += rest[0].val;
	          rest.shift();
	        }
	        return [text].concat(rest);
	      } else {
	        var text = new nodes.Text(str.substr(0, match.index));
	        text.line = line;
	        var buffer = [text];
	        var rest = match[2];
	        var range = parseJSExpression(rest);
	        var inner = new Parser(range.src, this.filename, this.options);
	        buffer.push(inner.parse());
	        return buffer.concat(this.parseInlineTagsInText(rest.substr(range.end + 1)));
	      }
	    } else {
	      var text = new nodes.Text(str);
	      text.line = line;
	      return [text];
	    }
	  },

	  /**
	   * indent (text | newline)* outdent
	   */

	  parseTextBlock: function(){
	    var block = new nodes.Block;
	    block.line = this.line();
	    var body = this.peek();
	    if (body.type !== 'pipeless-text') return;
	    this.advance();
	    block.nodes = body.val.reduce(function (accumulator, text) {
	      return accumulator.concat(this.parseInlineTagsInText(text));
	    }.bind(this), []);
	    return block;
	  },

	  /**
	   * indent expr* outdent
	   */

	  block: function(){
	    var block = new nodes.Block;
	    block.line = this.line();
	    block.filename = this.filename;
	    this.expect('indent');
	    while ('outdent' != this.peek().type) {
	      if ('newline' == this.peek().type) {
	        this.advance();
	      } else {
	        var expr = this.parseExpr();
	        expr.filename = this.filename;
	        block.push(expr);
	      }
	    }
	    this.expect('outdent');
	    return block;
	  },

	  /**
	   * interpolation (attrs | class | id)* (text | code | ':')? newline* block?
	   */

	  parseInterpolation: function(){
	    var tok = this.advance();
	    var tag = new nodes.Tag(tok.val);
	    tag.buffer = true;
	    return this.tag(tag);
	  },

	  /**
	   * tag (attrs | class | id)* (text | code | ':')? newline* block?
	   */

	  parseTag: function(){
	    var tok = this.advance();
	    var tag = new nodes.Tag(tok.val);

	    tag.selfClosing = tok.selfClosing;

	    return this.tag(tag);
	  },

	  /**
	   * Parse tag.
	   */

	  tag: function(tag){
	    tag.line = this.line();

	    var seenAttrs = false;
	    // (attrs | class | id)*
	    out:
	      while (true) {
	        switch (this.peek().type) {
	          case 'id':
	          case 'class':
	            var tok = this.advance();
	            tag.setAttribute(tok.type, "'" + tok.val + "'");
	            continue;
	          case 'attrs':
	            if (seenAttrs) {
	              console.warn(this.filename + ', line ' + this.peek().line + ':\nYou should not have jade tags with multiple attributes.');
	            }
	            seenAttrs = true;
	            var tok = this.advance();
	            var attrs = tok.attrs;

	            if (tok.selfClosing) tag.selfClosing = true;

	            for (var i = 0; i < attrs.length; i++) {
	              tag.setAttribute(attrs[i].name, attrs[i].val, attrs[i].escaped);
	            }
	            continue;
	          case '&attributes':
	            var tok = this.advance();
	            tag.addAttributes(tok.val);
	            break;
	          default:
	            break out;
	        }
	      }

	    // check immediate '.'
	    if ('dot' == this.peek().type) {
	      tag.textOnly = true;
	      this.advance();
	    }

	    // (text | code | ':')?
	    switch (this.peek().type) {
	      case 'text':
	        tag.block.push(this.parseText());
	        break;
	      case 'code':
	        tag.code = this.parseCode();
	        break;
	      case ':':
	        this.advance();
	        tag.block = new nodes.Block;
	        tag.block.push(this.parseExpr());
	        break;
	      case 'newline':
	      case 'indent':
	      case 'outdent':
	      case 'eos':
	      case 'pipeless-text':
	        break;
	      default:
	        throw new Error('Unexpected token `' + this.peek().type + '` expected `text`, `code`, `:`, `newline` or `eos`')
	    }

	    // newline*
	    while ('newline' == this.peek().type) this.advance();

	    // block?
	    if (tag.textOnly) {
	      tag.block = this.parseTextBlock() || new nodes.Block();
	    } else if ('indent' == this.peek().type) {
	      var block = this.block();
	      for (var i = 0, len = block.nodes.length; i < len; ++i) {
	        tag.block.push(block.nodes[i]);
	      }
	    }

	    return tag;
	  }
	};


/***/ },
/* 11 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var utils = __webpack_require__(12);
	var characterParser = __webpack_require__(13);


	/**
	 * Initialize `Lexer` with the given `str`.
	 *
	 * @param {String} str
	 * @param {String} filename
	 * @api private
	 */

	var Lexer = module.exports = function Lexer(str, filename) {
	  this.input = str.replace(/\r\n|\r/g, '\n');
	  this.filename = filename;
	  this.deferredTokens = [];
	  this.lastIndents = 0;
	  this.lineno = 1;
	  this.stash = [];
	  this.indentStack = [];
	  this.indentRe = null;
	  this.pipeless = false;
	};


	function assertExpression(exp) {
	  //this verifies that a JavaScript expression is valid
	  Function('', 'return (' + exp + ')');
	}
	function assertNestingCorrect(exp) {
	  //this verifies that code is properly nested, but allows
	  //invalid JavaScript such as the contents of `attributes`
	  var res = characterParser(exp)
	  if (res.isNesting()) {
	    throw new Error('Nesting must match on expression `' + exp + '`')
	  }
	}

	/**
	 * Lexer prototype.
	 */

	Lexer.prototype = {

	  /**
	   * Construct a token with the given `type` and `val`.
	   *
	   * @param {String} type
	   * @param {String} val
	   * @return {Object}
	   * @api private
	   */

	  tok: function(type, val){
	    return {
	        type: type
	      , line: this.lineno
	      , val: val
	    }
	  },

	  /**
	   * Consume the given `len` of input.
	   *
	   * @param {Number} len
	   * @api private
	   */

	  consume: function(len){
	    this.input = this.input.substr(len);
	  },

	  /**
	   * Scan for `type` with the given `regexp`.
	   *
	   * @param {String} type
	   * @param {RegExp} regexp
	   * @return {Object}
	   * @api private
	   */

	  scan: function(regexp, type){
	    var captures;
	    if (captures = regexp.exec(this.input)) {
	      this.consume(captures[0].length);
	      return this.tok(type, captures[1]);
	    }
	  },

	  /**
	   * Defer the given `tok`.
	   *
	   * @param {Object} tok
	   * @api private
	   */

	  defer: function(tok){
	    this.deferredTokens.push(tok);
	  },

	  /**
	   * Lookahead `n` tokens.
	   *
	   * @param {Number} n
	   * @return {Object}
	   * @api private
	   */

	  lookahead: function(n){
	    var fetch = n - this.stash.length;
	    while (fetch-- > 0) this.stash.push(this.next());
	    return this.stash[--n];
	  },

	  /**
	   * Return the indexOf `(` or `{` or `[` / `)` or `}` or `]` delimiters.
	   *
	   * @return {Number}
	   * @api private
	   */

	  bracketExpression: function(skip){
	    skip = skip || 0;
	    var start = this.input[skip];
	    if (start != '(' && start != '{' && start != '[') throw new Error('unrecognized start character');
	    var end = ({'(': ')', '{': '}', '[': ']'})[start];
	    var range = characterParser.parseMax(this.input, {start: skip + 1});
	    if (this.input[range.end] !== end) throw new Error('start character ' + start + ' does not match end character ' + this.input[range.end]);
	    return range;
	  },

	  /**
	   * Stashed token.
	   */

	  stashed: function() {
	    return this.stash.length
	      && this.stash.shift();
	  },

	  /**
	   * Deferred token.
	   */

	  deferred: function() {
	    return this.deferredTokens.length
	      && this.deferredTokens.shift();
	  },

	  /**
	   * end-of-source.
	   */

	  eos: function() {
	    if (this.input.length) return;
	    if (this.indentStack.length) {
	      this.indentStack.shift();
	      return this.tok('outdent');
	    } else {
	      return this.tok('eos');
	    }
	  },

	  /**
	   * Blank line.
	   */

	  blank: function() {
	    var captures;
	    if (captures = /^\n *\n/.exec(this.input)) {
	      this.consume(captures[0].length - 1);
	      ++this.lineno;
	      if (this.pipeless) return this.tok('text', '');
	      return this.next();
	    }
	  },

	  /**
	   * Comment.
	   */

	  comment: function() {
	    var captures;
	    if (captures = /^\/\/(-)?([^\n]*)/.exec(this.input)) {
	      this.consume(captures[0].length);
	      var tok = this.tok('comment', captures[2]);
	      tok.buffer = '-' != captures[1];
	      this.pipeless = true;
	      return tok;
	    }
	  },

	  /**
	   * Interpolated tag.
	   */

	  interpolation: function() {
	    if (/^#\{/.test(this.input)) {
	      var match = this.bracketExpression(1);

	      this.consume(match.end + 1);
	      return this.tok('interpolation', match.src);
	    }
	  },

	  /**
	   * Tag.
	   */

	  tag: function() {
	    var captures;
	    if (captures = /^(\w[-:\w]*)(\/?)/.exec(this.input)) {
	      this.consume(captures[0].length);
	      var tok, name = captures[1];
	      if (':' == name[name.length - 1]) {
	        name = name.slice(0, -1);
	        tok = this.tok('tag', name);
	        this.defer(this.tok(':'));
	        if (this.input[0] !== ' ') {
	          console.warn('Warning: space required after `:` on line ' + this.lineno +
	              ' of jade file "' + this.filename + '"');
	        }
	        while (' ' == this.input[0]) this.input = this.input.substr(1);
	      } else {
	        tok = this.tok('tag', name);
	      }
	      tok.selfClosing = !!captures[2];
	      return tok;
	    }
	  },

	  /**
	   * Filter.
	   */

	  filter: function() {
	    var tok = this.scan(/^:([\w\-]+)/, 'filter');
	    if (tok) {
	      this.pipeless = true;
	      return tok;
	    }
	  },

	  /**
	   * Doctype.
	   */

	  doctype: function() {
	    if (this.scan(/^!!! *([^\n]+)?/, 'doctype')) {
	      throw new Error('`!!!` is deprecated, you must now use `doctype`');
	    }
	    var node = this.scan(/^(?:doctype) *([^\n]+)?/, 'doctype');
	    if (node && node.val && node.val.trim() === '5') {
	      throw new Error('`doctype 5` is deprecated, you must now use `doctype html`');
	    }
	    return node;
	  },

	  /**
	   * Id.
	   */

	  id: function() {
	    return this.scan(/^#([\w-]+)/, 'id');
	  },

	  /**
	   * Class.
	   */

	  className: function() {
	    return this.scan(/^\.([\w-]+)/, 'class');
	  },

	  /**
	   * Text.
	   */

	  text: function() {
	    return this.scan(/^(?:\| ?| )([^\n]+)/, 'text') ||
	      this.scan(/^\|?( )/, 'text') ||
	      this.scan(/^(<[^\n]*)/, 'text');
	  },

	  textFail: function () {
	    var tok;
	    if (tok = this.scan(/^([^\.\n][^\n]+)/, 'text')) {
	      console.warn('Warning: missing space before text for line ' + this.lineno +
	          ' of jade file "' + this.filename + '"');
	      return tok;
	    }
	  },

	  /**
	   * Dot.
	   */

	  dot: function() {
	    var match;
	    if (match = this.scan(/^\./, 'dot')) {
	      this.pipeless = true;
	      return match;
	    }
	  },

	  /**
	   * Extends.
	   */

	  "extends": function() {
	    return this.scan(/^extends? +([^\n]+)/, 'extends');
	  },

	  /**
	   * Block prepend.
	   */

	  prepend: function() {
	    var captures;
	    if (captures = /^prepend +([^\n]+)/.exec(this.input)) {
	      this.consume(captures[0].length);
	      var mode = 'prepend'
	        , name = captures[1]
	        , tok = this.tok('block', name);
	      tok.mode = mode;
	      return tok;
	    }
	  },

	  /**
	   * Block append.
	   */

	  append: function() {
	    var captures;
	    if (captures = /^append +([^\n]+)/.exec(this.input)) {
	      this.consume(captures[0].length);
	      var mode = 'append'
	        , name = captures[1]
	        , tok = this.tok('block', name);
	      tok.mode = mode;
	      return tok;
	    }
	  },

	  /**
	   * Block.
	   */

	  block: function() {
	    var captures;
	    if (captures = /^block\b *(?:(prepend|append) +)?([^\n]+)/.exec(this.input)) {
	      this.consume(captures[0].length);
	      var mode = captures[1] || 'replace'
	        , name = captures[2]
	        , tok = this.tok('block', name);

	      tok.mode = mode;
	      return tok;
	    }
	  },

	  /**
	   * Mixin Block.
	   */

	  mixinBlock: function() {
	    var captures;
	    if (captures = /^block[ \t]*(\n|$)/.exec(this.input)) {
	      this.consume(captures[0].length - captures[1].length);
	      return this.tok('mixin-block');
	    }
	  },

	  /**
	   * Yield.
	   */

	  'yield': function() {
	    return this.scan(/^yield */, 'yield');
	  },

	  /**
	   * Include.
	   */

	  include: function() {
	    return this.scan(/^include +([^\n]+)/, 'include');
	  },

	  /**
	   * Include with filter
	   */

	  includeFiltered: function() {
	    var captures;
	    if (captures = /^include:([\w\-]+)([\( ])/.exec(this.input)) {
	      this.consume(captures[0].length - 1);
	      var filter = captures[1];
	      var attrs = captures[2] === '(' ? this.attrs() : null;
	      if (!(captures[2] === ' ' || this.input[0] === ' ')) {
	        throw new Error('expected space after include:filter but got ' + utils.stringify(this.input[0]));
	      }
	      captures = /^ *([^\n]+)/.exec(this.input);
	      if (!captures || captures[1].trim() === '') {
	        throw new Error('missing path for include:filter');
	      }
	      this.consume(captures[0].length);
	      var path = captures[1];
	      var tok = this.tok('include', path);
	      tok.filter = filter;
	      tok.attrs = attrs;
	      return tok;
	    }
	  },

	  /**
	   * Case.
	   */

	  "case": function() {
	    return this.scan(/^case +([^\n]+)/, 'case');
	  },

	  /**
	   * When.
	   */

	  when: function() {
	    return this.scan(/^when +([^:\n]+)/, 'when');
	  },

	  /**
	   * Default.
	   */

	  "default": function() {
	    return this.scan(/^default */, 'default');
	  },

	  /**
	   * Call mixin.
	   */

	  call: function(){

	    var tok, captures;
	    if (captures = /^\+(\s*)(([-\w]+)|(#\{))/.exec(this.input)) {
	      // try to consume simple or interpolated call
	      if (captures[3]) {
	        // simple call
	        this.consume(captures[0].length);
	        tok = this.tok('call', captures[3]);
	      } else {
	        // interpolated call
	        var match = this.bracketExpression(2 + captures[1].length);
	        this.consume(match.end + 1);
	        assertExpression(match.src);
	        tok = this.tok('call', '#{'+match.src+'}');
	      }

	      // Check for args (not attributes)
	      if (captures = /^ *\(/.exec(this.input)) {
	        var range = this.bracketExpression(captures[0].length - 1);
	        if (!/^\s*[-\w]+ *=/.test(range.src)) { // not attributes
	          this.consume(range.end + 1);
	          tok.args = range.src;
	        }
	        if (tok.args) {
	          assertExpression('[' + tok.args + ']');
	        }
	      }

	      return tok;
	    }
	  },

	  /**
	   * Mixin.
	   */

	  mixin: function(){
	    var captures;
	    if (captures = /^mixin +([-\w]+)(?: *\((.*)\))? */.exec(this.input)) {
	      this.consume(captures[0].length);
	      var tok = this.tok('mixin', captures[1]);
	      tok.args = captures[2];
	      return tok;
	    }
	  },

	  /**
	   * Conditional.
	   */

	  conditional: function() {
	    var captures;
	    if (captures = /^(if|unless|else if|else)\b([^\n]*)/.exec(this.input)) {
	      this.consume(captures[0].length);
	      var type = captures[1]
	      var js = captures[2];
	      var isIf = false;
	      var isElse = false;

	      switch (type) {
	        case 'if':
	          assertExpression(js)
	          js = 'if (' + js + ')';
	          isIf = true;
	          break;
	        case 'unless':
	          assertExpression(js)
	          js = 'if (!(' + js + '))';
	          isIf = true;
	          break;
	        case 'else if':
	          assertExpression(js)
	          js = 'else if (' + js + ')';
	          isIf = true;
	          isElse = true;
	          break;
	        case 'else':
	          if (js && js.trim()) {
	            throw new Error('`else` cannot have a condition, perhaps you meant `else if`');
	          }
	          js = 'else';
	          isElse = true;
	          break;
	      }
	      var tok = this.tok('code', js);
	      tok.isElse = isElse;
	      tok.isIf = isIf;
	      tok.requiresBlock = true;
	      return tok;
	    }
	  },

	  /**
	   * While.
	   */

	  "while": function() {
	    var captures;
	    if (captures = /^while +([^\n]+)/.exec(this.input)) {
	      this.consume(captures[0].length);
	      assertExpression(captures[1])
	      var tok = this.tok('code', 'while (' + captures[1] + ')');
	      tok.requiresBlock = true;
	      return tok;
	    }
	  },

	  /**
	   * Each.
	   */

	  each: function() {
	    var captures;
	    if (captures = /^(?:- *)?(?:each|for) +([a-zA-Z_$][\w$]*)(?: *, *([a-zA-Z_$][\w$]*))? * in *([^\n]+)/.exec(this.input)) {
	      this.consume(captures[0].length);
	      var tok = this.tok('each', captures[1]);
	      tok.key = captures[2] || '$index';
	      assertExpression(captures[3])
	      tok.code = captures[3];
	      return tok;
	    }
	  },

	  /**
	   * Code.
	   */

	  code: function() {
	    var captures;
	    if (captures = /^(!?=|-)[ \t]*([^\n]+)/.exec(this.input)) {
	      this.consume(captures[0].length);
	      var flags = captures[1];
	      captures[1] = captures[2];
	      var tok = this.tok('code', captures[1]);
	      tok.escape = flags.charAt(0) === '=';
	      tok.buffer = flags.charAt(0) === '=' || flags.charAt(1) === '=';
	      if (tok.buffer) assertExpression(captures[1])
	      return tok;
	    }
	  },


	  /**
	   * Block code.
	   */

	  blockCode: function() {
	    var captures;
	    if (captures = /^-\n/.exec(this.input)) {
	      this.consume(captures[0].length - 1);
	      var tok = this.tok('blockCode');
	      this.pipeless = true;
	      return tok;
	    }
	  },

	  /**
	   * Attributes.
	   */

	  attrs: function() {
	    if ('(' == this.input.charAt(0)) {
	      var index = this.bracketExpression().end
	        , str = this.input.substr(1, index-1)
	        , tok = this.tok('attrs');

	      assertNestingCorrect(str);

	      var quote = '';
	      var interpolate = function (attr) {
	        return attr.replace(/(\\)?#\{(.+)/g, function(_, escape, expr){
	          if (escape) return _;
	          try {
	            var range = characterParser.parseMax(expr);
	            if (expr[range.end] !== '}') return _.substr(0, 2) + interpolate(_.substr(2));
	            assertExpression(range.src)
	            return quote + " + (" + range.src + ") + " + quote + interpolate(expr.substr(range.end + 1));
	          } catch (ex) {
	            return _.substr(0, 2) + interpolate(_.substr(2));
	          }
	        });
	      }

	      this.consume(index + 1);
	      tok.attrs = [];

	      var escapedAttr = true
	      var key = '';
	      var val = '';
	      var interpolatable = '';
	      var state = characterParser.defaultState();
	      var loc = 'key';
	      var isEndOfAttribute = function (i) {
	        if (key.trim() === '') return false;
	        if (i === str.length) return true;
	        if (loc === 'key') {
	          if (str[i] === ' ' || str[i] === '\n') {
	            for (var x = i; x < str.length; x++) {
	              if (str[x] != ' ' && str[x] != '\n') {
	                if (str[x] === '=' || str[x] === '!' || str[x] === ',') return false;
	                else return true;
	              }
	            }
	          }
	          return str[i] === ','
	        } else if (loc === 'value' && !state.isNesting()) {
	          try {
	            assertExpression(val);
	            if (str[i] === ' ' || str[i] === '\n') {
	              for (var x = i; x < str.length; x++) {
	                if (str[x] != ' ' && str[x] != '\n') {
	                  if (characterParser.isPunctuator(str[x]) && str[x] != '"' && str[x] != "'") return false;
	                  else return true;
	                }
	              }
	            }
	            return str[i] === ',';
	          } catch (ex) {
	            return false;
	          }
	        }
	      }

	      this.lineno += str.split("\n").length - 1;

	      for (var i = 0; i <= str.length; i++) {
	        if (isEndOfAttribute(i)) {
	          val = val.trim();
	          if (val) assertExpression(val)
	          key = key.trim();
	          key = key.replace(/^['"]|['"]$/g, '');
	          tok.attrs.push({
	            name: key,
	            val: '' == val ? true : val,
	            escaped: escapedAttr
	          });
	          key = val = '';
	          loc = 'key';
	          escapedAttr = false;
	        } else {
	          switch (loc) {
	            case 'key-char':
	              if (str[i] === quote) {
	                loc = 'key';
	                if (i + 1 < str.length && [' ', ',', '!', '=', '\n'].indexOf(str[i + 1]) === -1)
	                  throw new Error('Unexpected character ' + str[i + 1] + ' expected ` `, `\\n`, `,`, `!` or `=`');
	              } else {
	                key += str[i];
	              }
	              break;
	            case 'key':
	              if (key === '' && (str[i] === '"' || str[i] === "'")) {
	                loc = 'key-char';
	                quote = str[i];
	              } else if (str[i] === '!' || str[i] === '=') {
	                escapedAttr = str[i] !== '!';
	                if (str[i] === '!') i++;
	                if (str[i] !== '=') throw new Error('Unexpected character ' + str[i] + ' expected `=`');
	                loc = 'value';
	                state = characterParser.defaultState();
	              } else {
	                key += str[i]
	              }
	              break;
	            case 'value':
	              state = characterParser.parseChar(str[i], state);
	              if (state.isString()) {
	                loc = 'string';
	                quote = str[i];
	                interpolatable = str[i];
	              } else {
	                val += str[i];
	              }
	              break;
	            case 'string':
	              state = characterParser.parseChar(str[i], state);
	              interpolatable += str[i];
	              if (!state.isString()) {
	                loc = 'value';
	                val += interpolate(interpolatable);
	              }
	              break;
	          }
	        }
	      }

	      if ('/' == this.input.charAt(0)) {
	        this.consume(1);
	        tok.selfClosing = true;
	      }

	      return tok;
	    }
	  },

	  /**
	   * &attributes block
	   */
	  attributesBlock: function () {
	    var captures;
	    if (/^&attributes\b/.test(this.input)) {
	      this.consume(11);
	      var args = this.bracketExpression();
	      this.consume(args.end + 1);
	      return this.tok('&attributes', args.src);
	    }
	  },

	  /**
	   * Indent | Outdent | Newline.
	   */

	  indent: function() {
	    var captures, re;

	    // established regexp
	    if (this.indentRe) {
	      captures = this.indentRe.exec(this.input);
	    // determine regexp
	    } else {
	      // tabs
	      re = /^\n(\t*) */;
	      captures = re.exec(this.input);

	      // spaces
	      if (captures && !captures[1].length) {
	        re = /^\n( *)/;
	        captures = re.exec(this.input);
	      }

	      // established
	      if (captures && captures[1].length) this.indentRe = re;
	    }

	    if (captures) {
	      var tok
	        , indents = captures[1].length;

	      ++this.lineno;
	      this.consume(indents + 1);

	      if (' ' == this.input[0] || '\t' == this.input[0]) {
	        throw new Error('Invalid indentation, you can use tabs or spaces but not both');
	      }

	      // blank line
	      if ('\n' == this.input[0]) {
	        this.pipeless = false;
	        return this.tok('newline');
	      }

	      // outdent
	      if (this.indentStack.length && indents < this.indentStack[0]) {
	        while (this.indentStack.length && this.indentStack[0] > indents) {
	          this.stash.push(this.tok('outdent'));
	          this.indentStack.shift();
	        }
	        tok = this.stash.pop();
	      // indent
	      } else if (indents && indents != this.indentStack[0]) {
	        this.indentStack.unshift(indents);
	        tok = this.tok('indent', indents);
	      // newline
	      } else {
	        tok = this.tok('newline');
	      }

	      this.pipeless = false;
	      return tok;
	    }
	  },

	  /**
	   * Pipe-less text consumed only when
	   * pipeless is true;
	   */

	  pipelessText: function() {
	    if (!this.pipeless) return;
	    var captures, re;

	    // established regexp
	    if (this.indentRe) {
	      captures = this.indentRe.exec(this.input);
	    // determine regexp
	    } else {
	      // tabs
	      re = /^\n(\t*) */;
	      captures = re.exec(this.input);

	      // spaces
	      if (captures && !captures[1].length) {
	        re = /^\n( *)/;
	        captures = re.exec(this.input);
	      }

	      // established
	      if (captures && captures[1].length) this.indentRe = re;
	    }

	    var indents = captures && captures[1].length;
	    if (indents && (this.indentStack.length === 0 || indents > this.indentStack[0])) {
	      var indent = captures[1];
	      var line;
	      var tokens = [];
	      var isMatch;
	      do {
	        // text has `\n` as a prefix
	        var i = this.input.substr(1).indexOf('\n');
	        if (-1 == i) i = this.input.length - 1;
	        var str = this.input.substr(1, i);
	        isMatch = str.substr(0, indent.length) === indent || !str.trim();
	        if (isMatch) {
	          // consume test along with `\n` prefix if match
	          this.consume(str.length + 1);
	          ++this.lineno;
	          tokens.push(str.substr(indent.length));
	        }
	      } while(this.input.length && isMatch);
	      while (this.input.length === 0 && tokens[tokens.length - 1] === '') tokens.pop();
	      return this.tok('pipeless-text', tokens);
	    }
	  },

	  /**
	   * ':'
	   */

	  colon: function() {
	    var good = /^: +/.test(this.input);
	    var res = this.scan(/^: */, ':');
	    if (res && !good) {
	      console.warn('Warning: space required after `:` on line ' + this.lineno +
	          ' of jade file "' + this.filename + '"');
	    }
	    return res;
	  },

	  fail: function () {
	    throw new Error('unexpected text ' + this.input.substr(0, 5));
	  },

	  /**
	   * Return the next token object, or those
	   * previously stashed by lookahead.
	   *
	   * @return {Object}
	   * @api private
	   */

	  advance: function(){
	    return this.stashed()
	      || this.next();
	  },

	  /**
	   * Return the next token object.
	   *
	   * @return {Object}
	   * @api private
	   */

	  next: function() {
	    return this.deferred()
	      || this.blank()
	      || this.eos()
	      || this.pipelessText()
	      || this.yield()
	      || this.doctype()
	      || this.interpolation()
	      || this["case"]()
	      || this.when()
	      || this["default"]()
	      || this["extends"]()
	      || this.append()
	      || this.prepend()
	      || this.block()
	      || this.mixinBlock()
	      || this.include()
	      || this.includeFiltered()
	      || this.mixin()
	      || this.call()
	      || this.conditional()
	      || this.each()
	      || this["while"]()
	      || this.tag()
	      || this.filter()
	      || this.blockCode()
	      || this.code()
	      || this.id()
	      || this.className()
	      || this.attrs()
	      || this.attributesBlock()
	      || this.indent()
	      || this.text()
	      || this.comment()
	      || this.colon()
	      || this.dot()
	      || this.textFail()
	      || this.fail();
	  }
	};


/***/ },
/* 12 */
/***/ function(module, exports) {

	'use strict';

	/**
	 * Merge `b` into `a`.
	 *
	 * @param {Object} a
	 * @param {Object} b
	 * @return {Object}
	 * @api public
	 */

	exports.merge = function(a, b) {
	  for (var key in b) a[key] = b[key];
	  return a;
	};

	exports.stringify = function(str) {
	  return JSON.stringify(str)
	             .replace(/\u2028/g, '\\u2028')
	             .replace(/\u2029/g, '\\u2029');
	};

	exports.walkAST = function walkAST(ast, before, after) {
	  before && before(ast);
	  switch (ast.type) {
	    case 'Block':
	      ast.nodes.forEach(function (node) {
	        walkAST(node, before, after);
	      });
	      break;
	    case 'Case':
	    case 'Each':
	    case 'Mixin':
	    case 'Tag':
	    case 'When':
	    case 'Code':
	      ast.block && walkAST(ast.block, before, after);
	      break;
	    case 'Attrs':
	    case 'BlockComment':
	    case 'Comment':
	    case 'Doctype':
	    case 'Filter':
	    case 'Literal':
	    case 'MixinBlock':
	    case 'Text':
	      break;
	    default:
	      throw new Error('Unexpected node type ' + ast.type);
	      break;
	  }
	  after && after(ast);
	};


/***/ },
/* 13 */
/***/ function(module, exports) {

	exports = (module.exports = parse);
	exports.parse = parse;
	function parse(src, state, options) {
	  options = options || {};
	  state = state || exports.defaultState();
	  var start = options.start || 0;
	  var end = options.end || src.length;
	  var index = start;
	  while (index < end) {
	    if (state.roundDepth < 0 || state.curlyDepth < 0 || state.squareDepth < 0) {
	      throw new SyntaxError('Mismatched Bracket: ' + src[index - 1]);
	    }
	    exports.parseChar(src[index++], state);
	  }
	  return state;
	}

	exports.parseMax = parseMax;
	function parseMax(src, options) {
	  options = options || {};
	  var start = options.start || 0;
	  var index = start;
	  var state = exports.defaultState();
	  while (state.roundDepth >= 0 && state.curlyDepth >= 0 && state.squareDepth >= 0) {
	    if (index >= src.length) {
	      throw new Error('The end of the string was reached with no closing bracket found.');
	    }
	    exports.parseChar(src[index++], state);
	  }
	  var end = index - 1;
	  return {
	    start: start,
	    end: end,
	    src: src.substring(start, end)
	  };
	}

	exports.parseUntil = parseUntil;
	function parseUntil(src, delimiter, options) {
	  options = options || {};
	  var includeLineComment = options.includeLineComment || false;
	  var start = options.start || 0;
	  var index = start;
	  var state = exports.defaultState();
	  while (state.isString() || state.regexp || state.blockComment ||
	         (!includeLineComment && state.lineComment) || !startsWith(src, delimiter, index)) {
	    exports.parseChar(src[index++], state);
	  }
	  var end = index;
	  return {
	    start: start,
	    end: end,
	    src: src.substring(start, end)
	  };
	}


	exports.parseChar = parseChar;
	function parseChar(character, state) {
	  if (character.length !== 1) throw new Error('Character must be a string of length 1');
	  state = state || exports.defaultState();
	  state.src = state.src || '';
	  state.src += character;
	  var wasComment = state.blockComment || state.lineComment;
	  var lastChar = state.history ? state.history[0] : '';

	  if (state.regexpStart) {
	    if (character === '/' || character == '*') {
	      state.regexp = false;
	    }
	    state.regexpStart = false;
	  }
	  if (state.lineComment) {
	    if (character === '\n') {
	      state.lineComment = false;
	    }
	  } else if (state.blockComment) {
	    if (state.lastChar === '*' && character === '/') {
	      state.blockComment = false;
	    }
	  } else if (state.singleQuote) {
	    if (character === '\'' && !state.escaped) {
	      state.singleQuote = false;
	    } else if (character === '\\' && !state.escaped) {
	      state.escaped = true;
	    } else {
	      state.escaped = false;
	    }
	  } else if (state.doubleQuote) {
	    if (character === '"' && !state.escaped) {
	      state.doubleQuote = false;
	    } else if (character === '\\' && !state.escaped) {
	      state.escaped = true;
	    } else {
	      state.escaped = false;
	    }
	  } else if (state.regexp) {
	    if (character === '/' && !state.escaped) {
	      state.regexp = false;
	    } else if (character === '\\' && !state.escaped) {
	      state.escaped = true;
	    } else {
	      state.escaped = false;
	    }
	  } else if (lastChar === '/' && character === '/') {
	    state.history = state.history.substr(1);
	    state.lineComment = true;
	  } else if (lastChar === '/' && character === '*') {
	    state.history = state.history.substr(1);
	    state.blockComment = true;
	  } else if (character === '/' && isRegexp(state.history)) {
	    state.regexp = true;
	    state.regexpStart = true;
	  } else if (character === '\'') {
	    state.singleQuote = true;
	  } else if (character === '"') {
	    state.doubleQuote = true;
	  } else if (character === '(') {
	    state.roundDepth++;
	  } else if (character === ')') {
	    state.roundDepth--;
	  } else if (character === '{') {
	    state.curlyDepth++;
	  } else if (character === '}') {
	    state.curlyDepth--;
	  } else if (character === '[') {
	    state.squareDepth++;
	  } else if (character === ']') {
	    state.squareDepth--;
	  }
	  if (!state.blockComment && !state.lineComment && !wasComment) state.history = character + state.history;
	  state.lastChar = character; // store last character for ending block comments
	  return state;
	}

	exports.defaultState = function () { return new State() };
	function State() {
	  this.lineComment = false;
	  this.blockComment = false;

	  this.singleQuote = false;
	  this.doubleQuote = false;
	  this.regexp = false;

	  this.escaped = false;

	  this.roundDepth = 0;
	  this.curlyDepth = 0;
	  this.squareDepth = 0;

	  this.history = ''
	  this.lastChar = ''
	}
	State.prototype.isString = function () {
	  return this.singleQuote || this.doubleQuote;
	}
	State.prototype.isComment = function () {
	  return this.lineComment || this.blockComment;
	}
	State.prototype.isNesting = function () {
	  return this.isString() || this.isComment() || this.regexp || this.roundDepth > 0 || this.curlyDepth > 0 || this.squareDepth > 0
	}

	function startsWith(str, start, i) {
	  return str.substr(i || 0, start.length) === start;
	}

	exports.isPunctuator = isPunctuator
	function isPunctuator(c) {
	  if (!c) return true; // the start of a string is a punctuator
	  var code = c.charCodeAt(0)

	  switch (code) {
	    case 46:   // . dot
	    case 40:   // ( open bracket
	    case 41:   // ) close bracket
	    case 59:   // ; semicolon
	    case 44:   // , comma
	    case 123:  // { open curly brace
	    case 125:  // } close curly brace
	    case 91:   // [
	    case 93:   // ]
	    case 58:   // :
	    case 63:   // ?
	    case 126:  // ~
	    case 37:   // %
	    case 38:   // &
	    case 42:   // *:
	    case 43:   // +
	    case 45:   // -
	    case 47:   // /
	    case 60:   // <
	    case 62:   // >
	    case 94:   // ^
	    case 124:  // |
	    case 33:   // !
	    case 61:   // =
	      return true;
	    default:
	      return false;
	  }
	}
	exports.isKeyword = isKeyword
	function isKeyword(id) {
	  return (id === 'if') || (id === 'in') || (id === 'do') || (id === 'var') || (id === 'for') || (id === 'new') ||
	         (id === 'try') || (id === 'let') || (id === 'this') || (id === 'else') || (id === 'case') ||
	         (id === 'void') || (id === 'with') || (id === 'enum') || (id === 'while') || (id === 'break') || (id === 'catch') ||
	         (id === 'throw') || (id === 'const') || (id === 'yield') || (id === 'class') || (id === 'super') ||
	         (id === 'return') || (id === 'typeof') || (id === 'delete') || (id === 'switch') || (id === 'export') ||
	         (id === 'import') || (id === 'default') || (id === 'finally') || (id === 'extends') || (id === 'function') ||
	         (id === 'continue') || (id === 'debugger') || (id === 'package') || (id === 'private') || (id === 'interface') ||
	         (id === 'instanceof') || (id === 'implements') || (id === 'protected') || (id === 'public') || (id === 'static') ||
	         (id === 'yield') || (id === 'let');
	}

	function isRegexp(history) {
	  //could be start of regexp or divide sign

	  history = history.replace(/^\s*/, '');

	  //unless its an `if`, `while`, `for` or `with` it's a divide, so we assume it's a divide
	  if (history[0] === ')') return false;
	  //unless it's a function expression, it's a regexp, so we assume it's a regexp
	  if (history[0] === '}') return true;
	  //any punctuation means it's a regexp
	  if (isPunctuator(history[0])) return true;
	  //if the last thing was a keyword then it must be a regexp (e.g. `typeof /foo/`)
	  if (/^\w+\b/.test(history) && isKeyword(/^\w+\b/.exec(history)[0].split('').reverse().join(''))) return true;

	  return false;
	}


/***/ },
/* 14 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.Node = __webpack_require__(15);
	exports.Tag = __webpack_require__(16);
	exports.Code = __webpack_require__(20);
	exports.Each = __webpack_require__(21);
	exports.Case = __webpack_require__(22);
	exports.Text = __webpack_require__(23);
	exports.Block = __webpack_require__(18);
	exports.MixinBlock = __webpack_require__(24);
	exports.Mixin = __webpack_require__(25);
	exports.Filter = __webpack_require__(26);
	exports.Comment = __webpack_require__(27);
	exports.Literal = __webpack_require__(28);
	exports.BlockComment = __webpack_require__(29);
	exports.Doctype = __webpack_require__(30);


/***/ },
/* 15 */
/***/ function(module, exports) {

	'use strict';

	var Node = module.exports = function Node(){};

	/**
	 * Clone this node (return itself)
	 *
	 * @return {Node}
	 * @api private
	 */

	Node.prototype.clone = function(){
	  var err = new Error('node.clone is deprecated and will be removed in v2.0.0');
	  console.warn(err.stack);
	  return this;
	};

	Node.prototype.type = '';


/***/ },
/* 16 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var Attrs = __webpack_require__(17);
	var Block = __webpack_require__(18);
	var inlineTags = __webpack_require__(19);

	/**
	 * Initialize a `Tag` node with the given tag `name` and optional `block`.
	 *
	 * @param {String} name
	 * @param {Block} block
	 * @api public
	 */

	var Tag = module.exports = function Tag(name, block) {
	  Attrs.call(this);
	  this.name = name;
	  this.block = block || new Block;
	};

	// Inherit from `Attrs`.
	Tag.prototype = Object.create(Attrs.prototype);
	Tag.prototype.constructor = Tag;

	Tag.prototype.type = 'Tag';

	/**
	 * Clone this tag.
	 *
	 * @return {Tag}
	 * @api private
	 */

	Tag.prototype.clone = function(){
	  var err = new Error('tag.clone is deprecated and will be removed in v2.0.0');
	  console.warn(err.stack);

	  var clone = new Tag(this.name, this.block.clone());
	  clone.line = this.line;
	  clone.attrs = this.attrs;
	  clone.textOnly = this.textOnly;
	  return clone;
	};

	/**
	 * Check if this tag is an inline tag.
	 *
	 * @return {Boolean}
	 * @api private
	 */

	Tag.prototype.isInline = function(){
	  return ~inlineTags.indexOf(this.name);
	};

	/**
	 * Check if this tag's contents can be inlined.  Used for pretty printing.
	 *
	 * @return {Boolean}
	 * @api private
	 */

	Tag.prototype.canInline = function(){
	  var nodes = this.block.nodes;

	  function isInline(node){
	    // Recurse if the node is a block
	    if (node.isBlock) return node.nodes.every(isInline);
	    return node.isText || (node.isInline && node.isInline());
	  }

	  // Empty tag
	  if (!nodes.length) return true;

	  // Text-only or inline-only tag
	  if (1 == nodes.length) return isInline(nodes[0]);

	  // Multi-line inline-only tag
	  if (this.block.nodes.every(isInline)) {
	    for (var i = 1, len = nodes.length; i < len; ++i) {
	      if (nodes[i-1].isText && nodes[i].isText)
	        return false;
	    }
	    return true;
	  }

	  // Mixed tag
	  return false;
	};


/***/ },
/* 17 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var Node = __webpack_require__(15);

	/**
	 * Initialize a `Attrs` node.
	 *
	 * @api public
	 */

	var Attrs = module.exports = function Attrs() {
	  this.attributeNames = [];
	  this.attrs = [];
	  this.attributeBlocks = [];
	};

	// Inherit from `Node`.
	Attrs.prototype = Object.create(Node.prototype);
	Attrs.prototype.constructor = Attrs;

	Attrs.prototype.type = 'Attrs';

	/**
	 * Set attribute `name` to `val`, keep in mind these become
	 * part of a raw js object literal, so to quote a value you must
	 * '"quote me"', otherwise or example 'user.name' is literal JavaScript.
	 *
	 * @param {String} name
	 * @param {String} val
	 * @param {Boolean} escaped
	 * @return {Tag} for chaining
	 * @api public
	 */

	Attrs.prototype.setAttribute = function(name, val, escaped){
	  if (name !== 'class' && this.attributeNames.indexOf(name) !== -1) {
	    throw new Error('Duplicate attribute "' + name + '" is not allowed.');
	  }
	  this.attributeNames.push(name);
	  this.attrs.push({ name: name, val: val, escaped: escaped });
	  return this;
	};

	/**
	 * Remove attribute `name` when present.
	 *
	 * @param {String} name
	 * @api public
	 */

	Attrs.prototype.removeAttribute = function(name){
	  var err = new Error('attrs.removeAttribute is deprecated and will be removed in v2.0.0');
	  console.warn(err.stack);

	  for (var i = 0, len = this.attrs.length; i < len; ++i) {
	    if (this.attrs[i] && this.attrs[i].name == name) {
	      delete this.attrs[i];
	    }
	  }
	};

	/**
	 * Get attribute value by `name`.
	 *
	 * @param {String} name
	 * @return {String}
	 * @api public
	 */

	Attrs.prototype.getAttribute = function(name){
	  var err = new Error('attrs.getAttribute is deprecated and will be removed in v2.0.0');
	  console.warn(err.stack);

	  for (var i = 0, len = this.attrs.length; i < len; ++i) {
	    if (this.attrs[i] && this.attrs[i].name == name) {
	      return this.attrs[i].val;
	    }
	  }
	};

	Attrs.prototype.addAttributes = function (src) {
	  this.attributeBlocks.push(src);
	};


/***/ },
/* 18 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var Node = __webpack_require__(15);

	/**
	 * Initialize a new `Block` with an optional `node`.
	 *
	 * @param {Node} node
	 * @api public
	 */

	var Block = module.exports = function Block(node){
	  this.nodes = [];
	  if (node) this.push(node);
	};

	// Inherit from `Node`.
	Block.prototype = Object.create(Node.prototype);
	Block.prototype.constructor = Block;

	Block.prototype.type = 'Block';

	/**
	 * Block flag.
	 */

	Block.prototype.isBlock = true;

	/**
	 * Replace the nodes in `other` with the nodes
	 * in `this` block.
	 *
	 * @param {Block} other
	 * @api private
	 */

	Block.prototype.replace = function(other){
	  var err = new Error('block.replace is deprecated and will be removed in v2.0.0');
	  console.warn(err.stack);

	  other.nodes = this.nodes;
	};

	/**
	 * Push the given `node`.
	 *
	 * @param {Node} node
	 * @return {Number}
	 * @api public
	 */

	Block.prototype.push = function(node){
	  return this.nodes.push(node);
	};

	/**
	 * Check if this block is empty.
	 *
	 * @return {Boolean}
	 * @api public
	 */

	Block.prototype.isEmpty = function(){
	  return 0 == this.nodes.length;
	};

	/**
	 * Unshift the given `node`.
	 *
	 * @param {Node} node
	 * @return {Number}
	 * @api public
	 */

	Block.prototype.unshift = function(node){
	  return this.nodes.unshift(node);
	};

	/**
	 * Return the "last" block, or the first `yield` node.
	 *
	 * @return {Block}
	 * @api private
	 */

	Block.prototype.includeBlock = function(){
	  var ret = this
	    , node;

	  for (var i = 0, len = this.nodes.length; i < len; ++i) {
	    node = this.nodes[i];
	    if (node.yield) return node;
	    else if (node.textOnly) continue;
	    else if (node.includeBlock) ret = node.includeBlock();
	    else if (node.block && !node.block.isEmpty()) ret = node.block.includeBlock();
	    if (ret.yield) return ret;
	  }

	  return ret;
	};

	/**
	 * Return a clone of this block.
	 *
	 * @return {Block}
	 * @api private
	 */

	Block.prototype.clone = function(){
	  var err = new Error('block.clone is deprecated and will be removed in v2.0.0');
	  console.warn(err.stack);

	  var clone = new Block;
	  for (var i = 0, len = this.nodes.length; i < len; ++i) {
	    clone.push(this.nodes[i].clone());
	  }
	  return clone;
	};


/***/ },
/* 19 */
/***/ function(module, exports) {

	'use strict';

	module.exports = [
	    'a'
	  , 'abbr'
	  , 'acronym'
	  , 'b'
	  , 'br'
	  , 'code'
	  , 'em'
	  , 'font'
	  , 'i'
	  , 'img'
	  , 'ins'
	  , 'kbd'
	  , 'map'
	  , 'samp'
	  , 'small'
	  , 'span'
	  , 'strong'
	  , 'sub'
	  , 'sup'
	];

/***/ },
/* 20 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var Node = __webpack_require__(15);

	/**
	 * Initialize a `Code` node with the given code `val`.
	 * Code may also be optionally buffered and escaped.
	 *
	 * @param {String} val
	 * @param {Boolean} buffer
	 * @param {Boolean} escape
	 * @api public
	 */

	var Code = module.exports = function Code(val, buffer, escape) {
	  this.val = val;
	  this.buffer = buffer;
	  this.escape = escape;
	  if (val.match(/^ *else/)) this.debug = false;
	};

	// Inherit from `Node`.
	Code.prototype = Object.create(Node.prototype);
	Code.prototype.constructor = Code;

	Code.prototype.type = 'Code'; // prevent the minifiers removing this

/***/ },
/* 21 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var Node = __webpack_require__(15);

	/**
	 * Initialize an `Each` node, representing iteration
	 *
	 * @param {String} obj
	 * @param {String} val
	 * @param {String} key
	 * @param {Block} block
	 * @api public
	 */

	var Each = module.exports = function Each(obj, val, key, block) {
	  this.obj = obj;
	  this.val = val;
	  this.key = key;
	  this.block = block;
	};

	// Inherit from `Node`.
	Each.prototype = Object.create(Node.prototype);
	Each.prototype.constructor = Each;

	Each.prototype.type = 'Each';


/***/ },
/* 22 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var Node = __webpack_require__(15);

	/**
	 * Initialize a new `Case` with `expr`.
	 *
	 * @param {String} expr
	 * @api public
	 */

	var Case = exports = module.exports = function Case(expr, block){
	  this.expr = expr;
	  this.block = block;
	};

	// Inherit from `Node`.
	Case.prototype = Object.create(Node.prototype);
	Case.prototype.constructor = Case;

	Case.prototype.type = 'Case';

	var When = exports.When = function When(expr, block){
	  this.expr = expr;
	  this.block = block;
	  this.debug = false;
	};

	// Inherit from `Node`.
	When.prototype = Object.create(Node.prototype);
	When.prototype.constructor = When;

	When.prototype.type = 'When';


/***/ },
/* 23 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var Node = __webpack_require__(15);

	/**
	 * Initialize a `Text` node with optional `line`.
	 *
	 * @param {String} line
	 * @api public
	 */

	var Text = module.exports = function Text(line) {
	  this.val = line;
	};

	// Inherit from `Node`.
	Text.prototype = Object.create(Node.prototype);
	Text.prototype.constructor = Text;

	Text.prototype.type = 'Text';

	/**
	 * Flag as text.
	 */

	Text.prototype.isText = true;

/***/ },
/* 24 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var Node = __webpack_require__(15);

	/**
	 * Initialize a new `Block` with an optional `node`.
	 *
	 * @param {Node} node
	 * @api public
	 */

	var MixinBlock = module.exports = function MixinBlock(){};

	// Inherit from `Node`.
	MixinBlock.prototype = Object.create(Node.prototype);
	MixinBlock.prototype.constructor = MixinBlock;

	MixinBlock.prototype.type = 'MixinBlock';


/***/ },
/* 25 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var Attrs = __webpack_require__(17);

	/**
	 * Initialize a new `Mixin` with `name` and `block`.
	 *
	 * @param {String} name
	 * @param {String} args
	 * @param {Block} block
	 * @api public
	 */

	var Mixin = module.exports = function Mixin(name, args, block, call){
	  Attrs.call(this);
	  this.name = name;
	  this.args = args;
	  this.block = block;
	  this.call = call;
	};

	// Inherit from `Attrs`.
	Mixin.prototype = Object.create(Attrs.prototype);
	Mixin.prototype.constructor = Mixin;

	Mixin.prototype.type = 'Mixin';


/***/ },
/* 26 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var Node = __webpack_require__(15);

	/**
	 * Initialize a `Filter` node with the given
	 * filter `name` and `block`.
	 *
	 * @param {String} name
	 * @param {Block|Node} block
	 * @api public
	 */

	var Filter = module.exports = function Filter(name, block, attrs) {
	  this.name = name;
	  this.block = block;
	  this.attrs = attrs;
	};

	// Inherit from `Node`.
	Filter.prototype = Object.create(Node.prototype);
	Filter.prototype.constructor = Filter;

	Filter.prototype.type = 'Filter';


/***/ },
/* 27 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var Node = __webpack_require__(15);

	/**
	 * Initialize a `Comment` with the given `val`, optionally `buffer`,
	 * otherwise the comment may render in the output.
	 *
	 * @param {String} val
	 * @param {Boolean} buffer
	 * @api public
	 */

	var Comment = module.exports = function Comment(val, buffer) {
	  this.val = val;
	  this.buffer = buffer;
	};

	// Inherit from `Node`.
	Comment.prototype = Object.create(Node.prototype);
	Comment.prototype.constructor = Comment;

	Comment.prototype.type = 'Comment';


/***/ },
/* 28 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var Node = __webpack_require__(15);

	/**
	 * Initialize a `Literal` node with the given `str.
	 *
	 * @param {String} str
	 * @api public
	 */

	var Literal = module.exports = function Literal(str) {
	  this.str = str;
	};

	// Inherit from `Node`.
	Literal.prototype = Object.create(Node.prototype);
	Literal.prototype.constructor = Literal;

	Literal.prototype.type = 'Literal';


/***/ },
/* 29 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var Node = __webpack_require__(15);

	/**
	 * Initialize a `BlockComment` with the given `block`.
	 *
	 * @param {String} val
	 * @param {Block} block
	 * @param {Boolean} buffer
	 * @api public
	 */

	var BlockComment = module.exports = function BlockComment(val, block, buffer) {
	  this.block = block;
	  this.val = val;
	  this.buffer = buffer;
	};

	// Inherit from `Node`.
	BlockComment.prototype = Object.create(Node.prototype);
	BlockComment.prototype.constructor = BlockComment;

	BlockComment.prototype.type = 'BlockComment';


/***/ },
/* 30 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var Node = __webpack_require__(15);

	/**
	 * Initialize a `Doctype` with the given `val`.
	 *
	 * @param {String} val
	 * @api public
	 */

	var Doctype = module.exports = function Doctype(val) {
	  this.val = val;
	};

	// Inherit from `Node`.
	Doctype.prototype = Object.create(Node.prototype);
	Doctype.prototype.constructor = Doctype;

	Doctype.prototype.type = 'Doctype';


/***/ },
/* 31 */
/***/ function(module, exports) {

	'use strict';

	module.exports = filter;
	function filter(name, str, options) {
	  if (typeof filter[name] === 'function') {
	    return filter[name](str, options);
	  } else {
	    throw new Error('unknown filter ":' + name + '"');
	  }
	}


/***/ },
/* 32 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.

	// resolves . and .. elements in a path array with directory names there
	// must be no slashes, empty elements, or device names (c:\) in the array
	// (so also no leading and trailing slashes - it does not distinguish
	// relative and absolute paths)
	function normalizeArray(parts, allowAboveRoot) {
	  // if the path tries to go above the root, `up` ends up > 0
	  var up = 0;
	  for (var i = parts.length - 1; i >= 0; i--) {
	    var last = parts[i];
	    if (last === '.') {
	      parts.splice(i, 1);
	    } else if (last === '..') {
	      parts.splice(i, 1);
	      up++;
	    } else if (up) {
	      parts.splice(i, 1);
	      up--;
	    }
	  }

	  // if the path is allowed to go above the root, restore leading ..s
	  if (allowAboveRoot) {
	    for (; up--; up) {
	      parts.unshift('..');
	    }
	  }

	  return parts;
	}

	// Split a filename into [root, dir, basename, ext], unix version
	// 'root' is just a slash, or nothing.
	var splitPathRe =
	    /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/;
	var splitPath = function(filename) {
	  return splitPathRe.exec(filename).slice(1);
	};

	// path.resolve([from ...], to)
	// posix version
	exports.resolve = function() {
	  var resolvedPath = '',
	      resolvedAbsolute = false;

	  for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
	    var path = (i >= 0) ? arguments[i] : process.cwd();

	    // Skip empty and invalid entries
	    if (typeof path !== 'string') {
	      throw new TypeError('Arguments to path.resolve must be strings');
	    } else if (!path) {
	      continue;
	    }

	    resolvedPath = path + '/' + resolvedPath;
	    resolvedAbsolute = path.charAt(0) === '/';
	  }

	  // At this point the path should be resolved to a full absolute path, but
	  // handle relative paths to be safe (might happen when process.cwd() fails)

	  // Normalize the path
	  resolvedPath = normalizeArray(filter(resolvedPath.split('/'), function(p) {
	    return !!p;
	  }), !resolvedAbsolute).join('/');

	  return ((resolvedAbsolute ? '/' : '') + resolvedPath) || '.';
	};

	// path.normalize(path)
	// posix version
	exports.normalize = function(path) {
	  var isAbsolute = exports.isAbsolute(path),
	      trailingSlash = substr(path, -1) === '/';

	  // Normalize the path
	  path = normalizeArray(filter(path.split('/'), function(p) {
	    return !!p;
	  }), !isAbsolute).join('/');

	  if (!path && !isAbsolute) {
	    path = '.';
	  }
	  if (path && trailingSlash) {
	    path += '/';
	  }

	  return (isAbsolute ? '/' : '') + path;
	};

	// posix version
	exports.isAbsolute = function(path) {
	  return path.charAt(0) === '/';
	};

	// posix version
	exports.join = function() {
	  var paths = Array.prototype.slice.call(arguments, 0);
	  return exports.normalize(filter(paths, function(p, index) {
	    if (typeof p !== 'string') {
	      throw new TypeError('Arguments to path.join must be strings');
	    }
	    return p;
	  }).join('/'));
	};


	// path.relative(from, to)
	// posix version
	exports.relative = function(from, to) {
	  from = exports.resolve(from).substr(1);
	  to = exports.resolve(to).substr(1);

	  function trim(arr) {
	    var start = 0;
	    for (; start < arr.length; start++) {
	      if (arr[start] !== '') break;
	    }

	    var end = arr.length - 1;
	    for (; end >= 0; end--) {
	      if (arr[end] !== '') break;
	    }

	    if (start > end) return [];
	    return arr.slice(start, end - start + 1);
	  }

	  var fromParts = trim(from.split('/'));
	  var toParts = trim(to.split('/'));

	  var length = Math.min(fromParts.length, toParts.length);
	  var samePartsLength = length;
	  for (var i = 0; i < length; i++) {
	    if (fromParts[i] !== toParts[i]) {
	      samePartsLength = i;
	      break;
	    }
	  }

	  var outputParts = [];
	  for (var i = samePartsLength; i < fromParts.length; i++) {
	    outputParts.push('..');
	  }

	  outputParts = outputParts.concat(toParts.slice(samePartsLength));

	  return outputParts.join('/');
	};

	exports.sep = '/';
	exports.delimiter = ':';

	exports.dirname = function(path) {
	  var result = splitPath(path),
	      root = result[0],
	      dir = result[1];

	  if (!root && !dir) {
	    // No dirname whatsoever
	    return '.';
	  }

	  if (dir) {
	    // It has a dirname, strip trailing slash
	    dir = dir.substr(0, dir.length - 1);
	  }

	  return root + dir;
	};


	exports.basename = function(path, ext) {
	  var f = splitPath(path)[2];
	  // TODO: make this comparison case-insensitive on windows?
	  if (ext && f.substr(-1 * ext.length) === ext) {
	    f = f.substr(0, f.length - ext.length);
	  }
	  return f;
	};


	exports.extname = function(path) {
	  return splitPath(path)[3];
	};

	function filter (xs, f) {
	    if (xs.filter) return xs.filter(f);
	    var res = [];
	    for (var i = 0; i < xs.length; i++) {
	        if (f(xs[i], i, xs)) res.push(xs[i]);
	    }
	    return res;
	}

	// String.prototype.substr - negative index don't work in IE8
	var substr = 'ab'.substr(-1) === 'b'
	    ? function (str, start, len) { return str.substr(start, len) }
	    : function (str, start, len) {
	        if (start < 0) start = str.length + start;
	        return str.substr(start, len);
	    }
	;

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(9)))

/***/ },
/* 33 */
/***/ function(module, exports, __webpack_require__) {

	'use strict'

	var acorn = __webpack_require__(34);
	var walk = __webpack_require__(35);

	var lastSRC = '(null)';
	var lastRes = true;
	var lastConstants = undefined;

	var STATEMENT_WHITE_LIST = {
	  'EmptyStatement': true,
	  'ExpressionStatement': true,
	};
	var EXPRESSION_WHITE_LIST = {
	  'ParenthesizedExpression': true,
	  'ArrayExpression': true,
	  'ObjectExpression': true,
	  'SequenceExpression': true,
	  'TemplateLiteral': true,
	  'UnaryExpression': true,
	  'BinaryExpression': true,
	  'LogicalExpression': true,
	  'ConditionalExpression': true,
	  'Identifier': true,
	  'Literal': true,
	  'ComprehensionExpression': true,
	  'TaggedTemplateExpression': true,
	  'MemberExpression': true,
	  'CallExpression': true,
	  'NewExpression': true,
	};
	module.exports = isConstant;
	function isConstant(src, constants) {
	  src = '(' + src + ')';
	  if (lastSRC === src && lastConstants === constants) return lastRes;
	  lastSRC = src;
	  lastConstants = constants;
	  if (!isExpression(src)) return lastRes = false;
	  var ast;
	  try {
	    ast = acorn.parse(src, {
	      ecmaVersion: 6,
	      allowReturnOutsideFunction: true,
	      allowImportExportEverywhere: true,
	      allowHashBang: true
	    });
	  } catch (ex) {
	    return lastRes = false;
	  }
	  var isConstant = true;
	  walk.simple(ast, {
	    Statement: function (node) {
	      if (isConstant) {
	        if (STATEMENT_WHITE_LIST[node.type] !== true) {
	          isConstant = false;
	        }
	      }
	    },
	    Expression: function (node) {
	      if (isConstant) {
	        if (EXPRESSION_WHITE_LIST[node.type] !== true) {
	          isConstant = false;
	        }
	      }
	    },
	    MemberExpression: function (node) {
	      if (isConstant) {
	        if (node.computed) isConstant = false;
	        else if (node.property.name[0] === '_') isConstant = false;
	      }
	    },
	    Identifier: function (node) {
	      if (isConstant) {
	        if (!constants || !(node.name in constants)) {
	          isConstant = false;
	        }
	      }
	    },
	  });
	  return lastRes = isConstant;
	}
	isConstant.isConstant = isConstant;

	isConstant.toConstant = toConstant;
	function toConstant(src, constants) {
	  if (!isConstant(src, constants)) throw new Error(JSON.stringify(src) + ' is not constant.');
	  return Function(Object.keys(constants || {}).join(','), 'return (' + src + ')').apply(null, Object.keys(constants || {}).map(function (key) {
	    return constants[key];
	  }));
	}

	function isExpression(src) {
	  try {
	    eval('throw "STOP"; (function () { return (' + src + '); })()');
	    return false;
	  }
	  catch (err) {
	    return err === 'STOP';
	  }
	}


/***/ },
/* 34 */
/***/ function(module, exports, __webpack_require__) {

	var require;var require;(function(f){if(true){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}g.acorn = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return require(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(_dereq_,module,exports){
	// A recursive descent parser operates by defining functions for all
	// syntactic elements, and recursively calling those, each function
	// advancing the input stream and returning an AST node. Precedence
	// of constructs (for example, the fact that `!x[1]` means `!(x[1])`
	// instead of `(!x)[1]` is handled by the fact that the parser
	// function that parses unary prefix operators is called first, and
	// in turn calls the function that parses `[]` subscripts  that
	// way, it'll receive the node for `x[1]` already parsed, and wraps
	// *that* in the unary operator node.
	//
	// Acorn uses an [operator precedence parser][opp] to handle binary
	// operator precedence, because it is much more compact than using
	// the technique outlined above, which uses different, nesting
	// functions to specify precedence, for all of the ten binary
	// precedence levels that JavaScript defines.
	//
	// [opp]: http://en.wikipedia.org/wiki/Operator-precedence_parser

	"use strict";

	var _tokentype = _dereq_("./tokentype");

	var _state = _dereq_("./state");

	var pp = _state.Parser.prototype;

	// Check if property name clashes with already added.
	// Object/class getters and setters are not allowed to clash 
	// either with each other or with an init property  and in
	// strict mode, init properties are also not allowed to be repeated.

	pp.checkPropClash = function (prop, propHash) {
	  if (this.options.ecmaVersion >= 6 && (prop.computed || prop.method || prop.shorthand)) return;
	  var key = prop.key;var name = undefined;
	  switch (key.type) {
	    case "Identifier":
	      name = key.name;break;
	    case "Literal":
	      name = String(key.value);break;
	    default:
	      return;
	  }
	  var kind = prop.kind;

	  if (this.options.ecmaVersion >= 6) {
	    if (name === "__proto__" && kind === "init") {
	      if (propHash.proto) this.raise(key.start, "Redefinition of __proto__ property");
	      propHash.proto = true;
	    }
	    return;
	  }
	  name = "$" + name;
	  var other = propHash[name];
	  if (other) {
	    var isGetSet = kind !== "init";
	    if ((this.strict || isGetSet) && other[kind] || !(isGetSet ^ other.init)) this.raise(key.start, "Redefinition of property");
	  } else {
	    other = propHash[name] = {
	      init: false,
	      get: false,
	      set: false
	    };
	  }
	  other[kind] = true;
	};

	// ### Expression parsing

	// These nest, from the most general expression type at the top to
	// 'atomic', nondivisible expression types at the bottom. Most of
	// the functions will simply let the function(s) below them parse,
	// and, *if* the syntactic construct they handle is present, wrap
	// the AST node that the inner parser gave them in another node.

	// Parse a full expression. The optional arguments are used to
	// forbid the `in` operator (in for loops initalization expressions)
	// and provide reference for storing '=' operator inside shorthand
	// property assignment in contexts where both object expression
	// and object pattern might appear (so it's possible to raise
	// delayed syntax error at correct position).

	pp.parseExpression = function (noIn, refShorthandDefaultPos) {
	  var startPos = this.start,
	      startLoc = this.startLoc;
	  var expr = this.parseMaybeAssign(noIn, refShorthandDefaultPos);
	  if (this.type === _tokentype.types.comma) {
	    var node = this.startNodeAt(startPos, startLoc);
	    node.expressions = [expr];
	    while (this.eat(_tokentype.types.comma)) node.expressions.push(this.parseMaybeAssign(noIn, refShorthandDefaultPos));
	    return this.finishNode(node, "SequenceExpression");
	  }
	  return expr;
	};

	// Parse an assignment expression. This includes applications of
	// operators like `+=`.

	pp.parseMaybeAssign = function (noIn, refShorthandDefaultPos, afterLeftParse) {
	  if (this.type == _tokentype.types._yield && this.inGenerator) return this.parseYield();

	  var failOnShorthandAssign = undefined;
	  if (!refShorthandDefaultPos) {
	    refShorthandDefaultPos = { start: 0 };
	    failOnShorthandAssign = true;
	  } else {
	    failOnShorthandAssign = false;
	  }
	  var startPos = this.start,
	      startLoc = this.startLoc;
	  if (this.type == _tokentype.types.parenL || this.type == _tokentype.types.name) this.potentialArrowAt = this.start;
	  var left = this.parseMaybeConditional(noIn, refShorthandDefaultPos);
	  if (afterLeftParse) left = afterLeftParse.call(this, left, startPos, startLoc);
	  if (this.type.isAssign) {
	    var node = this.startNodeAt(startPos, startLoc);
	    node.operator = this.value;
	    node.left = this.type === _tokentype.types.eq ? this.toAssignable(left) : left;
	    refShorthandDefaultPos.start = 0; // reset because shorthand default was used correctly
	    this.checkLVal(left);
	    this.next();
	    node.right = this.parseMaybeAssign(noIn);
	    return this.finishNode(node, "AssignmentExpression");
	  } else if (failOnShorthandAssign && refShorthandDefaultPos.start) {
	    this.unexpected(refShorthandDefaultPos.start);
	  }
	  return left;
	};

	// Parse a ternary conditional (`?:`) operator.

	pp.parseMaybeConditional = function (noIn, refShorthandDefaultPos) {
	  var startPos = this.start,
	      startLoc = this.startLoc;
	  var expr = this.parseExprOps(noIn, refShorthandDefaultPos);
	  if (refShorthandDefaultPos && refShorthandDefaultPos.start) return expr;
	  if (this.eat(_tokentype.types.question)) {
	    var node = this.startNodeAt(startPos, startLoc);
	    node.test = expr;
	    node.consequent = this.parseMaybeAssign();
	    this.expect(_tokentype.types.colon);
	    node.alternate = this.parseMaybeAssign(noIn);
	    return this.finishNode(node, "ConditionalExpression");
	  }
	  return expr;
	};

	// Start the precedence parser.

	pp.parseExprOps = function (noIn, refShorthandDefaultPos) {
	  var startPos = this.start,
	      startLoc = this.startLoc;
	  var expr = this.parseMaybeUnary(refShorthandDefaultPos);
	  if (refShorthandDefaultPos && refShorthandDefaultPos.start) return expr;
	  return this.parseExprOp(expr, startPos, startLoc, -1, noIn);
	};

	// Parse binary operators with the operator precedence parsing
	// algorithm. `left` is the left-hand side of the operator.
	// `minPrec` provides context that allows the function to stop and
	// defer further parser to one of its callers when it encounters an
	// operator that has a lower precedence than the set it is parsing.

	pp.parseExprOp = function (left, leftStartPos, leftStartLoc, minPrec, noIn) {
	  var prec = this.type.binop;
	  if (prec != null && (!noIn || this.type !== _tokentype.types._in)) {
	    if (prec > minPrec) {
	      var node = this.startNodeAt(leftStartPos, leftStartLoc);
	      node.left = left;
	      node.operator = this.value;
	      var op = this.type;
	      this.next();
	      var startPos = this.start,
	          startLoc = this.startLoc;
	      node.right = this.parseExprOp(this.parseMaybeUnary(), startPos, startLoc, prec, noIn);
	      this.finishNode(node, op === _tokentype.types.logicalOR || op === _tokentype.types.logicalAND ? "LogicalExpression" : "BinaryExpression");
	      return this.parseExprOp(node, leftStartPos, leftStartLoc, minPrec, noIn);
	    }
	  }
	  return left;
	};

	// Parse unary operators, both prefix and postfix.

	pp.parseMaybeUnary = function (refShorthandDefaultPos) {
	  if (this.type.prefix) {
	    var node = this.startNode(),
	        update = this.type === _tokentype.types.incDec;
	    node.operator = this.value;
	    node.prefix = true;
	    this.next();
	    node.argument = this.parseMaybeUnary();
	    if (refShorthandDefaultPos && refShorthandDefaultPos.start) this.unexpected(refShorthandDefaultPos.start);
	    if (update) this.checkLVal(node.argument);else if (this.strict && node.operator === "delete" && node.argument.type === "Identifier") this.raise(node.start, "Deleting local variable in strict mode");
	    return this.finishNode(node, update ? "UpdateExpression" : "UnaryExpression");
	  }
	  var startPos = this.start,
	      startLoc = this.startLoc;
	  var expr = this.parseExprSubscripts(refShorthandDefaultPos);
	  if (refShorthandDefaultPos && refShorthandDefaultPos.start) return expr;
	  while (this.type.postfix && !this.canInsertSemicolon()) {
	    var node = this.startNodeAt(startPos, startLoc);
	    node.operator = this.value;
	    node.prefix = false;
	    node.argument = expr;
	    this.checkLVal(expr);
	    this.next();
	    expr = this.finishNode(node, "UpdateExpression");
	  }
	  return expr;
	};

	// Parse call, dot, and `[]`-subscript expressions.

	pp.parseExprSubscripts = function (refShorthandDefaultPos) {
	  var startPos = this.start,
	      startLoc = this.startLoc;
	  var expr = this.parseExprAtom(refShorthandDefaultPos);
	  var skipArrowSubscripts = expr.type === "ArrowFunctionExpression" && this.input.slice(this.lastTokStart, this.lastTokEnd) !== ")";
	  if (refShorthandDefaultPos && refShorthandDefaultPos.start || skipArrowSubscripts) return expr;
	  return this.parseSubscripts(expr, startPos, startLoc);
	};

	pp.parseSubscripts = function (base, startPos, startLoc, noCalls) {
	  for (;;) {
	    if (this.eat(_tokentype.types.dot)) {
	      var node = this.startNodeAt(startPos, startLoc);
	      node.object = base;
	      node.property = this.parseIdent(true);
	      node.computed = false;
	      base = this.finishNode(node, "MemberExpression");
	    } else if (this.eat(_tokentype.types.bracketL)) {
	      var node = this.startNodeAt(startPos, startLoc);
	      node.object = base;
	      node.property = this.parseExpression();
	      node.computed = true;
	      this.expect(_tokentype.types.bracketR);
	      base = this.finishNode(node, "MemberExpression");
	    } else if (!noCalls && this.eat(_tokentype.types.parenL)) {
	      var node = this.startNodeAt(startPos, startLoc);
	      node.callee = base;
	      node.arguments = this.parseExprList(_tokentype.types.parenR, false);
	      base = this.finishNode(node, "CallExpression");
	    } else if (this.type === _tokentype.types.backQuote) {
	      var node = this.startNodeAt(startPos, startLoc);
	      node.tag = base;
	      node.quasi = this.parseTemplate();
	      base = this.finishNode(node, "TaggedTemplateExpression");
	    } else {
	      return base;
	    }
	  }
	};

	// Parse an atomic expression  either a single token that is an
	// expression, an expression started by a keyword like `function` or
	// `new`, or an expression wrapped in punctuation like `()`, `[]`,
	// or `{}`.

	pp.parseExprAtom = function (refShorthandDefaultPos) {
	  var node = undefined,
	      canBeArrow = this.potentialArrowAt == this.start;
	  switch (this.type) {
	    case _tokentype.types._super:
	      if (!this.inFunction) this.raise(this.start, "'super' outside of function or class");
	    case _tokentype.types._this:
	      var type = this.type === _tokentype.types._this ? "ThisExpression" : "Super";
	      node = this.startNode();
	      this.next();
	      return this.finishNode(node, type);

	    case _tokentype.types._yield:
	      if (this.inGenerator) this.unexpected();

	    case _tokentype.types.name:
	      var startPos = this.start,
	          startLoc = this.startLoc;
	      var id = this.parseIdent(this.type !== _tokentype.types.name);
	      if (canBeArrow && !this.canInsertSemicolon() && this.eat(_tokentype.types.arrow)) return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), [id]);
	      return id;

	    case _tokentype.types.regexp:
	      var value = this.value;
	      node = this.parseLiteral(value.value);
	      node.regex = { pattern: value.pattern, flags: value.flags };
	      return node;

	    case _tokentype.types.num:case _tokentype.types.string:
	      return this.parseLiteral(this.value);

	    case _tokentype.types._null:case _tokentype.types._true:case _tokentype.types._false:
	      node = this.startNode();
	      node.value = this.type === _tokentype.types._null ? null : this.type === _tokentype.types._true;
	      node.raw = this.type.keyword;
	      this.next();
	      return this.finishNode(node, "Literal");

	    case _tokentype.types.parenL:
	      return this.parseParenAndDistinguishExpression(canBeArrow);

	    case _tokentype.types.bracketL:
	      node = this.startNode();
	      this.next();
	      // check whether this is array comprehension or regular array
	      if (this.options.ecmaVersion >= 7 && this.type === _tokentype.types._for) {
	        return this.parseComprehension(node, false);
	      }
	      node.elements = this.parseExprList(_tokentype.types.bracketR, true, true, refShorthandDefaultPos);
	      return this.finishNode(node, "ArrayExpression");

	    case _tokentype.types.braceL:
	      return this.parseObj(false, refShorthandDefaultPos);

	    case _tokentype.types._function:
	      node = this.startNode();
	      this.next();
	      return this.parseFunction(node, false);

	    case _tokentype.types._class:
	      return this.parseClass(this.startNode(), false);

	    case _tokentype.types._new:
	      return this.parseNew();

	    case _tokentype.types.backQuote:
	      return this.parseTemplate();

	    default:
	      this.unexpected();
	  }
	};

	pp.parseLiteral = function (value) {
	  var node = this.startNode();
	  node.value = value;
	  node.raw = this.input.slice(this.start, this.end);
	  this.next();
	  return this.finishNode(node, "Literal");
	};

	pp.parseParenExpression = function () {
	  this.expect(_tokentype.types.parenL);
	  var val = this.parseExpression();
	  this.expect(_tokentype.types.parenR);
	  return val;
	};

	pp.parseParenAndDistinguishExpression = function (canBeArrow) {
	  var startPos = this.start,
	      startLoc = this.startLoc,
	      val = undefined;
	  if (this.options.ecmaVersion >= 6) {
	    this.next();

	    if (this.options.ecmaVersion >= 7 && this.type === _tokentype.types._for) {
	      return this.parseComprehension(this.startNodeAt(startPos, startLoc), true);
	    }

	    var innerStartPos = this.start,
	        innerStartLoc = this.startLoc;
	    var exprList = [],
	        first = true;
	    var refShorthandDefaultPos = { start: 0 },
	        spreadStart = undefined,
	        innerParenStart = undefined;
	    while (this.type !== _tokentype.types.parenR) {
	      first ? first = false : this.expect(_tokentype.types.comma);
	      if (this.type === _tokentype.types.ellipsis) {
	        spreadStart = this.start;
	        exprList.push(this.parseParenItem(this.parseRest()));
	        break;
	      } else {
	        if (this.type === _tokentype.types.parenL && !innerParenStart) {
	          innerParenStart = this.start;
	        }
	        exprList.push(this.parseMaybeAssign(false, refShorthandDefaultPos, this.parseParenItem));
	      }
	    }
	    var innerEndPos = this.start,
	        innerEndLoc = this.startLoc;
	    this.expect(_tokentype.types.parenR);

	    if (canBeArrow && !this.canInsertSemicolon() && this.eat(_tokentype.types.arrow)) {
	      if (innerParenStart) this.unexpected(innerParenStart);
	      return this.parseParenArrowList(startPos, startLoc, exprList);
	    }

	    if (!exprList.length) this.unexpected(this.lastTokStart);
	    if (spreadStart) this.unexpected(spreadStart);
	    if (refShorthandDefaultPos.start) this.unexpected(refShorthandDefaultPos.start);

	    if (exprList.length > 1) {
	      val = this.startNodeAt(innerStartPos, innerStartLoc);
	      val.expressions = exprList;
	      this.finishNodeAt(val, "SequenceExpression", innerEndPos, innerEndLoc);
	    } else {
	      val = exprList[0];
	    }
	  } else {
	    val = this.parseParenExpression();
	  }

	  if (this.options.preserveParens) {
	    var par = this.startNodeAt(startPos, startLoc);
	    par.expression = val;
	    return this.finishNode(par, "ParenthesizedExpression");
	  } else {
	    return val;
	  }
	};

	pp.parseParenItem = function (item) {
	  return item;
	};

	pp.parseParenArrowList = function (startPos, startLoc, exprList) {
	  return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), exprList);
	};

	// New's precedence is slightly tricky. It must allow its argument
	// to be a `[]` or dot subscript expression, but not a call  at
	// least, not without wrapping it in parentheses. Thus, it uses the

	var empty = [];

	pp.parseNew = function () {
	  var node = this.startNode();
	  var meta = this.parseIdent(true);
	  if (this.options.ecmaVersion >= 6 && this.eat(_tokentype.types.dot)) {
	    node.meta = meta;
	    node.property = this.parseIdent(true);
	    if (node.property.name !== "target") this.raise(node.property.start, "The only valid meta property for new is new.target");
	    if (!this.inFunction) this.raise(node.start, "new.target can only be used in functions");
	    return this.finishNode(node, "MetaProperty");
	  }
	  var startPos = this.start,
	      startLoc = this.startLoc;
	  node.callee = this.parseSubscripts(this.parseExprAtom(), startPos, startLoc, true);
	  if (this.eat(_tokentype.types.parenL)) node.arguments = this.parseExprList(_tokentype.types.parenR, false);else node.arguments = empty;
	  return this.finishNode(node, "NewExpression");
	};

	// Parse template expression.

	pp.parseTemplateElement = function () {
	  var elem = this.startNode();
	  elem.value = {
	    raw: this.input.slice(this.start, this.end).replace(/\r\n?/g, '\n'),
	    cooked: this.value
	  };
	  this.next();
	  elem.tail = this.type === _tokentype.types.backQuote;
	  return this.finishNode(elem, "TemplateElement");
	};

	pp.parseTemplate = function () {
	  var node = this.startNode();
	  this.next();
	  node.expressions = [];
	  var curElt = this.parseTemplateElement();
	  node.quasis = [curElt];
	  while (!curElt.tail) {
	    this.expect(_tokentype.types.dollarBraceL);
	    node.expressions.push(this.parseExpression());
	    this.expect(_tokentype.types.braceR);
	    node.quasis.push(curElt = this.parseTemplateElement());
	  }
	  this.next();
	  return this.finishNode(node, "TemplateLiteral");
	};

	// Parse an object literal or binding pattern.

	pp.parseObj = function (isPattern, refShorthandDefaultPos) {
	  var node = this.startNode(),
	      first = true,
	      propHash = {};
	  node.properties = [];
	  this.next();
	  while (!this.eat(_tokentype.types.braceR)) {
	    if (!first) {
	      this.expect(_tokentype.types.comma);
	      if (this.afterTrailingComma(_tokentype.types.braceR)) break;
	    } else first = false;

	    var prop = this.startNode(),
	        isGenerator = undefined,
	        startPos = undefined,
	        startLoc = undefined;
	    if (this.options.ecmaVersion >= 6) {
	      prop.method = false;
	      prop.shorthand = false;
	      if (isPattern || refShorthandDefaultPos) {
	        startPos = this.start;
	        startLoc = this.startLoc;
	      }
	      if (!isPattern) isGenerator = this.eat(_tokentype.types.star);
	    }
	    this.parsePropertyName(prop);
	    this.parsePropertyValue(prop, isPattern, isGenerator, startPos, startLoc, refShorthandDefaultPos);
	    this.checkPropClash(prop, propHash);
	    node.properties.push(this.finishNode(prop, "Property"));
	  }
	  return this.finishNode(node, isPattern ? "ObjectPattern" : "ObjectExpression");
	};

	pp.parsePropertyValue = function (prop, isPattern, isGenerator, startPos, startLoc, refShorthandDefaultPos) {
	  if (this.eat(_tokentype.types.colon)) {
	    prop.value = isPattern ? this.parseMaybeDefault(this.start, this.startLoc) : this.parseMaybeAssign(false, refShorthandDefaultPos);
	    prop.kind = "init";
	  } else if (this.options.ecmaVersion >= 6 && this.type === _tokentype.types.parenL) {
	    if (isPattern) this.unexpected();
	    prop.kind = "init";
	    prop.method = true;
	    prop.value = this.parseMethod(isGenerator);
	  } else if (this.options.ecmaVersion >= 5 && !prop.computed && prop.key.type === "Identifier" && (prop.key.name === "get" || prop.key.name === "set") && (this.type != _tokentype.types.comma && this.type != _tokentype.types.braceR)) {
	    if (isGenerator || isPattern) this.unexpected();
	    prop.kind = prop.key.name;
	    this.parsePropertyName(prop);
	    prop.value = this.parseMethod(false);
	    var paramCount = prop.kind === "get" ? 0 : 1;
	    if (prop.value.params.length !== paramCount) {
	      var start = prop.value.start;
	      if (prop.kind === "get") this.raise(start, "getter should have no params");else this.raise(start, "setter should have exactly one param");
	    }
	  } else if (this.options.ecmaVersion >= 6 && !prop.computed && prop.key.type === "Identifier") {
	    prop.kind = "init";
	    if (isPattern) {
	      if (this.keywords.test(prop.key.name) || (this.strict ? this.reservedWordsStrictBind : this.reservedWords).test(prop.key.name)) this.raise(prop.key.start, "Binding " + prop.key.name);
	      prop.value = this.parseMaybeDefault(startPos, startLoc, prop.key);
	    } else if (this.type === _tokentype.types.eq && refShorthandDefaultPos) {
	      if (!refShorthandDefaultPos.start) refShorthandDefaultPos.start = this.start;
	      prop.value = this.parseMaybeDefault(startPos, startLoc, prop.key);
	    } else {
	      prop.value = prop.key;
	    }
	    prop.shorthand = true;
	  } else this.unexpected();
	};

	pp.parsePropertyName = function (prop) {
	  if (this.options.ecmaVersion >= 6) {
	    if (this.eat(_tokentype.types.bracketL)) {
	      prop.computed = true;
	      prop.key = this.parseMaybeAssign();
	      this.expect(_tokentype.types.bracketR);
	      return prop.key;
	    } else {
	      prop.computed = false;
	    }
	  }
	  return prop.key = this.type === _tokentype.types.num || this.type === _tokentype.types.string ? this.parseExprAtom() : this.parseIdent(true);
	};

	// Initialize empty function node.

	pp.initFunction = function (node) {
	  node.id = null;
	  if (this.options.ecmaVersion >= 6) {
	    node.generator = false;
	    node.expression = false;
	  }
	};

	// Parse object or class method.

	pp.parseMethod = function (isGenerator) {
	  var node = this.startNode();
	  this.initFunction(node);
	  this.expect(_tokentype.types.parenL);
	  node.params = this.parseBindingList(_tokentype.types.parenR, false, false);
	  if (this.options.ecmaVersion >= 6) node.generator = isGenerator;
	  this.parseFunctionBody(node, false);
	  return this.finishNode(node, "FunctionExpression");
	};

	// Parse arrow function expression with given parameters.

	pp.parseArrowExpression = function (node, params) {
	  this.initFunction(node);
	  node.params = this.toAssignableList(params, true);
	  this.parseFunctionBody(node, true);
	  return this.finishNode(node, "ArrowFunctionExpression");
	};

	// Parse function body and check parameters.

	pp.parseFunctionBody = function (node, isArrowFunction) {
	  var isExpression = isArrowFunction && this.type !== _tokentype.types.braceL;

	  if (isExpression) {
	    node.body = this.parseMaybeAssign();
	    node.expression = true;
	  } else {
	    // Start a new scope with regard to labels and the `inFunction`
	    // flag (restore them to their old value afterwards).
	    var oldInFunc = this.inFunction,
	        oldInGen = this.inGenerator,
	        oldLabels = this.labels;
	    this.inFunction = true;this.inGenerator = node.generator;this.labels = [];
	    node.body = this.parseBlock(true);
	    node.expression = false;
	    this.inFunction = oldInFunc;this.inGenerator = oldInGen;this.labels = oldLabels;
	  }

	  // If this is a strict mode function, verify that argument names
	  // are not repeated, and it does not try to bind the words `eval`
	  // or `arguments`.
	  if (this.strict || !isExpression && node.body.body.length && this.isUseStrict(node.body.body[0])) {
	    var oldStrict = this.strict;
	    this.strict = true;
	    if (node.id) this.checkLVal(node.id, true);
	    this.checkParams(node);
	    this.strict = oldStrict;
	  } else if (isArrowFunction) {
	    this.checkParams(node);
	  }
	};

	// Checks function params for various disallowed patterns such as using "eval"
	// or "arguments" and duplicate parameters.

	pp.checkParams = function (node) {
	  var nameHash = {};
	  for (var i = 0; i < node.params.length; i++) {
	    this.checkLVal(node.params[i], true, nameHash);
	  }
	};

	// Parses a comma-separated list of expressions, and returns them as
	// an array. `close` is the token type that ends the list, and
	// `allowEmpty` can be turned on to allow subsequent commas with
	// nothing in between them to be parsed as `null` (which is needed
	// for array literals).

	pp.parseExprList = function (close, allowTrailingComma, allowEmpty, refShorthandDefaultPos) {
	  var elts = [],
	      first = true;
	  while (!this.eat(close)) {
	    if (!first) {
	      this.expect(_tokentype.types.comma);
	      if (allowTrailingComma && this.afterTrailingComma(close)) break;
	    } else first = false;

	    var elt = undefined;
	    if (allowEmpty && this.type === _tokentype.types.comma) elt = null;else if (this.type === _tokentype.types.ellipsis) elt = this.parseSpread(refShorthandDefaultPos);else elt = this.parseMaybeAssign(false, refShorthandDefaultPos);
	    elts.push(elt);
	  }
	  return elts;
	};

	// Parse the next token as an identifier. If `liberal` is true (used
	// when parsing properties), it will also convert keywords into
	// identifiers.

	pp.parseIdent = function (liberal) {
	  var node = this.startNode();
	  if (liberal && this.options.allowReserved == "never") liberal = false;
	  if (this.type === _tokentype.types.name) {
	    if (!liberal && (this.strict ? this.reservedWordsStrict : this.reservedWords).test(this.value) && (this.options.ecmaVersion >= 6 || this.input.slice(this.start, this.end).indexOf("\\") == -1)) this.raise(this.start, "The keyword '" + this.value + "' is reserved");
	    node.name = this.value;
	  } else if (liberal && this.type.keyword) {
	    node.name = this.type.keyword;
	  } else {
	    this.unexpected();
	  }
	  this.next();
	  return this.finishNode(node, "Identifier");
	};

	// Parses yield expression inside generator.

	pp.parseYield = function () {
	  var node = this.startNode();
	  this.next();
	  if (this.type == _tokentype.types.semi || this.canInsertSemicolon() || this.type != _tokentype.types.star && !this.type.startsExpr) {
	    node.delegate = false;
	    node.argument = null;
	  } else {
	    node.delegate = this.eat(_tokentype.types.star);
	    node.argument = this.parseMaybeAssign();
	  }
	  return this.finishNode(node, "YieldExpression");
	};

	// Parses array and generator comprehensions.

	pp.parseComprehension = function (node, isGenerator) {
	  node.blocks = [];
	  while (this.type === _tokentype.types._for) {
	    var block = this.startNode();
	    this.next();
	    this.expect(_tokentype.types.parenL);
	    block.left = this.parseBindingAtom();
	    this.checkLVal(block.left, true);
	    this.expectContextual("of");
	    block.right = this.parseExpression();
	    this.expect(_tokentype.types.parenR);
	    node.blocks.push(this.finishNode(block, "ComprehensionBlock"));
	  }
	  node.filter = this.eat(_tokentype.types._if) ? this.parseParenExpression() : null;
	  node.body = this.parseExpression();
	  this.expect(isGenerator ? _tokentype.types.parenR : _tokentype.types.bracketR);
	  node.generator = isGenerator;
	  return this.finishNode(node, "ComprehensionExpression");
	};

	},{"./state":10,"./tokentype":14}],2:[function(_dereq_,module,exports){
	// This is a trick taken from Esprima. It turns out that, on
	// non-Chrome browsers, to check whether a string is in a set, a
	// predicate containing a big ugly `switch` statement is faster than
	// a regular expression, and on Chrome the two are about on par.
	// This function uses `eval` (non-lexical) to produce such a
	// predicate from a space-separated string of words.
	//
	// It starts by sorting the words by length.

	// Reserved word lists for various dialects of the language

	"use strict";

	exports.__esModule = true;
	exports.isIdentifierStart = isIdentifierStart;
	exports.isIdentifierChar = isIdentifierChar;
	var reservedWords = {
	  3: "abstract boolean byte char class double enum export extends final float goto implements import int interface long native package private protected public short static super synchronized throws transient volatile",
	  5: "class enum extends super const export import",
	  6: "enum",
	  strict: "implements interface let package private protected public static yield",
	  strictBind: "eval arguments"
	};

	exports.reservedWords = reservedWords;
	// And the keywords

	var ecma5AndLessKeywords = "break case catch continue debugger default do else finally for function if return switch throw try var while with null true false instanceof typeof void delete new in this";

	var keywords = {
	  5: ecma5AndLessKeywords,
	  6: ecma5AndLessKeywords + " let const class extends export import yield super"
	};

	exports.keywords = keywords;
	// ## Character categories

	// Big ugly regular expressions that match characters in the
	// whitespace, identifier, and identifier-start categories. These
	// are only applied when a character is found to actually have a
	// code point above 128.
	// Generated by `tools/generate-identifier-regex.js`.

	var nonASCIIidentifierStartChars = "-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------";
	var nonASCIIidentifierChars = "-------------------------------------------------------------------------------------------------------------------------------------------------";

	var nonASCIIidentifierStart = new RegExp("[" + nonASCIIidentifierStartChars + "]");
	var nonASCIIidentifier = new RegExp("[" + nonASCIIidentifierStartChars + nonASCIIidentifierChars + "]");

	nonASCIIidentifierStartChars = nonASCIIidentifierChars = null;

	// These are a run-length and offset encoded representation of the
	// >0xffff code points that are a valid part of identifiers. The
	// offset starts at 0x10000, and each pair of numbers represents an
	// offset to the next range, and then a size of the range. They were
	// generated by tools/generate-identifier-regex.js
	var astralIdentifierStartCodes = [0, 11, 2, 25, 2, 18, 2, 1, 2, 14, 3, 13, 35, 122, 70, 52, 268, 28, 4, 48, 48, 31, 17, 26, 6, 37, 11, 29, 3, 35, 5, 7, 2, 4, 43, 157, 99, 39, 9, 51, 157, 310, 10, 21, 11, 7, 153, 5, 3, 0, 2, 43, 2, 1, 4, 0, 3, 22, 11, 22, 10, 30, 98, 21, 11, 25, 71, 55, 7, 1, 65, 0, 16, 3, 2, 2, 2, 26, 45, 28, 4, 28, 36, 7, 2, 27, 28, 53, 11, 21, 11, 18, 14, 17, 111, 72, 955, 52, 76, 44, 33, 24, 27, 35, 42, 34, 4, 0, 13, 47, 15, 3, 22, 0, 38, 17, 2, 24, 133, 46, 39, 7, 3, 1, 3, 21, 2, 6, 2, 1, 2, 4, 4, 0, 32, 4, 287, 47, 21, 1, 2, 0, 185, 46, 82, 47, 21, 0, 60, 42, 502, 63, 32, 0, 449, 56, 1288, 920, 104, 110, 2962, 1070, 13266, 568, 8, 30, 114, 29, 19, 47, 17, 3, 32, 20, 6, 18, 881, 68, 12, 0, 67, 12, 16481, 1, 3071, 106, 6, 12, 4, 8, 8, 9, 5991, 84, 2, 70, 2, 1, 3, 0, 3, 1, 3, 3, 2, 11, 2, 0, 2, 6, 2, 64, 2, 3, 3, 7, 2, 6, 2, 27, 2, 3, 2, 4, 2, 0, 4, 6, 2, 339, 3, 24, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 7, 4149, 196, 1340, 3, 2, 26, 2, 1, 2, 0, 3, 0, 2, 9, 2, 3, 2, 0, 2, 0, 7, 0, 5, 0, 2, 0, 2, 0, 2, 2, 2, 1, 2, 0, 3, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 1, 2, 0, 3, 3, 2, 6, 2, 3, 2, 3, 2, 0, 2, 9, 2, 16, 6, 2, 2, 4, 2, 16, 4421, 42710, 42, 4148, 12, 221, 16355, 541];
	var astralIdentifierCodes = [509, 0, 227, 0, 150, 4, 294, 9, 1368, 2, 2, 1, 6, 3, 41, 2, 5, 0, 166, 1, 1306, 2, 54, 14, 32, 9, 16, 3, 46, 10, 54, 9, 7, 2, 37, 13, 2, 9, 52, 0, 13, 2, 49, 13, 16, 9, 83, 11, 168, 11, 6, 9, 8, 2, 57, 0, 2, 6, 3, 1, 3, 2, 10, 0, 11, 1, 3, 6, 4, 4, 316, 19, 13, 9, 214, 6, 3, 8, 112, 16, 16, 9, 82, 12, 9, 9, 535, 9, 20855, 9, 135, 4, 60, 6, 26, 9, 1016, 45, 17, 3, 19723, 1, 5319, 4, 4, 5, 9, 7, 3, 6, 31, 3, 149, 2, 1418, 49, 4305, 6, 792618, 239];

	// This has a complexity linear to the value of the code. The
	// assumption is that looking up astral identifier characters is
	// rare.
	function isInAstralSet(code, set) {
	  var pos = 0x10000;
	  for (var i = 0; i < set.length; i += 2) {
	    pos += set[i];
	    if (pos > code) return false;
	    pos += set[i + 1];
	    if (pos >= code) return true;
	  }
	}

	// Test whether a given character code starts an identifier.

	function isIdentifierStart(code, astral) {
	  if (code < 65) return code === 36;
	  if (code < 91) return true;
	  if (code < 97) return code === 95;
	  if (code < 123) return true;
	  if (code <= 0xffff) return code >= 0xaa && nonASCIIidentifierStart.test(String.fromCharCode(code));
	  if (astral === false) return false;
	  return isInAstralSet(code, astralIdentifierStartCodes);
	}

	// Test whether a given character is part of an identifier.

	function isIdentifierChar(code, astral) {
	  if (code < 48) return code === 36;
	  if (code < 58) return true;
	  if (code < 65) return false;
	  if (code < 91) return true;
	  if (code < 97) return code === 95;
	  if (code < 123) return true;
	  if (code <= 0xffff) return code >= 0xaa && nonASCIIidentifier.test(String.fromCharCode(code));
	  if (astral === false) return false;
	  return isInAstralSet(code, astralIdentifierStartCodes) || isInAstralSet(code, astralIdentifierCodes);
	}

	},{}],3:[function(_dereq_,module,exports){
	// Acorn is a tiny, fast JavaScript parser written in JavaScript.
	//
	// Acorn was written by Marijn Haverbeke, Ingvar Stepanyan, and
	// various contributors and released under an MIT license.
	//
	// Git repositories for Acorn are available at
	//
	//     http://marijnhaverbeke.nl/git/acorn
	//     https://github.com/marijnh/acorn.git
	//
	// Please use the [github bug tracker][ghbt] to report issues.
	//
	// [ghbt]: https://github.com/marijnh/acorn/issues
	//
	// This file defines the main parser interface. The library also comes
	// with a [error-tolerant parser][dammit] and an
	// [abstract syntax tree walker][walk], defined in other files.
	//
	// [dammit]: acorn_loose.js
	// [walk]: util/walk.js

	"use strict";

	exports.__esModule = true;
	exports.parse = parse;
	exports.parseExpressionAt = parseExpressionAt;
	exports.tokenizer = tokenizer;

	var _state = _dereq_("./state");

	_dereq_("./parseutil");

	_dereq_("./statement");

	_dereq_("./lval");

	_dereq_("./expression");

	_dereq_("./location");

	exports.Parser = _state.Parser;
	exports.plugins = _state.plugins;

	var _options = _dereq_("./options");

	exports.defaultOptions = _options.defaultOptions;

	var _locutil = _dereq_("./locutil");

	exports.Position = _locutil.Position;
	exports.SourceLocation = _locutil.SourceLocation;
	exports.getLineInfo = _locutil.getLineInfo;

	var _node = _dereq_("./node");

	exports.Node = _node.Node;

	var _tokentype = _dereq_("./tokentype");

	exports.TokenType = _tokentype.TokenType;
	exports.tokTypes = _tokentype.types;

	var _tokencontext = _dereq_("./tokencontext");

	exports.TokContext = _tokencontext.TokContext;
	exports.tokContexts = _tokencontext.types;

	var _identifier = _dereq_("./identifier");

	exports.isIdentifierChar = _identifier.isIdentifierChar;
	exports.isIdentifierStart = _identifier.isIdentifierStart;

	var _tokenize = _dereq_("./tokenize");

	exports.Token = _tokenize.Token;

	var _whitespace = _dereq_("./whitespace");

	exports.isNewLine = _whitespace.isNewLine;
	exports.lineBreak = _whitespace.lineBreak;
	exports.lineBreakG = _whitespace.lineBreakG;
	var version = "2.5.2";

	exports.version = version;
	// The main exported interface (under `self.acorn` when in the
	// browser) is a `parse` function that takes a code string and
	// returns an abstract syntax tree as specified by [Mozilla parser
	// API][api].
	//
	// [api]: https://developer.mozilla.org/en-US/docs/SpiderMonkey/Parser_API

	function parse(input, options) {
	  return new _state.Parser(options, input).parse();
	}

	// This function tries to parse a single expression at a given
	// offset in a string. Useful for parsing mixed-language formats
	// that embed JavaScript expressions.

	function parseExpressionAt(input, pos, options) {
	  var p = new _state.Parser(options, input, pos);
	  p.nextToken();
	  return p.parseExpression();
	}

	// Acorn is organized as a tokenizer and a recursive-descent parser.
	// The `tokenizer` export provides an interface to the tokenizer.

	function tokenizer(input, options) {
	  return new _state.Parser(options, input);
	}

	},{"./expression":1,"./identifier":2,"./location":4,"./locutil":5,"./lval":6,"./node":7,"./options":8,"./parseutil":9,"./state":10,"./statement":11,"./tokencontext":12,"./tokenize":13,"./tokentype":14,"./whitespace":16}],4:[function(_dereq_,module,exports){
	"use strict";

	var _state = _dereq_("./state");

	var _locutil = _dereq_("./locutil");

	var pp = _state.Parser.prototype;

	// This function is used to raise exceptions on parse errors. It
	// takes an offset integer (into the current `input`) to indicate
	// the location of the error, attaches the position to the end
	// of the error message, and then raises a `SyntaxError` with that
	// message.

	pp.raise = function (pos, message) {
	  var loc = _locutil.getLineInfo(this.input, pos);
	  message += " (" + loc.line + ":" + loc.column + ")";
	  var err = new SyntaxError(message);
	  err.pos = pos;err.loc = loc;err.raisedAt = this.pos;
	  throw err;
	};

	pp.curPosition = function () {
	  if (this.options.locations) {
	    return new _locutil.Position(this.curLine, this.pos - this.lineStart);
	  }
	};

	},{"./locutil":5,"./state":10}],5:[function(_dereq_,module,exports){
	"use strict";

	exports.__esModule = true;
	exports.getLineInfo = getLineInfo;

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	var _whitespace = _dereq_("./whitespace");

	// These are used when `options.locations` is on, for the
	// `startLoc` and `endLoc` properties.

	var Position = (function () {
	  function Position(line, col) {
	    _classCallCheck(this, Position);

	    this.line = line;
	    this.column = col;
	  }

	  Position.prototype.offset = function offset(n) {
	    return new Position(this.line, this.column + n);
	  };

	  return Position;
	})();

	exports.Position = Position;

	var SourceLocation = function SourceLocation(p, start, end) {
	  _classCallCheck(this, SourceLocation);

	  this.start = start;
	  this.end = end;
	  if (p.sourceFile !== null) this.source = p.sourceFile;
	}

	// The `getLineInfo` function is mostly useful when the
	// `locations` option is off (for performance reasons) and you
	// want to find the line/column position for a given character
	// offset. `input` should be the code string that the offset refers
	// into.

	;

	exports.SourceLocation = SourceLocation;

	function getLineInfo(input, offset) {
	  for (var line = 1, cur = 0;;) {
	    _whitespace.lineBreakG.lastIndex = cur;
	    var match = _whitespace.lineBreakG.exec(input);
	    if (match && match.index < offset) {
	      ++line;
	      cur = match.index + match[0].length;
	    } else {
	      return new Position(line, offset - cur);
	    }
	  }
	}

	},{"./whitespace":16}],6:[function(_dereq_,module,exports){
	"use strict";

	var _tokentype = _dereq_("./tokentype");

	var _state = _dereq_("./state");

	var _util = _dereq_("./util");

	var pp = _state.Parser.prototype;

	// Convert existing expression atom to assignable pattern
	// if possible.

	pp.toAssignable = function (node, isBinding) {
	  if (this.options.ecmaVersion >= 6 && node) {
	    switch (node.type) {
	      case "Identifier":
	      case "ObjectPattern":
	      case "ArrayPattern":
	      case "AssignmentPattern":
	        break;

	      case "ObjectExpression":
	        node.type = "ObjectPattern";
	        for (var i = 0; i < node.properties.length; i++) {
	          var prop = node.properties[i];
	          if (prop.kind !== "init") this.raise(prop.key.start, "Object pattern can't contain getter or setter");
	          this.toAssignable(prop.value, isBinding);
	        }
	        break;

	      case "ArrayExpression":
	        node.type = "ArrayPattern";
	        this.toAssignableList(node.elements, isBinding);
	        break;

	      case "AssignmentExpression":
	        if (node.operator === "=") {
	          node.type = "AssignmentPattern";
	          delete node.operator;
	        } else {
	          this.raise(node.left.end, "Only '=' operator can be used for specifying default value.");
	        }
	        break;

	      case "ParenthesizedExpression":
	        node.expression = this.toAssignable(node.expression, isBinding);
	        break;

	      case "MemberExpression":
	        if (!isBinding) break;

	      default:
	        this.raise(node.start, "Assigning to rvalue");
	    }
	  }
	  return node;
	};

	// Convert list of expression atoms to binding list.

	pp.toAssignableList = function (exprList, isBinding) {
	  var end = exprList.length;
	  if (end) {
	    var last = exprList[end - 1];
	    if (last && last.type == "RestElement") {
	      --end;
	    } else if (last && last.type == "SpreadElement") {
	      last.type = "RestElement";
	      var arg = last.argument;
	      this.toAssignable(arg, isBinding);
	      if (arg.type !== "Identifier" && arg.type !== "MemberExpression" && arg.type !== "ArrayPattern") this.unexpected(arg.start);
	      --end;
	    }

	    if (isBinding && last.type === "RestElement" && last.argument.type !== "Identifier") this.unexpected(last.argument.start);
	  }
	  for (var i = 0; i < end; i++) {
	    var elt = exprList[i];
	    if (elt) this.toAssignable(elt, isBinding);
	  }
	  return exprList;
	};

	// Parses spread element.

	pp.parseSpread = function (refShorthandDefaultPos) {
	  var node = this.startNode();
	  this.next();
	  node.argument = this.parseMaybeAssign(refShorthandDefaultPos);
	  return this.finishNode(node, "SpreadElement");
	};

	pp.parseRest = function (allowNonIdent) {
	  var node = this.startNode();
	  this.next();

	  // RestElement inside of a function parameter must be an identifier
	  if (allowNonIdent) node.argument = this.type === _tokentype.types.name ? this.parseIdent() : this.unexpected();else node.argument = this.type === _tokentype.types.name || this.type === _tokentype.types.bracketL ? this.parseBindingAtom() : this.unexpected();

	  return this.finishNode(node, "RestElement");
	};

	// Parses lvalue (assignable) atom.

	pp.parseBindingAtom = function () {
	  if (this.options.ecmaVersion < 6) return this.parseIdent();
	  switch (this.type) {
	    case _tokentype.types.name:
	      return this.parseIdent();

	    case _tokentype.types.bracketL:
	      var node = this.startNode();
	      this.next();
	      node.elements = this.parseBindingList(_tokentype.types.bracketR, true, true);
	      return this.finishNode(node, "ArrayPattern");

	    case _tokentype.types.braceL:
	      return this.parseObj(true);

	    default:
	      this.unexpected();
	  }
	};

	pp.parseBindingList = function (close, allowEmpty, allowTrailingComma, allowNonIdent) {
	  var elts = [],
	      first = true;
	  while (!this.eat(close)) {
	    if (first) first = false;else this.expect(_tokentype.types.comma);
	    if (allowEmpty && this.type === _tokentype.types.comma) {
	      elts.push(null);
	    } else if (allowTrailingComma && this.afterTrailingComma(close)) {
	      break;
	    } else if (this.type === _tokentype.types.ellipsis) {
	      var rest = this.parseRest(allowNonIdent);
	      this.parseBindingListItem(rest);
	      elts.push(rest);
	      this.expect(close);
	      break;
	    } else {
	      var elem = this.parseMaybeDefault(this.start, this.startLoc);
	      this.parseBindingListItem(elem);
	      elts.push(elem);
	    }
	  }
	  return elts;
	};

	pp.parseBindingListItem = function (param) {
	  return param;
	};

	// Parses assignment pattern around given atom if possible.

	pp.parseMaybeDefault = function (startPos, startLoc, left) {
	  left = left || this.parseBindingAtom();
	  if (this.options.ecmaVersion < 6 || !this.eat(_tokentype.types.eq)) return left;
	  var node = this.startNodeAt(startPos, startLoc);
	  node.left = left;
	  node.right = this.parseMaybeAssign();
	  return this.finishNode(node, "AssignmentPattern");
	};

	// Verify that a node is an lval  something that can be assigned
	// to.

	pp.checkLVal = function (expr, isBinding, checkClashes) {
	  switch (expr.type) {
	    case "Identifier":
	      if (this.strict && this.reservedWordsStrictBind.test(expr.name)) this.raise(expr.start, (isBinding ? "Binding " : "Assigning to ") + expr.name + " in strict mode");
	      if (checkClashes) {
	        if (_util.has(checkClashes, expr.name)) this.raise(expr.start, "Argument name clash");
	        checkClashes[expr.name] = true;
	      }
	      break;

	    case "MemberExpression":
	      if (isBinding) this.raise(expr.start, (isBinding ? "Binding" : "Assigning to") + " member expression");
	      break;

	    case "ObjectPattern":
	      for (var i = 0; i < expr.properties.length; i++) {
	        this.checkLVal(expr.properties[i].value, isBinding, checkClashes);
	      }break;

	    case "ArrayPattern":
	      for (var i = 0; i < expr.elements.length; i++) {
	        var elem = expr.elements[i];
	        if (elem) this.checkLVal(elem, isBinding, checkClashes);
	      }
	      break;

	    case "AssignmentPattern":
	      this.checkLVal(expr.left, isBinding, checkClashes);
	      break;

	    case "RestElement":
	      this.checkLVal(expr.argument, isBinding, checkClashes);
	      break;

	    case "ParenthesizedExpression":
	      this.checkLVal(expr.expression, isBinding, checkClashes);
	      break;

	    default:
	      this.raise(expr.start, (isBinding ? "Binding" : "Assigning to") + " rvalue");
	  }
	};

	},{"./state":10,"./tokentype":14,"./util":15}],7:[function(_dereq_,module,exports){
	"use strict";

	exports.__esModule = true;

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	var _state = _dereq_("./state");

	var _locutil = _dereq_("./locutil");

	var Node = function Node(parser, pos, loc) {
	  _classCallCheck(this, Node);

	  this.type = "";
	  this.start = pos;
	  this.end = 0;
	  if (parser.options.locations) this.loc = new _locutil.SourceLocation(parser, loc);
	  if (parser.options.directSourceFile) this.sourceFile = parser.options.directSourceFile;
	  if (parser.options.ranges) this.range = [pos, 0];
	}

	// Start an AST node, attaching a start offset.

	;

	exports.Node = Node;
	var pp = _state.Parser.prototype;

	pp.startNode = function () {
	  return new Node(this, this.start, this.startLoc);
	};

	pp.startNodeAt = function (pos, loc) {
	  return new Node(this, pos, loc);
	};

	// Finish an AST node, adding `type` and `end` properties.

	function finishNodeAt(node, type, pos, loc) {
	  node.type = type;
	  node.end = pos;
	  if (this.options.locations) node.loc.end = loc;
	  if (this.options.ranges) node.range[1] = pos;
	  return node;
	}

	pp.finishNode = function (node, type) {
	  return finishNodeAt.call(this, node, type, this.lastTokEnd, this.lastTokEndLoc);
	};

	// Finish node at given position

	pp.finishNodeAt = function (node, type, pos, loc) {
	  return finishNodeAt.call(this, node, type, pos, loc);
	};

	},{"./locutil":5,"./state":10}],8:[function(_dereq_,module,exports){
	"use strict";

	exports.__esModule = true;
	exports.getOptions = getOptions;

	var _util = _dereq_("./util");

	var _locutil = _dereq_("./locutil");

	// A second optional argument can be given to further configure
	// the parser process. These options are recognized:

	var defaultOptions = {
	  // `ecmaVersion` indicates the ECMAScript version to parse. Must
	  // be either 3, or 5, or 6. This influences support for strict
	  // mode, the set of reserved words, support for getters and
	  // setters and other features.
	  ecmaVersion: 5,
	  // Source type ("script" or "module") for different semantics
	  sourceType: "script",
	  // `onInsertedSemicolon` can be a callback that will be called
	  // when a semicolon is automatically inserted. It will be passed
	  // th position of the comma as an offset, and if `locations` is
	  // enabled, it is given the location as a `{line, column}` object
	  // as second argument.
	  onInsertedSemicolon: null,
	  // `onTrailingComma` is similar to `onInsertedSemicolon`, but for
	  // trailing commas.
	  onTrailingComma: null,
	  // By default, reserved words are only enforced if ecmaVersion >= 5.
	  // Set `allowReserved` to a boolean value to explicitly turn this on
	  // an off. When this option has the value "never", reserved words
	  // and keywords can also not be used as property names.
	  allowReserved: null,
	  // When enabled, a return at the top level is not considered an
	  // error.
	  allowReturnOutsideFunction: false,
	  // When enabled, import/export statements are not constrained to
	  // appearing at the top of the program.
	  allowImportExportEverywhere: false,
	  // When enabled, hashbang directive in the beginning of file
	  // is allowed and treated as a line comment.
	  allowHashBang: false,
	  // When `locations` is on, `loc` properties holding objects with
	  // `start` and `end` properties in `{line, column}` form (with
	  // line being 1-based and column 0-based) will be attached to the
	  // nodes.
	  locations: false,
	  // A function can be passed as `onToken` option, which will
	  // cause Acorn to call that function with object in the same
	  // format as tokens returned from `tokenizer().getToken()`. Note
	  // that you are not allowed to call the parser from the
	  // callbackthat will corrupt its internal state.
	  onToken: null,
	  // A function can be passed as `onComment` option, which will
	  // cause Acorn to call that function with `(block, text, start,
	  // end)` parameters whenever a comment is skipped. `block` is a
	  // boolean indicating whether this is a block (`/* */`) comment,
	  // `text` is the content of the comment, and `start` and `end` are
	  // character offsets that denote the start and end of the comment.
	  // When the `locations` option is on, two more parameters are
	  // passed, the full `{line, column}` locations of the start and
	  // end of the comments. Note that you are not allowed to call the
	  // parser from the callbackthat will corrupt its internal state.
	  onComment: null,
	  // Nodes have their start and end characters offsets recorded in
	  // `start` and `end` properties (directly on the node, rather than
	  // the `loc` object, which holds line/column data. To also add a
	  // [semi-standardized][range] `range` property holding a `[start,
	  // end]` array with the same numbers, set the `ranges` option to
	  // `true`.
	  //
	  // [range]: https://bugzilla.mozilla.org/show_bug.cgi?id=745678
	  ranges: false,
	  // It is possible to parse multiple files into a single AST by
	  // passing the tree produced by parsing the first file as
	  // `program` option in subsequent parses. This will add the
	  // toplevel forms of the parsed file to the `Program` (top) node
	  // of an existing parse tree.
	  program: null,
	  // When `locations` is on, you can pass this to record the source
	  // file in every node's `loc` object.
	  sourceFile: null,
	  // This value, if given, is stored in every node, whether
	  // `locations` is on or off.
	  directSourceFile: null,
	  // When enabled, parenthesized expressions are represented by
	  // (non-standard) ParenthesizedExpression nodes
	  preserveParens: false,
	  plugins: {}
	};

	exports.defaultOptions = defaultOptions;
	// Interpret and default an options object

	function getOptions(opts) {
	  var options = {};
	  for (var opt in defaultOptions) {
	    options[opt] = opts && _util.has(opts, opt) ? opts[opt] : defaultOptions[opt];
	  }if (options.allowReserved == null) options.allowReserved = options.ecmaVersion >= 5;

	  if (_util.isArray(options.onToken)) {
	    (function () {
	      var tokens = options.onToken;
	      options.onToken = function (token) {
	        return tokens.push(token);
	      };
	    })();
	  }
	  if (_util.isArray(options.onComment)) options.onComment = pushComment(options, options.onComment);

	  return options;
	}

	function pushComment(options, array) {
	  return function (block, text, start, end, startLoc, endLoc) {
	    var comment = {
	      type: block ? 'Block' : 'Line',
	      value: text,
	      start: start,
	      end: end
	    };
	    if (options.locations) comment.loc = new _locutil.SourceLocation(this, startLoc, endLoc);
	    if (options.ranges) comment.range = [start, end];
	    array.push(comment);
	  };
	}

	},{"./locutil":5,"./util":15}],9:[function(_dereq_,module,exports){
	"use strict";

	var _tokentype = _dereq_("./tokentype");

	var _state = _dereq_("./state");

	var _whitespace = _dereq_("./whitespace");

	var pp = _state.Parser.prototype;

	// ## Parser utilities

	// Test whether a statement node is the string literal `"use strict"`.

	pp.isUseStrict = function (stmt) {
	  return this.options.ecmaVersion >= 5 && stmt.type === "ExpressionStatement" && stmt.expression.type === "Literal" && stmt.expression.raw.slice(1, -1) === "use strict";
	};

	// Predicate that tests whether the next token is of the given
	// type, and if yes, consumes it as a side effect.

	pp.eat = function (type) {
	  if (this.type === type) {
	    this.next();
	    return true;
	  } else {
	    return false;
	  }
	};

	// Tests whether parsed token is a contextual keyword.

	pp.isContextual = function (name) {
	  return this.type === _tokentype.types.name && this.value === name;
	};

	// Consumes contextual keyword if possible.

	pp.eatContextual = function (name) {
	  return this.value === name && this.eat(_tokentype.types.name);
	};

	// Asserts that following token is given contextual keyword.

	pp.expectContextual = function (name) {
	  if (!this.eatContextual(name)) this.unexpected();
	};

	// Test whether a semicolon can be inserted at the current position.

	pp.canInsertSemicolon = function () {
	  return this.type === _tokentype.types.eof || this.type === _tokentype.types.braceR || _whitespace.lineBreak.test(this.input.slice(this.lastTokEnd, this.start));
	};

	pp.insertSemicolon = function () {
	  if (this.canInsertSemicolon()) {
	    if (this.options.onInsertedSemicolon) this.options.onInsertedSemicolon(this.lastTokEnd, this.lastTokEndLoc);
	    return true;
	  }
	};

	// Consume a semicolon, or, failing that, see if we are allowed to
	// pretend that there is a semicolon at this position.

	pp.semicolon = function () {
	  if (!this.eat(_tokentype.types.semi) && !this.insertSemicolon()) this.unexpected();
	};

	pp.afterTrailingComma = function (tokType) {
	  if (this.type == tokType) {
	    if (this.options.onTrailingComma) this.options.onTrailingComma(this.lastTokStart, this.lastTokStartLoc);
	    this.next();
	    return true;
	  }
	};

	// Expect a token of a given type. If found, consume it, otherwise,
	// raise an unexpected token error.

	pp.expect = function (type) {
	  this.eat(type) || this.unexpected();
	};

	// Raise an unexpected token error.

	pp.unexpected = function (pos) {
	  this.raise(pos != null ? pos : this.start, "Unexpected token");
	};

	},{"./state":10,"./tokentype":14,"./whitespace":16}],10:[function(_dereq_,module,exports){
	"use strict";

	exports.__esModule = true;

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	var _identifier = _dereq_("./identifier");

	var _tokentype = _dereq_("./tokentype");

	var _whitespace = _dereq_("./whitespace");

	var _options = _dereq_("./options");

	// Registered plugins
	var plugins = {};

	exports.plugins = plugins;
	function keywordRegexp(words) {
	  return new RegExp("^(" + words.replace(/ /g, "|") + ")$");
	}

	var Parser = (function () {
	  function Parser(options, input, startPos) {
	    _classCallCheck(this, Parser);

	    this.options = _options.getOptions(options);
	    this.sourceFile = this.options.sourceFile;
	    this.keywords = keywordRegexp(_identifier.keywords[this.options.ecmaVersion >= 6 ? 6 : 5]);
	    var reserved = this.options.allowReserved ? "" : _identifier.reservedWords[this.options.ecmaVersion] + (options.sourceType == "module" ? " await" : "");
	    this.reservedWords = keywordRegexp(reserved);
	    var reservedStrict = (reserved ? reserved + " " : "") + _identifier.reservedWords.strict;
	    this.reservedWordsStrict = keywordRegexp(reservedStrict);
	    this.reservedWordsStrictBind = keywordRegexp(reservedStrict + " " + _identifier.reservedWords.strictBind);
	    this.input = String(input);

	    // Used to signal to callers of `readWord1` whether the word
	    // contained any escape sequences. This is needed because words with
	    // escape sequences must not be interpreted as keywords.
	    this.containsEsc = false;

	    // Load plugins
	    this.loadPlugins(this.options.plugins);

	    // Set up token state

	    // The current position of the tokenizer in the input.
	    if (startPos) {
	      this.pos = startPos;
	      this.lineStart = Math.max(0, this.input.lastIndexOf("\n", startPos));
	      this.curLine = this.input.slice(0, this.lineStart).split(_whitespace.lineBreak).length;
	    } else {
	      this.pos = this.lineStart = 0;
	      this.curLine = 1;
	    }

	    // Properties of the current token:
	    // Its type
	    this.type = _tokentype.types.eof;
	    // For tokens that include more information than their type, the value
	    this.value = null;
	    // Its start and end offset
	    this.start = this.end = this.pos;
	    // And, if locations are used, the {line, column} object
	    // corresponding to those offsets
	    this.startLoc = this.endLoc = this.curPosition();

	    // Position information for the previous token
	    this.lastTokEndLoc = this.lastTokStartLoc = null;
	    this.lastTokStart = this.lastTokEnd = this.pos;

	    // The context stack is used to superficially track syntactic
	    // context to predict whether a regular expression is allowed in a
	    // given position.
	    this.context = this.initialContext();
	    this.exprAllowed = true;

	    // Figure out if it's a module code.
	    this.strict = this.inModule = this.options.sourceType === "module";

	    // Used to signify the start of a potential arrow function
	    this.potentialArrowAt = -1;

	    // Flags to track whether we are in a function, a generator.
	    this.inFunction = this.inGenerator = false;
	    // Labels in scope.
	    this.labels = [];

	    // If enabled, skip leading hashbang line.
	    if (this.pos === 0 && this.options.allowHashBang && this.input.slice(0, 2) === '#!') this.skipLineComment(2);
	  }

	  // DEPRECATED Kept for backwards compatibility until 3.0 in case a plugin uses them

	  Parser.prototype.isKeyword = function isKeyword(word) {
	    return this.keywords.test(word);
	  };

	  Parser.prototype.isReservedWord = function isReservedWord(word) {
	    return this.reservedWords.test(word);
	  };

	  Parser.prototype.extend = function extend(name, f) {
	    this[name] = f(this[name]);
	  };

	  Parser.prototype.loadPlugins = function loadPlugins(pluginConfigs) {
	    for (var _name in pluginConfigs) {
	      var plugin = plugins[_name];
	      if (!plugin) throw new Error("Plugin '" + _name + "' not found");
	      plugin(this, pluginConfigs[_name]);
	    }
	  };

	  Parser.prototype.parse = function parse() {
	    var node = this.options.program || this.startNode();
	    this.nextToken();
	    return this.parseTopLevel(node);
	  };

	  return Parser;
	})();

	exports.Parser = Parser;

	},{"./identifier":2,"./options":8,"./tokentype":14,"./whitespace":16}],11:[function(_dereq_,module,exports){
	"use strict";

	var _tokentype = _dereq_("./tokentype");

	var _state = _dereq_("./state");

	var _whitespace = _dereq_("./whitespace");

	var pp = _state.Parser.prototype;

	// ### Statement parsing

	// Parse a program. Initializes the parser, reads any number of
	// statements, and wraps them in a Program node.  Optionally takes a
	// `program` argument.  If present, the statements will be appended
	// to its body instead of creating a new node.

	pp.parseTopLevel = function (node) {
	  var first = true;
	  if (!node.body) node.body = [];
	  while (this.type !== _tokentype.types.eof) {
	    var stmt = this.parseStatement(true, true);
	    node.body.push(stmt);
	    if (first) {
	      if (this.isUseStrict(stmt)) this.setStrict(true);
	      first = false;
	    }
	  }
	  this.next();
	  if (this.options.ecmaVersion >= 6) {
	    node.sourceType = this.options.sourceType;
	  }
	  return this.finishNode(node, "Program");
	};

	var loopLabel = { kind: "loop" },
	    switchLabel = { kind: "switch" };

	// Parse a single statement.
	//
	// If expecting a statement and finding a slash operator, parse a
	// regular expression literal. This is to handle cases like
	// `if (foo) /blah/.exec(foo)`, where looking at the previous token
	// does not help.

	pp.parseStatement = function (declaration, topLevel) {
	  var starttype = this.type,
	      node = this.startNode();

	  // Most types of statements are recognized by the keyword they
	  // start with. Many are trivial to parse, some require a bit of
	  // complexity.

	  switch (starttype) {
	    case _tokentype.types._break:case _tokentype.types._continue:
	      return this.parseBreakContinueStatement(node, starttype.keyword);
	    case _tokentype.types._debugger:
	      return this.parseDebuggerStatement(node);
	    case _tokentype.types._do:
	      return this.parseDoStatement(node);
	    case _tokentype.types._for:
	      return this.parseForStatement(node);
	    case _tokentype.types._function:
	      if (!declaration && this.options.ecmaVersion >= 6) this.unexpected();
	      return this.parseFunctionStatement(node);
	    case _tokentype.types._class:
	      if (!declaration) this.unexpected();
	      return this.parseClass(node, true);
	    case _tokentype.types._if:
	      return this.parseIfStatement(node);
	    case _tokentype.types._return:
	      return this.parseReturnStatement(node);
	    case _tokentype.types._switch:
	      return this.parseSwitchStatement(node);
	    case _tokentype.types._throw:
	      return this.parseThrowStatement(node);
	    case _tokentype.types._try:
	      return this.parseTryStatement(node);
	    case _tokentype.types._let:case _tokentype.types._const:
	      if (!declaration) this.unexpected(); // NOTE: falls through to _var
	    case _tokentype.types._var:
	      return this.parseVarStatement(node, starttype);
	    case _tokentype.types._while:
	      return this.parseWhileStatement(node);
	    case _tokentype.types._with:
	      return this.parseWithStatement(node);
	    case _tokentype.types.braceL:
	      return this.parseBlock();
	    case _tokentype.types.semi:
	      return this.parseEmptyStatement(node);
	    case _tokentype.types._export:
	    case _tokentype.types._import:
	      if (!this.options.allowImportExportEverywhere) {
	        if (!topLevel) this.raise(this.start, "'import' and 'export' may only appear at the top level");
	        if (!this.inModule) this.raise(this.start, "'import' and 'export' may appear only with 'sourceType: module'");
	      }
	      return starttype === _tokentype.types._import ? this.parseImport(node) : this.parseExport(node);

	    // If the statement does not start with a statement keyword or a
	    // brace, it's an ExpressionStatement or LabeledStatement. We
	    // simply start parsing an expression, and afterwards, if the
	    // next token is a colon and the expression was a simple
	    // Identifier node, we switch to interpreting it as a label.
	    default:
	      var maybeName = this.value,
	          expr = this.parseExpression();
	      if (starttype === _tokentype.types.name && expr.type === "Identifier" && this.eat(_tokentype.types.colon)) return this.parseLabeledStatement(node, maybeName, expr);else return this.parseExpressionStatement(node, expr);
	  }
	};

	pp.parseBreakContinueStatement = function (node, keyword) {
	  var isBreak = keyword == "break";
	  this.next();
	  if (this.eat(_tokentype.types.semi) || this.insertSemicolon()) node.label = null;else if (this.type !== _tokentype.types.name) this.unexpected();else {
	    node.label = this.parseIdent();
	    this.semicolon();
	  }

	  // Verify that there is an actual destination to break or
	  // continue to.
	  for (var i = 0; i < this.labels.length; ++i) {
	    var lab = this.labels[i];
	    if (node.label == null || lab.name === node.label.name) {
	      if (lab.kind != null && (isBreak || lab.kind === "loop")) break;
	      if (node.label && isBreak) break;
	    }
	  }
	  if (i === this.labels.length) this.raise(node.start, "Unsyntactic " + keyword);
	  return this.finishNode(node, isBreak ? "BreakStatement" : "ContinueStatement");
	};

	pp.parseDebuggerStatement = function (node) {
	  this.next();
	  this.semicolon();
	  return this.finishNode(node, "DebuggerStatement");
	};

	pp.parseDoStatement = function (node) {
	  this.next();
	  this.labels.push(loopLabel);
	  node.body = this.parseStatement(false);
	  this.labels.pop();
	  this.expect(_tokentype.types._while);
	  node.test = this.parseParenExpression();
	  if (this.options.ecmaVersion >= 6) this.eat(_tokentype.types.semi);else this.semicolon();
	  return this.finishNode(node, "DoWhileStatement");
	};

	// Disambiguating between a `for` and a `for`/`in` or `for`/`of`
	// loop is non-trivial. Basically, we have to parse the init `var`
	// statement or expression, disallowing the `in` operator (see
	// the second parameter to `parseExpression`), and then check
	// whether the next token is `in` or `of`. When there is no init
	// part (semicolon immediately after the opening parenthesis), it
	// is a regular `for` loop.

	pp.parseForStatement = function (node) {
	  this.next();
	  this.labels.push(loopLabel);
	  this.expect(_tokentype.types.parenL);
	  if (this.type === _tokentype.types.semi) return this.parseFor(node, null);
	  if (this.type === _tokentype.types._var || this.type === _tokentype.types._let || this.type === _tokentype.types._const) {
	    var _init = this.startNode(),
	        varKind = this.type;
	    this.next();
	    this.parseVar(_init, true, varKind);
	    this.finishNode(_init, "VariableDeclaration");
	    if ((this.type === _tokentype.types._in || this.options.ecmaVersion >= 6 && this.isContextual("of")) && _init.declarations.length === 1 && !(varKind !== _tokentype.types._var && _init.declarations[0].init)) return this.parseForIn(node, _init);
	    return this.parseFor(node, _init);
	  }
	  var refShorthandDefaultPos = { start: 0 };
	  var init = this.parseExpression(true, refShorthandDefaultPos);
	  if (this.type === _tokentype.types._in || this.options.ecmaVersion >= 6 && this.isContextual("of")) {
	    this.toAssignable(init);
	    this.checkLVal(init);
	    return this.parseForIn(node, init);
	  } else if (refShorthandDefaultPos.start) {
	    this.unexpected(refShorthandDefaultPos.start);
	  }
	  return this.parseFor(node, init);
	};

	pp.parseFunctionStatement = function (node) {
	  this.next();
	  return this.parseFunction(node, true);
	};

	pp.parseIfStatement = function (node) {
	  this.next();
	  node.test = this.parseParenExpression();
	  node.consequent = this.parseStatement(false);
	  node.alternate = this.eat(_tokentype.types._else) ? this.parseStatement(false) : null;
	  return this.finishNode(node, "IfStatement");
	};

	pp.parseReturnStatement = function (node) {
	  if (!this.inFunction && !this.options.allowReturnOutsideFunction) this.raise(this.start, "'return' outside of function");
	  this.next();

	  // In `return` (and `break`/`continue`), the keywords with
	  // optional arguments, we eagerly look for a semicolon or the
	  // possibility to insert one.

	  if (this.eat(_tokentype.types.semi) || this.insertSemicolon()) node.argument = null;else {
	    node.argument = this.parseExpression();this.semicolon();
	  }
	  return this.finishNode(node, "ReturnStatement");
	};

	pp.parseSwitchStatement = function (node) {
	  this.next();
	  node.discriminant = this.parseParenExpression();
	  node.cases = [];
	  this.expect(_tokentype.types.braceL);
	  this.labels.push(switchLabel);

	  // Statements under must be grouped (by label) in SwitchCase
	  // nodes. `cur` is used to keep the node that we are currently
	  // adding statements to.

	  for (var cur, sawDefault = false; this.type != _tokentype.types.braceR;) {
	    if (this.type === _tokentype.types._case || this.type === _tokentype.types._default) {
	      var isCase = this.type === _tokentype.types._case;
	      if (cur) this.finishNode(cur, "SwitchCase");
	      node.cases.push(cur = this.startNode());
	      cur.consequent = [];
	      this.next();
	      if (isCase) {
	        cur.test = this.parseExpression();
	      } else {
	        if (sawDefault) this.raise(this.lastTokStart, "Multiple default clauses");
	        sawDefault = true;
	        cur.test = null;
	      }
	      this.expect(_tokentype.types.colon);
	    } else {
	      if (!cur) this.unexpected();
	      cur.consequent.push(this.parseStatement(true));
	    }
	  }
	  if (cur) this.finishNode(cur, "SwitchCase");
	  this.next(); // Closing brace
	  this.labels.pop();
	  return this.finishNode(node, "SwitchStatement");
	};

	pp.parseThrowStatement = function (node) {
	  this.next();
	  if (_whitespace.lineBreak.test(this.input.slice(this.lastTokEnd, this.start))) this.raise(this.lastTokEnd, "Illegal newline after throw");
	  node.argument = this.parseExpression();
	  this.semicolon();
	  return this.finishNode(node, "ThrowStatement");
	};

	// Reused empty array added for node fields that are always empty.

	var empty = [];

	pp.parseTryStatement = function (node) {
	  this.next();
	  node.block = this.parseBlock();
	  node.handler = null;
	  if (this.type === _tokentype.types._catch) {
	    var clause = this.startNode();
	    this.next();
	    this.expect(_tokentype.types.parenL);
	    clause.param = this.parseBindingAtom();
	    this.checkLVal(clause.param, true);
	    this.expect(_tokentype.types.parenR);
	    clause.body = this.parseBlock();
	    node.handler = this.finishNode(clause, "CatchClause");
	  }
	  node.finalizer = this.eat(_tokentype.types._finally) ? this.parseBlock() : null;
	  if (!node.handler && !node.finalizer) this.raise(node.start, "Missing catch or finally clause");
	  return this.finishNode(node, "TryStatement");
	};

	pp.parseVarStatement = function (node, kind) {
	  this.next();
	  this.parseVar(node, false, kind);
	  this.semicolon();
	  return this.finishNode(node, "VariableDeclaration");
	};

	pp.parseWhileStatement = function (node) {
	  this.next();
	  node.test = this.parseParenExpression();
	  this.labels.push(loopLabel);
	  node.body = this.parseStatement(false);
	  this.labels.pop();
	  return this.finishNode(node, "WhileStatement");
	};

	pp.parseWithStatement = function (node) {
	  if (this.strict) this.raise(this.start, "'with' in strict mode");
	  this.next();
	  node.object = this.parseParenExpression();
	  node.body = this.parseStatement(false);
	  return this.finishNode(node, "WithStatement");
	};

	pp.parseEmptyStatement = function (node) {
	  this.next();
	  return this.finishNode(node, "EmptyStatement");
	};

	pp.parseLabeledStatement = function (node, maybeName, expr) {
	  for (var i = 0; i < this.labels.length; ++i) {
	    if (this.labels[i].name === maybeName) this.raise(expr.start, "Label '" + maybeName + "' is already declared");
	  }var kind = this.type.isLoop ? "loop" : this.type === _tokentype.types._switch ? "switch" : null;
	  for (var i = this.labels.length - 1; i >= 0; i--) {
	    var label = this.labels[i];
	    if (label.statementStart == node.start) {
	      label.statementStart = this.start;
	      label.kind = kind;
	    } else break;
	  }
	  this.labels.push({ name: maybeName, kind: kind, statementStart: this.start });
	  node.body = this.parseStatement(true);
	  this.labels.pop();
	  node.label = expr;
	  return this.finishNode(node, "LabeledStatement");
	};

	pp.parseExpressionStatement = function (node, expr) {
	  node.expression = expr;
	  this.semicolon();
	  return this.finishNode(node, "ExpressionStatement");
	};

	// Parse a semicolon-enclosed block of statements, handling `"use
	// strict"` declarations when `allowStrict` is true (used for
	// function bodies).

	pp.parseBlock = function (allowStrict) {
	  var node = this.startNode(),
	      first = true,
	      oldStrict = undefined;
	  node.body = [];
	  this.expect(_tokentype.types.braceL);
	  while (!this.eat(_tokentype.types.braceR)) {
	    var stmt = this.parseStatement(true);
	    node.body.push(stmt);
	    if (first && allowStrict && this.isUseStrict(stmt)) {
	      oldStrict = this.strict;
	      this.setStrict(this.strict = true);
	    }
	    first = false;
	  }
	  if (oldStrict === false) this.setStrict(false);
	  return this.finishNode(node, "BlockStatement");
	};

	// Parse a regular `for` loop. The disambiguation code in
	// `parseStatement` will already have parsed the init statement or
	// expression.

	pp.parseFor = function (node, init) {
	  node.init = init;
	  this.expect(_tokentype.types.semi);
	  node.test = this.type === _tokentype.types.semi ? null : this.parseExpression();
	  this.expect(_tokentype.types.semi);
	  node.update = this.type === _tokentype.types.parenR ? null : this.parseExpression();
	  this.expect(_tokentype.types.parenR);
	  node.body = this.parseStatement(false);
	  this.labels.pop();
	  return this.finishNode(node, "ForStatement");
	};

	// Parse a `for`/`in` and `for`/`of` loop, which are almost
	// same from parser's perspective.

	pp.parseForIn = function (node, init) {
	  var type = this.type === _tokentype.types._in ? "ForInStatement" : "ForOfStatement";
	  this.next();
	  node.left = init;
	  node.right = this.parseExpression();
	  this.expect(_tokentype.types.parenR);
	  node.body = this.parseStatement(false);
	  this.labels.pop();
	  return this.finishNode(node, type);
	};

	// Parse a list of variable declarations.

	pp.parseVar = function (node, isFor, kind) {
	  node.declarations = [];
	  node.kind = kind.keyword;
	  for (;;) {
	    var decl = this.startNode();
	    this.parseVarId(decl);
	    if (this.eat(_tokentype.types.eq)) {
	      decl.init = this.parseMaybeAssign(isFor);
	    } else if (kind === _tokentype.types._const && !(this.type === _tokentype.types._in || this.options.ecmaVersion >= 6 && this.isContextual("of"))) {
	      this.unexpected();
	    } else if (decl.id.type != "Identifier" && !(isFor && (this.type === _tokentype.types._in || this.isContextual("of")))) {
	      this.raise(this.lastTokEnd, "Complex binding patterns require an initialization value");
	    } else {
	      decl.init = null;
	    }
	    node.declarations.push(this.finishNode(decl, "VariableDeclarator"));
	    if (!this.eat(_tokentype.types.comma)) break;
	  }
	  return node;
	};

	pp.parseVarId = function (decl) {
	  decl.id = this.parseBindingAtom();
	  this.checkLVal(decl.id, true);
	};

	// Parse a function declaration or literal (depending on the
	// `isStatement` parameter).

	pp.parseFunction = function (node, isStatement, allowExpressionBody) {
	  this.initFunction(node);
	  if (this.options.ecmaVersion >= 6) node.generator = this.eat(_tokentype.types.star);
	  if (isStatement || this.type === _tokentype.types.name) node.id = this.parseIdent();
	  this.parseFunctionParams(node);
	  this.parseFunctionBody(node, allowExpressionBody);
	  return this.finishNode(node, isStatement ? "FunctionDeclaration" : "FunctionExpression");
	};

	pp.parseFunctionParams = function (node) {
	  this.expect(_tokentype.types.parenL);
	  node.params = this.parseBindingList(_tokentype.types.parenR, false, false, true);
	};

	// Parse a class declaration or literal (depending on the
	// `isStatement` parameter).

	pp.parseClass = function (node, isStatement) {
	  this.next();
	  this.parseClassId(node, isStatement);
	  this.parseClassSuper(node);
	  var classBody = this.startNode();
	  var hadConstructor = false;
	  classBody.body = [];
	  this.expect(_tokentype.types.braceL);
	  while (!this.eat(_tokentype.types.braceR)) {
	    if (this.eat(_tokentype.types.semi)) continue;
	    var method = this.startNode();
	    var isGenerator = this.eat(_tokentype.types.star);
	    var isMaybeStatic = this.type === _tokentype.types.name && this.value === "static";
	    this.parsePropertyName(method);
	    method["static"] = isMaybeStatic && this.type !== _tokentype.types.parenL;
	    if (method["static"]) {
	      if (isGenerator) this.unexpected();
	      isGenerator = this.eat(_tokentype.types.star);
	      this.parsePropertyName(method);
	    }
	    method.kind = "method";
	    var isGetSet = false;
	    if (!method.computed) {
	      var key = method.key;

	      if (!isGenerator && key.type === "Identifier" && this.type !== _tokentype.types.parenL && (key.name === "get" || key.name === "set")) {
	        isGetSet = true;
	        method.kind = key.name;
	        key = this.parsePropertyName(method);
	      }
	      if (!method["static"] && (key.type === "Identifier" && key.name === "constructor" || key.type === "Literal" && key.value === "constructor")) {
	        if (hadConstructor) this.raise(key.start, "Duplicate constructor in the same class");
	        if (isGetSet) this.raise(key.start, "Constructor can't have get/set modifier");
	        if (isGenerator) this.raise(key.start, "Constructor can't be a generator");
	        method.kind = "constructor";
	        hadConstructor = true;
	      }
	    }
	    this.parseClassMethod(classBody, method, isGenerator);
	    if (isGetSet) {
	      var paramCount = method.kind === "get" ? 0 : 1;
	      if (method.value.params.length !== paramCount) {
	        var start = method.value.start;
	        if (method.kind === "get") this.raise(start, "getter should have no params");else this.raise(start, "setter should have exactly one param");
	      }
	    }
	  }
	  node.body = this.finishNode(classBody, "ClassBody");
	  return this.finishNode(node, isStatement ? "ClassDeclaration" : "ClassExpression");
	};

	pp.parseClassMethod = function (classBody, method, isGenerator) {
	  method.value = this.parseMethod(isGenerator);
	  classBody.body.push(this.finishNode(method, "MethodDefinition"));
	};

	pp.parseClassId = function (node, isStatement) {
	  node.id = this.type === _tokentype.types.name ? this.parseIdent() : isStatement ? this.unexpected() : null;
	};

	pp.parseClassSuper = function (node) {
	  node.superClass = this.eat(_tokentype.types._extends) ? this.parseExprSubscripts() : null;
	};

	// Parses module export declaration.

	pp.parseExport = function (node) {
	  this.next();
	  // export * from '...'
	  if (this.eat(_tokentype.types.star)) {
	    this.expectContextual("from");
	    node.source = this.type === _tokentype.types.string ? this.parseExprAtom() : this.unexpected();
	    this.semicolon();
	    return this.finishNode(node, "ExportAllDeclaration");
	  }
	  if (this.eat(_tokentype.types._default)) {
	    // export default ...
	    var expr = this.parseMaybeAssign();
	    var needsSemi = true;
	    if (expr.type == "FunctionExpression" || expr.type == "ClassExpression") {
	      needsSemi = false;
	      if (expr.id) {
	        expr.type = expr.type == "FunctionExpression" ? "FunctionDeclaration" : "ClassDeclaration";
	      }
	    }
	    node.declaration = expr;
	    if (needsSemi) this.semicolon();
	    return this.finishNode(node, "ExportDefaultDeclaration");
	  }
	  // export var|const|let|function|class ...
	  if (this.shouldParseExportStatement()) {
	    node.declaration = this.parseStatement(true);
	    node.specifiers = [];
	    node.source = null;
	  } else {
	    // export { x, y as z } [from '...']
	    node.declaration = null;
	    node.specifiers = this.parseExportSpecifiers();
	    if (this.eatContextual("from")) {
	      node.source = this.type === _tokentype.types.string ? this.parseExprAtom() : this.unexpected();
	    } else {
	      // check for keywords used as local names
	      for (var i = 0; i < node.specifiers.length; i++) {
	        if (this.keywords.test(node.specifiers[i].local.name) || this.reservedWords.test(node.specifiers[i].local.name)) {
	          this.unexpected(node.specifiers[i].local.start);
	        }
	      }

	      node.source = null;
	    }
	    this.semicolon();
	  }
	  return this.finishNode(node, "ExportNamedDeclaration");
	};

	pp.shouldParseExportStatement = function () {
	  return this.type.keyword;
	};

	// Parses a comma-separated list of module exports.

	pp.parseExportSpecifiers = function () {
	  var nodes = [],
	      first = true;
	  // export { x, y as z } [from '...']
	  this.expect(_tokentype.types.braceL);
	  while (!this.eat(_tokentype.types.braceR)) {
	    if (!first) {
	      this.expect(_tokentype.types.comma);
	      if (this.afterTrailingComma(_tokentype.types.braceR)) break;
	    } else first = false;

	    var node = this.startNode();
	    node.local = this.parseIdent(this.type === _tokentype.types._default);
	    node.exported = this.eatContextual("as") ? this.parseIdent(true) : node.local;
	    nodes.push(this.finishNode(node, "ExportSpecifier"));
	  }
	  return nodes;
	};

	// Parses import declaration.

	pp.parseImport = function (node) {
	  this.next();
	  // import '...'
	  if (this.type === _tokentype.types.string) {
	    node.specifiers = empty;
	    node.source = this.parseExprAtom();
	  } else {
	    node.specifiers = this.parseImportSpecifiers();
	    this.expectContextual("from");
	    node.source = this.type === _tokentype.types.string ? this.parseExprAtom() : this.unexpected();
	  }
	  this.semicolon();
	  return this.finishNode(node, "ImportDeclaration");
	};

	// Parses a comma-separated list of module imports.

	pp.parseImportSpecifiers = function () {
	  var nodes = [],
	      first = true;
	  if (this.type === _tokentype.types.name) {
	    // import defaultObj, { x, y as z } from '...'
	    var node = this.startNode();
	    node.local = this.parseIdent();
	    this.checkLVal(node.local, true);
	    nodes.push(this.finishNode(node, "ImportDefaultSpecifier"));
	    if (!this.eat(_tokentype.types.comma)) return nodes;
	  }
	  if (this.type === _tokentype.types.star) {
	    var node = this.startNode();
	    this.next();
	    this.expectContextual("as");
	    node.local = this.parseIdent();
	    this.checkLVal(node.local, true);
	    nodes.push(this.finishNode(node, "ImportNamespaceSpecifier"));
	    return nodes;
	  }
	  this.expect(_tokentype.types.braceL);
	  while (!this.eat(_tokentype.types.braceR)) {
	    if (!first) {
	      this.expect(_tokentype.types.comma);
	      if (this.afterTrailingComma(_tokentype.types.braceR)) break;
	    } else first = false;

	    var node = this.startNode();
	    node.imported = this.parseIdent(true);
	    node.local = this.eatContextual("as") ? this.parseIdent() : node.imported;
	    this.checkLVal(node.local, true);
	    nodes.push(this.finishNode(node, "ImportSpecifier"));
	  }
	  return nodes;
	};

	},{"./state":10,"./tokentype":14,"./whitespace":16}],12:[function(_dereq_,module,exports){
	// The algorithm used to determine whether a regexp can appear at a
	// given point in the program is loosely based on sweet.js' approach.
	// See https://github.com/mozilla/sweet.js/wiki/design

	"use strict";

	exports.__esModule = true;

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	var _state = _dereq_("./state");

	var _tokentype = _dereq_("./tokentype");

	var _whitespace = _dereq_("./whitespace");

	var TokContext = function TokContext(token, isExpr, preserveSpace, override) {
	  _classCallCheck(this, TokContext);

	  this.token = token;
	  this.isExpr = !!isExpr;
	  this.preserveSpace = !!preserveSpace;
	  this.override = override;
	};

	exports.TokContext = TokContext;
	var types = {
	  b_stat: new TokContext("{", false),
	  b_expr: new TokContext("{", true),
	  b_tmpl: new TokContext("${", true),
	  p_stat: new TokContext("(", false),
	  p_expr: new TokContext("(", true),
	  q_tmpl: new TokContext("`", true, true, function (p) {
	    return p.readTmplToken();
	  }),
	  f_expr: new TokContext("function", true)
	};

	exports.types = types;
	var pp = _state.Parser.prototype;

	pp.initialContext = function () {
	  return [types.b_stat];
	};

	pp.braceIsBlock = function (prevType) {
	  if (prevType === _tokentype.types.colon) {
	    var _parent = this.curContext();
	    if (_parent === types.b_stat || _parent === types.b_expr) return !_parent.isExpr;
	  }
	  if (prevType === _tokentype.types._return) return _whitespace.lineBreak.test(this.input.slice(this.lastTokEnd, this.start));
	  if (prevType === _tokentype.types._else || prevType === _tokentype.types.semi || prevType === _tokentype.types.eof || prevType === _tokentype.types.parenR) return true;
	  if (prevType == _tokentype.types.braceL) return this.curContext() === types.b_stat;
	  return !this.exprAllowed;
	};

	pp.updateContext = function (prevType) {
	  var update = undefined,
	      type = this.type;
	  if (type.keyword && prevType == _tokentype.types.dot) this.exprAllowed = false;else if (update = type.updateContext) update.call(this, prevType);else this.exprAllowed = type.beforeExpr;
	};

	// Token-specific context update code

	_tokentype.types.parenR.updateContext = _tokentype.types.braceR.updateContext = function () {
	  if (this.context.length == 1) {
	    this.exprAllowed = true;
	    return;
	  }
	  var out = this.context.pop();
	  if (out === types.b_stat && this.curContext() === types.f_expr) {
	    this.context.pop();
	    this.exprAllowed = false;
	  } else if (out === types.b_tmpl) {
	    this.exprAllowed = true;
	  } else {
	    this.exprAllowed = !out.isExpr;
	  }
	};

	_tokentype.types.braceL.updateContext = function (prevType) {
	  this.context.push(this.braceIsBlock(prevType) ? types.b_stat : types.b_expr);
	  this.exprAllowed = true;
	};

	_tokentype.types.dollarBraceL.updateContext = function () {
	  this.context.push(types.b_tmpl);
	  this.exprAllowed = true;
	};

	_tokentype.types.parenL.updateContext = function (prevType) {
	  var statementParens = prevType === _tokentype.types._if || prevType === _tokentype.types._for || prevType === _tokentype.types._with || prevType === _tokentype.types._while;
	  this.context.push(statementParens ? types.p_stat : types.p_expr);
	  this.exprAllowed = true;
	};

	_tokentype.types.incDec.updateContext = function () {
	  // tokExprAllowed stays unchanged
	};

	_tokentype.types._function.updateContext = function () {
	  if (this.curContext() !== types.b_stat) this.context.push(types.f_expr);
	  this.exprAllowed = false;
	};

	_tokentype.types.backQuote.updateContext = function () {
	  if (this.curContext() === types.q_tmpl) this.context.pop();else this.context.push(types.q_tmpl);
	  this.exprAllowed = false;
	};

	},{"./state":10,"./tokentype":14,"./whitespace":16}],13:[function(_dereq_,module,exports){
	"use strict";

	exports.__esModule = true;

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	var _identifier = _dereq_("./identifier");

	var _tokentype = _dereq_("./tokentype");

	var _state = _dereq_("./state");

	var _locutil = _dereq_("./locutil");

	var _whitespace = _dereq_("./whitespace");

	// Object type used to represent tokens. Note that normally, tokens
	// simply exist as properties on the parser object. This is only
	// used for the onToken callback and the external tokenizer.

	var Token = function Token(p) {
	  _classCallCheck(this, Token);

	  this.type = p.type;
	  this.value = p.value;
	  this.start = p.start;
	  this.end = p.end;
	  if (p.options.locations) this.loc = new _locutil.SourceLocation(p, p.startLoc, p.endLoc);
	  if (p.options.ranges) this.range = [p.start, p.end];
	}

	// ## Tokenizer

	;

	exports.Token = Token;
	var pp = _state.Parser.prototype;

	// Are we running under Rhino?
	var isRhino = typeof Packages == "object" && Object.prototype.toString.call(Packages) == "[object JavaPackage]";

	// Move to the next token

	pp.next = function () {
	  if (this.options.onToken) this.options.onToken(new Token(this));

	  this.lastTokEnd = this.end;
	  this.lastTokStart = this.start;
	  this.lastTokEndLoc = this.endLoc;
	  this.lastTokStartLoc = this.startLoc;
	  this.nextToken();
	};

	pp.getToken = function () {
	  this.next();
	  return new Token(this);
	};

	// If we're in an ES6 environment, make parsers iterable
	if (typeof Symbol !== "undefined") pp[Symbol.iterator] = function () {
	  var self = this;
	  return { next: function next() {
	      var token = self.getToken();
	      return {
	        done: token.type === _tokentype.types.eof,
	        value: token
	      };
	    } };
	};

	// Toggle strict mode. Re-reads the next number or string to please
	// pedantic tests (`"use strict"; 010;` should fail).

	pp.setStrict = function (strict) {
	  this.strict = strict;
	  if (this.type !== _tokentype.types.num && this.type !== _tokentype.types.string) return;
	  this.pos = this.start;
	  if (this.options.locations) {
	    while (this.pos < this.lineStart) {
	      this.lineStart = this.input.lastIndexOf("\n", this.lineStart - 2) + 1;
	      --this.curLine;
	    }
	  }
	  this.nextToken();
	};

	pp.curContext = function () {
	  return this.context[this.context.length - 1];
	};

	// Read a single token, updating the parser object's token-related
	// properties.

	pp.nextToken = function () {
	  var curContext = this.curContext();
	  if (!curContext || !curContext.preserveSpace) this.skipSpace();

	  this.start = this.pos;
	  if (this.options.locations) this.startLoc = this.curPosition();
	  if (this.pos >= this.input.length) return this.finishToken(_tokentype.types.eof);

	  if (curContext.override) return curContext.override(this);else this.readToken(this.fullCharCodeAtPos());
	};

	pp.readToken = function (code) {
	  // Identifier or keyword. '\uXXXX' sequences are allowed in
	  // identifiers, so '\' also dispatches to that.
	  if (_identifier.isIdentifierStart(code, this.options.ecmaVersion >= 6) || code === 92 /* '\' */) return this.readWord();

	  return this.getTokenFromCode(code);
	};

	pp.fullCharCodeAtPos = function () {
	  var code = this.input.charCodeAt(this.pos);
	  if (code <= 0xd7ff || code >= 0xe000) return code;
	  var next = this.input.charCodeAt(this.pos + 1);
	  return (code << 10) + next - 0x35fdc00;
	};

	pp.skipBlockComment = function () {
	  var startLoc = this.options.onComment && this.curPosition();
	  var start = this.pos,
	      end = this.input.indexOf("*/", this.pos += 2);
	  if (end === -1) this.raise(this.pos - 2, "Unterminated comment");
	  this.pos = end + 2;
	  if (this.options.locations) {
	    _whitespace.lineBreakG.lastIndex = start;
	    var match = undefined;
	    while ((match = _whitespace.lineBreakG.exec(this.input)) && match.index < this.pos) {
	      ++this.curLine;
	      this.lineStart = match.index + match[0].length;
	    }
	  }
	  if (this.options.onComment) this.options.onComment(true, this.input.slice(start + 2, end), start, this.pos, startLoc, this.curPosition());
	};

	pp.skipLineComment = function (startSkip) {
	  var start = this.pos;
	  var startLoc = this.options.onComment && this.curPosition();
	  var ch = this.input.charCodeAt(this.pos += startSkip);
	  while (this.pos < this.input.length && ch !== 10 && ch !== 13 && ch !== 8232 && ch !== 8233) {
	    ++this.pos;
	    ch = this.input.charCodeAt(this.pos);
	  }
	  if (this.options.onComment) this.options.onComment(false, this.input.slice(start + startSkip, this.pos), start, this.pos, startLoc, this.curPosition());
	};

	// Called at the start of the parse and after every token. Skips
	// whitespace and comments, and.

	pp.skipSpace = function () {
	  loop: while (this.pos < this.input.length) {
	    var ch = this.input.charCodeAt(this.pos);
	    switch (ch) {
	      case 32:case 160:
	        // ' '
	        ++this.pos;
	        break;
	      case 13:
	        if (this.input.charCodeAt(this.pos + 1) === 10) {
	          ++this.pos;
	        }
	      case 10:case 8232:case 8233:
	        ++this.pos;
	        if (this.options.locations) {
	          ++this.curLine;
	          this.lineStart = this.pos;
	        }
	        break;
	      case 47:
	        // '/'
	        switch (this.input.charCodeAt(this.pos + 1)) {
	          case 42:
	            // '*'
	            this.skipBlockComment();
	            break;
	          case 47:
	            this.skipLineComment(2);
	            break;
	          default:
	            break loop;
	        }
	        break;
	      default:
	        if (ch > 8 && ch < 14 || ch >= 5760 && _whitespace.nonASCIIwhitespace.test(String.fromCharCode(ch))) {
	          ++this.pos;
	        } else {
	          break loop;
	        }
	    }
	  }
	};

	// Called at the end of every token. Sets `end`, `val`, and
	// maintains `context` and `exprAllowed`, and skips the space after
	// the token, so that the next one's `start` will point at the
	// right position.

	pp.finishToken = function (type, val) {
	  this.end = this.pos;
	  if (this.options.locations) this.endLoc = this.curPosition();
	  var prevType = this.type;
	  this.type = type;
	  this.value = val;

	  this.updateContext(prevType);
	};

	// ### Token reading

	// This is the function that is called to fetch the next token. It
	// is somewhat obscure, because it works in character codes rather
	// than characters, and because operator parsing has been inlined
	// into it.
	//
	// All in the name of speed.
	//
	pp.readToken_dot = function () {
	  var next = this.input.charCodeAt(this.pos + 1);
	  if (next >= 48 && next <= 57) return this.readNumber(true);
	  var next2 = this.input.charCodeAt(this.pos + 2);
	  if (this.options.ecmaVersion >= 6 && next === 46 && next2 === 46) {
	    // 46 = dot '.'
	    this.pos += 3;
	    return this.finishToken(_tokentype.types.ellipsis);
	  } else {
	    ++this.pos;
	    return this.finishToken(_tokentype.types.dot);
	  }
	};

	pp.readToken_slash = function () {
	  // '/'
	  var next = this.input.charCodeAt(this.pos + 1);
	  if (this.exprAllowed) {
	    ++this.pos;return this.readRegexp();
	  }
	  if (next === 61) return this.finishOp(_tokentype.types.assign, 2);
	  return this.finishOp(_tokentype.types.slash, 1);
	};

	pp.readToken_mult_modulo = function (code) {
	  // '%*'
	  var next = this.input.charCodeAt(this.pos + 1);
	  if (next === 61) return this.finishOp(_tokentype.types.assign, 2);
	  return this.finishOp(code === 42 ? _tokentype.types.star : _tokentype.types.modulo, 1);
	};

	pp.readToken_pipe_amp = function (code) {
	  // '|&'
	  var next = this.input.charCodeAt(this.pos + 1);
	  if (next === code) return this.finishOp(code === 124 ? _tokentype.types.logicalOR : _tokentype.types.logicalAND, 2);
	  if (next === 61) return this.finishOp(_tokentype.types.assign, 2);
	  return this.finishOp(code === 124 ? _tokentype.types.bitwiseOR : _tokentype.types.bitwiseAND, 1);
	};

	pp.readToken_caret = function () {
	  // '^'
	  var next = this.input.charCodeAt(this.pos + 1);
	  if (next === 61) return this.finishOp(_tokentype.types.assign, 2);
	  return this.finishOp(_tokentype.types.bitwiseXOR, 1);
	};

	pp.readToken_plus_min = function (code) {
	  // '+-'
	  var next = this.input.charCodeAt(this.pos + 1);
	  if (next === code) {
	    if (next == 45 && this.input.charCodeAt(this.pos + 2) == 62 && _whitespace.lineBreak.test(this.input.slice(this.lastTokEnd, this.pos))) {
	      // A `-->` line comment
	      this.skipLineComment(3);
	      this.skipSpace();
	      return this.nextToken();
	    }
	    return this.finishOp(_tokentype.types.incDec, 2);
	  }
	  if (next === 61) return this.finishOp(_tokentype.types.assign, 2);
	  return this.finishOp(_tokentype.types.plusMin, 1);
	};

	pp.readToken_lt_gt = function (code) {
	  // '<>'
	  var next = this.input.charCodeAt(this.pos + 1);
	  var size = 1;
	  if (next === code) {
	    size = code === 62 && this.input.charCodeAt(this.pos + 2) === 62 ? 3 : 2;
	    if (this.input.charCodeAt(this.pos + size) === 61) return this.finishOp(_tokentype.types.assign, size + 1);
	    return this.finishOp(_tokentype.types.bitShift, size);
	  }
	  if (next == 33 && code == 60 && this.input.charCodeAt(this.pos + 2) == 45 && this.input.charCodeAt(this.pos + 3) == 45) {
	    if (this.inModule) this.unexpected();
	    // `<!--`, an XML-style comment that should be interpreted as a line comment
	    this.skipLineComment(4);
	    this.skipSpace();
	    return this.nextToken();
	  }
	  if (next === 61) size = this.input.charCodeAt(this.pos + 2) === 61 ? 3 : 2;
	  return this.finishOp(_tokentype.types.relational, size);
	};

	pp.readToken_eq_excl = function (code) {
	  // '=!'
	  var next = this.input.charCodeAt(this.pos + 1);
	  if (next === 61) return this.finishOp(_tokentype.types.equality, this.input.charCodeAt(this.pos + 2) === 61 ? 3 : 2);
	  if (code === 61 && next === 62 && this.options.ecmaVersion >= 6) {
	    // '=>'
	    this.pos += 2;
	    return this.finishToken(_tokentype.types.arrow);
	  }
	  return this.finishOp(code === 61 ? _tokentype.types.eq : _tokentype.types.prefix, 1);
	};

	pp.getTokenFromCode = function (code) {
	  switch (code) {
	    // The interpretation of a dot depends on whether it is followed
	    // by a digit or another two dots.
	    case 46:
	      // '.'
	      return this.readToken_dot();

	    // Punctuation tokens.
	    case 40:
	      ++this.pos;return this.finishToken(_tokentype.types.parenL);
	    case 41:
	      ++this.pos;return this.finishToken(_tokentype.types.parenR);
	    case 59:
	      ++this.pos;return this.finishToken(_tokentype.types.semi);
	    case 44:
	      ++this.pos;return this.finishToken(_tokentype.types.comma);
	    case 91:
	      ++this.pos;return this.finishToken(_tokentype.types.bracketL);
	    case 93:
	      ++this.pos;return this.finishToken(_tokentype.types.bracketR);
	    case 123:
	      ++this.pos;return this.finishToken(_tokentype.types.braceL);
	    case 125:
	      ++this.pos;return this.finishToken(_tokentype.types.braceR);
	    case 58:
	      ++this.pos;return this.finishToken(_tokentype.types.colon);
	    case 63:
	      ++this.pos;return this.finishToken(_tokentype.types.question);

	    case 96:
	      // '`'
	      if (this.options.ecmaVersion < 6) break;
	      ++this.pos;
	      return this.finishToken(_tokentype.types.backQuote);

	    case 48:
	      // '0'
	      var next = this.input.charCodeAt(this.pos + 1);
	      if (next === 120 || next === 88) return this.readRadixNumber(16); // '0x', '0X' - hex number
	      if (this.options.ecmaVersion >= 6) {
	        if (next === 111 || next === 79) return this.readRadixNumber(8); // '0o', '0O' - octal number
	        if (next === 98 || next === 66) return this.readRadixNumber(2); // '0b', '0B' - binary number
	      }
	    // Anything else beginning with a digit is an integer, octal
	    // number, or float.
	    case 49:case 50:case 51:case 52:case 53:case 54:case 55:case 56:case 57:
	      // 1-9
	      return this.readNumber(false);

	    // Quotes produce strings.
	    case 34:case 39:
	      // '"', "'"
	      return this.readString(code);

	    // Operators are parsed inline in tiny state machines. '=' (61) is
	    // often referred to. `finishOp` simply skips the amount of
	    // characters it is given as second argument, and returns a token
	    // of the type given by its first argument.

	    case 47:
	      // '/'
	      return this.readToken_slash();

	    case 37:case 42:
	      // '%*'
	      return this.readToken_mult_modulo(code);

	    case 124:case 38:
	      // '|&'
	      return this.readToken_pipe_amp(code);

	    case 94:
	      // '^'
	      return this.readToken_caret();

	    case 43:case 45:
	      // '+-'
	      return this.readToken_plus_min(code);

	    case 60:case 62:
	      // '<>'
	      return this.readToken_lt_gt(code);

	    case 61:case 33:
	      // '=!'
	      return this.readToken_eq_excl(code);

	    case 126:
	      // '~'
	      return this.finishOp(_tokentype.types.prefix, 1);
	  }

	  this.raise(this.pos, "Unexpected character '" + codePointToString(code) + "'");
	};

	pp.finishOp = function (type, size) {
	  var str = this.input.slice(this.pos, this.pos + size);
	  this.pos += size;
	  return this.finishToken(type, str);
	};

	// Parse a regular expression. Some context-awareness is necessary,
	// since a '/' inside a '[]' set does not end the expression.

	function tryCreateRegexp(src, flags, throwErrorAt, parser) {
	  try {
	    return new RegExp(src, flags);
	  } catch (e) {
	    if (throwErrorAt !== undefined) {
	      if (e instanceof SyntaxError) parser.raise(throwErrorAt, "Error parsing regular expression: " + e.message);
	      throw e;
	    }
	  }
	}

	var regexpUnicodeSupport = !!tryCreateRegexp("", "u");

	pp.readRegexp = function () {
	  var _this = this;

	  var escaped = undefined,
	      inClass = undefined,
	      start = this.pos;
	  for (;;) {
	    if (this.pos >= this.input.length) this.raise(start, "Unterminated regular expression");
	    var ch = this.input.charAt(this.pos);
	    if (_whitespace.lineBreak.test(ch)) this.raise(start, "Unterminated regular expression");
	    if (!escaped) {
	      if (ch === "[") inClass = true;else if (ch === "]" && inClass) inClass = false;else if (ch === "/" && !inClass) break;
	      escaped = ch === "\\";
	    } else escaped = false;
	    ++this.pos;
	  }
	  var content = this.input.slice(start, this.pos);
	  ++this.pos;
	  // Need to use `readWord1` because '\uXXXX' sequences are allowed
	  // here (don't ask).
	  var mods = this.readWord1();
	  var tmp = content;
	  if (mods) {
	    var validFlags = /^[gmsiy]*$/;
	    if (this.options.ecmaVersion >= 6) validFlags = /^[gmsiyu]*$/;
	    if (!validFlags.test(mods)) this.raise(start, "Invalid regular expression flag");
	    if (mods.indexOf('u') >= 0 && !regexpUnicodeSupport) {
	      // Replace each astral symbol and every Unicode escape sequence that
	      // possibly represents an astral symbol or a paired surrogate with a
	      // single ASCII symbol to avoid throwing on regular expressions that
	      // are only valid in combination with the `/u` flag.
	      // Note: replacing with the ASCII symbol `x` might cause false
	      // negatives in unlikely scenarios. For example, `[\u{61}-b]` is a
	      // perfectly valid pattern that is equivalent to `[a-b]`, but it would
	      // be replaced by `[x-b]` which throws an error.
	      tmp = tmp.replace(/\\u\{([0-9a-fA-F]+)\}/g, function (_match, code, offset) {
	        code = Number("0x" + code);
	        if (code > 0x10FFFF) _this.raise(start + offset + 3, "Code point out of bounds");
	        return "x";
	      });
	      tmp = tmp.replace(/\\u([a-fA-F0-9]{4})|[\uD800-\uDBFF][\uDC00-\uDFFF]/g, "x");
	    }
	  }
	  // Detect invalid regular expressions.
	  var value = null;
	  // Rhino's regular expression parser is flaky and throws uncatchable exceptions,
	  // so don't do detection if we are running under Rhino
	  if (!isRhino) {
	    tryCreateRegexp(tmp, undefined, start, this);
	    // Get a regular expression object for this pattern-flag pair, or `null` in
	    // case the current environment doesn't support the flags it uses.
	    value = tryCreateRegexp(content, mods);
	  }
	  return this.finishToken(_tokentype.types.regexp, { pattern: content, flags: mods, value: value });
	};

	// Read an integer in the given radix. Return null if zero digits
	// were read, the integer value otherwise. When `len` is given, this
	// will return `null` unless the integer has exactly `len` digits.

	pp.readInt = function (radix, len) {
	  var start = this.pos,
	      total = 0;
	  for (var i = 0, e = len == null ? Infinity : len; i < e; ++i) {
	    var code = this.input.charCodeAt(this.pos),
	        val = undefined;
	    if (code >= 97) val = code - 97 + 10; // a
	    else if (code >= 65) val = code - 65 + 10; // A
	      else if (code >= 48 && code <= 57) val = code - 48; // 0-9
	        else val = Infinity;
	    if (val >= radix) break;
	    ++this.pos;
	    total = total * radix + val;
	  }
	  if (this.pos === start || len != null && this.pos - start !== len) return null;

	  return total;
	};

	pp.readRadixNumber = function (radix) {
	  this.pos += 2; // 0x
	  var val = this.readInt(radix);
	  if (val == null) this.raise(this.start + 2, "Expected number in radix " + radix);
	  if (_identifier.isIdentifierStart(this.fullCharCodeAtPos())) this.raise(this.pos, "Identifier directly after number");
	  return this.finishToken(_tokentype.types.num, val);
	};

	// Read an integer, octal integer, or floating-point number.

	pp.readNumber = function (startsWithDot) {
	  var start = this.pos,
	      isFloat = false,
	      octal = this.input.charCodeAt(this.pos) === 48;
	  if (!startsWithDot && this.readInt(10) === null) this.raise(start, "Invalid number");
	  var next = this.input.charCodeAt(this.pos);
	  if (next === 46) {
	    // '.'
	    ++this.pos;
	    this.readInt(10);
	    isFloat = true;
	    next = this.input.charCodeAt(this.pos);
	  }
	  if (next === 69 || next === 101) {
	    // 'eE'
	    next = this.input.charCodeAt(++this.pos);
	    if (next === 43 || next === 45) ++this.pos; // '+-'
	    if (this.readInt(10) === null) this.raise(start, "Invalid number");
	    isFloat = true;
	  }
	  if (_identifier.isIdentifierStart(this.fullCharCodeAtPos())) this.raise(this.pos, "Identifier directly after number");

	  var str = this.input.slice(start, this.pos),
	      val = undefined;
	  if (isFloat) val = parseFloat(str);else if (!octal || str.length === 1) val = parseInt(str, 10);else if (/[89]/.test(str) || this.strict) this.raise(start, "Invalid number");else val = parseInt(str, 8);
	  return this.finishToken(_tokentype.types.num, val);
	};

	// Read a string value, interpreting backslash-escapes.

	pp.readCodePoint = function () {
	  var ch = this.input.charCodeAt(this.pos),
	      code = undefined;

	  if (ch === 123) {
	    if (this.options.ecmaVersion < 6) this.unexpected();
	    var codePos = ++this.pos;
	    code = this.readHexChar(this.input.indexOf('}', this.pos) - this.pos);
	    ++this.pos;
	    if (code > 0x10FFFF) this.raise(codePos, "Code point out of bounds");
	  } else {
	    code = this.readHexChar(4);
	  }
	  return code;
	};

	function codePointToString(code) {
	  // UTF-16 Decoding
	  if (code <= 0xFFFF) return String.fromCharCode(code);
	  code -= 0x10000;
	  return String.fromCharCode((code >> 10) + 0xD800, (code & 1023) + 0xDC00);
	}

	pp.readString = function (quote) {
	  var out = "",
	      chunkStart = ++this.pos;
	  for (;;) {
	    if (this.pos >= this.input.length) this.raise(this.start, "Unterminated string constant");
	    var ch = this.input.charCodeAt(this.pos);
	    if (ch === quote) break;
	    if (ch === 92) {
	      // '\'
	      out += this.input.slice(chunkStart, this.pos);
	      out += this.readEscapedChar(false);
	      chunkStart = this.pos;
	    } else {
	      if (_whitespace.isNewLine(ch)) this.raise(this.start, "Unterminated string constant");
	      ++this.pos;
	    }
	  }
	  out += this.input.slice(chunkStart, this.pos++);
	  return this.finishToken(_tokentype.types.string, out);
	};

	// Reads template string tokens.

	pp.readTmplToken = function () {
	  var out = "",
	      chunkStart = this.pos;
	  for (;;) {
	    if (this.pos >= this.input.length) this.raise(this.start, "Unterminated template");
	    var ch = this.input.charCodeAt(this.pos);
	    if (ch === 96 || ch === 36 && this.input.charCodeAt(this.pos + 1) === 123) {
	      // '`', '${'
	      if (this.pos === this.start && this.type === _tokentype.types.template) {
	        if (ch === 36) {
	          this.pos += 2;
	          return this.finishToken(_tokentype.types.dollarBraceL);
	        } else {
	          ++this.pos;
	          return this.finishToken(_tokentype.types.backQuote);
	        }
	      }
	      out += this.input.slice(chunkStart, this.pos);
	      return this.finishToken(_tokentype.types.template, out);
	    }
	    if (ch === 92) {
	      // '\'
	      out += this.input.slice(chunkStart, this.pos);
	      out += this.readEscapedChar(true);
	      chunkStart = this.pos;
	    } else if (_whitespace.isNewLine(ch)) {
	      out += this.input.slice(chunkStart, this.pos);
	      ++this.pos;
	      switch (ch) {
	        case 13:
	          if (this.input.charCodeAt(this.pos) === 10) ++this.pos;
	        case 10:
	          out += "\n";
	          break;
	        default:
	          out += String.fromCharCode(ch);
	          break;
	      }
	      if (this.options.locations) {
	        ++this.curLine;
	        this.lineStart = this.pos;
	      }
	      chunkStart = this.pos;
	    } else {
	      ++this.pos;
	    }
	  }
	};

	// Used to read escaped characters

	pp.readEscapedChar = function (inTemplate) {
	  var ch = this.input.charCodeAt(++this.pos);
	  ++this.pos;
	  switch (ch) {
	    case 110:
	      return "\n"; // 'n' -> '\n'
	    case 114:
	      return "\r"; // 'r' -> '\r'
	    case 120:
	      return String.fromCharCode(this.readHexChar(2)); // 'x'
	    case 117:
	      return codePointToString(this.readCodePoint()); // 'u'
	    case 116:
	      return "\t"; // 't' -> '\t'
	    case 98:
	      return "\b"; // 'b' -> '\b'
	    case 118:
	      return "\u000b"; // 'v' -> '\u000b'
	    case 102:
	      return "\f"; // 'f' -> '\f'
	    case 13:
	      if (this.input.charCodeAt(this.pos) === 10) ++this.pos; // '\r\n'
	    case 10:
	      // ' \n'
	      if (this.options.locations) {
	        this.lineStart = this.pos;++this.curLine;
	      }
	      return "";
	    default:
	      if (ch >= 48 && ch <= 55) {
	        var octalStr = this.input.substr(this.pos - 1, 3).match(/^[0-7]+/)[0];
	        var octal = parseInt(octalStr, 8);
	        if (octal > 255) {
	          octalStr = octalStr.slice(0, -1);
	          octal = parseInt(octalStr, 8);
	        }
	        if (octal > 0 && (this.strict || inTemplate)) {
	          this.raise(this.pos - 2, "Octal literal in strict mode");
	        }
	        this.pos += octalStr.length - 1;
	        return String.fromCharCode(octal);
	      }
	      return String.fromCharCode(ch);
	  }
	};

	// Used to read character escape sequences ('\x', '\u', '\U').

	pp.readHexChar = function (len) {
	  var codePos = this.pos;
	  var n = this.readInt(16, len);
	  if (n === null) this.raise(codePos, "Bad character escape sequence");
	  return n;
	};

	// Read an identifier, and return it as a string. Sets `this.containsEsc`
	// to whether the word contained a '\u' escape.
	//
	// Incrementally adds only escaped chars, adding other chunks as-is
	// as a micro-optimization.

	pp.readWord1 = function () {
	  this.containsEsc = false;
	  var word = "",
	      first = true,
	      chunkStart = this.pos;
	  var astral = this.options.ecmaVersion >= 6;
	  while (this.pos < this.input.length) {
	    var ch = this.fullCharCodeAtPos();
	    if (_identifier.isIdentifierChar(ch, astral)) {
	      this.pos += ch <= 0xffff ? 1 : 2;
	    } else if (ch === 92) {
	      // "\"
	      this.containsEsc = true;
	      word += this.input.slice(chunkStart, this.pos);
	      var escStart = this.pos;
	      if (this.input.charCodeAt(++this.pos) != 117) // "u"
	        this.raise(this.pos, "Expecting Unicode escape sequence \\uXXXX");
	      ++this.pos;
	      var esc = this.readCodePoint();
	      if (!(first ? _identifier.isIdentifierStart : _identifier.isIdentifierChar)(esc, astral)) this.raise(escStart, "Invalid Unicode escape");
	      word += codePointToString(esc);
	      chunkStart = this.pos;
	    } else {
	      break;
	    }
	    first = false;
	  }
	  return word + this.input.slice(chunkStart, this.pos);
	};

	// Read an identifier or keyword token. Will check for reserved
	// words when necessary.

	pp.readWord = function () {
	  var word = this.readWord1();
	  var type = _tokentype.types.name;
	  if ((this.options.ecmaVersion >= 6 || !this.containsEsc) && this.keywords.test(word)) type = _tokentype.keywords[word];
	  return this.finishToken(type, word);
	};

	},{"./identifier":2,"./locutil":5,"./state":10,"./tokentype":14,"./whitespace":16}],14:[function(_dereq_,module,exports){
	// ## Token types

	// The assignment of fine-grained, information-carrying type objects
	// allows the tokenizer to store the information it has about a
	// token in a way that is very cheap for the parser to look up.

	// All token type variables start with an underscore, to make them
	// easy to recognize.

	// The `beforeExpr` property is used to disambiguate between regular
	// expressions and divisions. It is set on all token types that can
	// be followed by an expression (thus, a slash after them would be a
	// regular expression).
	//
	// The `startsExpr` property is used to check if the token ends a
	// `yield` expression. It is set on all token types that either can
	// directly start an expression (like a quotation mark) or can
	// continue an expression (like the body of a string).
	//
	// `isLoop` marks a keyword as starting a loop, which is important
	// to know when parsing a label, in order to allow or disallow
	// continue jumps to that label.

	"use strict";

	exports.__esModule = true;

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	var TokenType = function TokenType(label) {
	  var conf = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

	  _classCallCheck(this, TokenType);

	  this.label = label;
	  this.keyword = conf.keyword;
	  this.beforeExpr = !!conf.beforeExpr;
	  this.startsExpr = !!conf.startsExpr;
	  this.isLoop = !!conf.isLoop;
	  this.isAssign = !!conf.isAssign;
	  this.prefix = !!conf.prefix;
	  this.postfix = !!conf.postfix;
	  this.binop = conf.binop || null;
	  this.updateContext = null;
	};

	exports.TokenType = TokenType;

	function binop(name, prec) {
	  return new TokenType(name, { beforeExpr: true, binop: prec });
	}
	var beforeExpr = { beforeExpr: true },
	    startsExpr = { startsExpr: true };

	var types = {
	  num: new TokenType("num", startsExpr),
	  regexp: new TokenType("regexp", startsExpr),
	  string: new TokenType("string", startsExpr),
	  name: new TokenType("name", startsExpr),
	  eof: new TokenType("eof"),

	  // Punctuation token types.
	  bracketL: new TokenType("[", { beforeExpr: true, startsExpr: true }),
	  bracketR: new TokenType("]"),
	  braceL: new TokenType("{", { beforeExpr: true, startsExpr: true }),
	  braceR: new TokenType("}"),
	  parenL: new TokenType("(", { beforeExpr: true, startsExpr: true }),
	  parenR: new TokenType(")"),
	  comma: new TokenType(",", beforeExpr),
	  semi: new TokenType(";", beforeExpr),
	  colon: new TokenType(":", beforeExpr),
	  dot: new TokenType("."),
	  question: new TokenType("?", beforeExpr),
	  arrow: new TokenType("=>", beforeExpr),
	  template: new TokenType("template"),
	  ellipsis: new TokenType("...", beforeExpr),
	  backQuote: new TokenType("`", startsExpr),
	  dollarBraceL: new TokenType("${", { beforeExpr: true, startsExpr: true }),

	  // Operators. These carry several kinds of properties to help the
	  // parser use them properly (the presence of these properties is
	  // what categorizes them as operators).
	  //
	  // `binop`, when present, specifies that this operator is a binary
	  // operator, and will refer to its precedence.
	  //
	  // `prefix` and `postfix` mark the operator as a prefix or postfix
	  // unary operator.
	  //
	  // `isAssign` marks all of `=`, `+=`, `-=` etcetera, which act as
	  // binary operators with a very low precedence, that should result
	  // in AssignmentExpression nodes.

	  eq: new TokenType("=", { beforeExpr: true, isAssign: true }),
	  assign: new TokenType("_=", { beforeExpr: true, isAssign: true }),
	  incDec: new TokenType("++/--", { prefix: true, postfix: true, startsExpr: true }),
	  prefix: new TokenType("prefix", { beforeExpr: true, prefix: true, startsExpr: true }),
	  logicalOR: binop("||", 1),
	  logicalAND: binop("&&", 2),
	  bitwiseOR: binop("|", 3),
	  bitwiseXOR: binop("^", 4),
	  bitwiseAND: binop("&", 5),
	  equality: binop("==/!=", 6),
	  relational: binop("</>", 7),
	  bitShift: binop("<</>>", 8),
	  plusMin: new TokenType("+/-", { beforeExpr: true, binop: 9, prefix: true, startsExpr: true }),
	  modulo: binop("%", 10),
	  star: binop("*", 10),
	  slash: binop("/", 10)
	};

	exports.types = types;
	// Map keyword names to token types.

	var keywords = {};

	exports.keywords = keywords;
	// Succinct definitions of keyword token types
	function kw(name) {
	  var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

	  options.keyword = name;
	  keywords[name] = types["_" + name] = new TokenType(name, options);
	}

	kw("break");
	kw("case", beforeExpr);
	kw("catch");
	kw("continue");
	kw("debugger");
	kw("default", beforeExpr);
	kw("do", { isLoop: true, beforeExpr: true });
	kw("else", beforeExpr);
	kw("finally");
	kw("for", { isLoop: true });
	kw("function", startsExpr);
	kw("if");
	kw("return", beforeExpr);
	kw("switch");
	kw("throw", beforeExpr);
	kw("try");
	kw("var");
	kw("let");
	kw("const");
	kw("while", { isLoop: true });
	kw("with");
	kw("new", { beforeExpr: true, startsExpr: true });
	kw("this", startsExpr);
	kw("super", startsExpr);
	kw("class");
	kw("extends", beforeExpr);
	kw("export");
	kw("import");
	kw("yield", { beforeExpr: true, startsExpr: true });
	kw("null", startsExpr);
	kw("true", startsExpr);
	kw("false", startsExpr);
	kw("in", { beforeExpr: true, binop: 7 });
	kw("instanceof", { beforeExpr: true, binop: 7 });
	kw("typeof", { beforeExpr: true, prefix: true, startsExpr: true });
	kw("void", { beforeExpr: true, prefix: true, startsExpr: true });
	kw("delete", { beforeExpr: true, prefix: true, startsExpr: true });

	},{}],15:[function(_dereq_,module,exports){
	"use strict";

	exports.__esModule = true;
	exports.isArray = isArray;
	exports.has = has;

	function isArray(obj) {
	  return Object.prototype.toString.call(obj) === "[object Array]";
	}

	// Checks if an object has a property.

	function has(obj, propName) {
	  return Object.prototype.hasOwnProperty.call(obj, propName);
	}

	},{}],16:[function(_dereq_,module,exports){
	// Matches a whole line break (where CRLF is considered a single
	// line break). Used to count lines.

	"use strict";

	exports.__esModule = true;
	exports.isNewLine = isNewLine;
	var lineBreak = /\r\n?|\n|\u2028|\u2029/;
	exports.lineBreak = lineBreak;
	var lineBreakG = new RegExp(lineBreak.source, "g");

	exports.lineBreakG = lineBreakG;

	function isNewLine(code) {
	  return code === 10 || code === 13 || code === 0x2028 || code == 0x2029;
	}

	var nonASCIIwhitespace = /[\u1680\u180e\u2000-\u200a\u202f\u205f\u3000\ufeff]/;
	exports.nonASCIIwhitespace = nonASCIIwhitespace;

	},{}]},{},[3])(3)
	});

/***/ },
/* 35 */
/***/ function(module, exports, __webpack_require__) {

	var require;var require;(function(f){if(true){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}(g.acorn || (g.acorn = {})).walk = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return require(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(_dereq_,module,exports){
	// AST walker module for Mozilla Parser API compatible trees

	// A simple walk is one where you simply specify callbacks to be
	// called on specific nodes. The last two arguments are optional. A
	// simple use would be
	//
	//     walk.simple(myTree, {
	//         Expression: function(node) { ... }
	//     });
	//
	// to do something with all expressions. All Parser API node types
	// can be used to identify node types, as well as Expression,
	// Statement, and ScopeBody, which denote categories of nodes.
	//
	// The base argument can be used to pass a custom (recursive)
	// walker, and state can be used to give this walked an initial
	// state.

	"use strict";

	exports.__esModule = true;
	exports.simple = simple;
	exports.ancestor = ancestor;
	exports.recursive = recursive;
	exports.findNodeAt = findNodeAt;
	exports.findNodeAround = findNodeAround;
	exports.findNodeAfter = findNodeAfter;
	exports.findNodeBefore = findNodeBefore;
	exports.make = make;

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function simple(node, visitors, base, state, override) {
	  if (!base) base = exports.base;(function c(node, st, override) {
	    var type = override || node.type,
	        found = visitors[type];
	    base[type](node, st, c);
	    if (found) found(node, st);
	  })(node, state, override);
	}

	// An ancestor walk builds up an array of ancestor nodes (including
	// the current node) and passes them to the callback as the state parameter.

	function ancestor(node, visitors, base, state) {
	  if (!base) base = exports.base;
	  if (!state) state = [];(function c(node, st, override) {
	    var type = override || node.type,
	        found = visitors[type];
	    if (node != st[st.length - 1]) {
	      st = st.slice();
	      st.push(node);
	    }
	    base[type](node, st, c);
	    if (found) found(node, st);
	  })(node, state);
	}

	// A recursive walk is one where your functions override the default
	// walkers. They can modify and replace the state parameter that's
	// threaded through the walk, and can opt how and whether to walk
	// their child nodes (by calling their third argument on these
	// nodes).

	function recursive(node, state, funcs, base, override) {
	  var visitor = funcs ? exports.make(funcs, base) : base;(function c(node, st, override) {
	    visitor[override || node.type](node, st, c);
	  })(node, state, override);
	}

	function makeTest(test) {
	  if (typeof test == "string") return function (type) {
	    return type == test;
	  };else if (!test) return function () {
	    return true;
	  };else return test;
	}

	var Found = function Found(node, state) {
	  _classCallCheck(this, Found);

	  this.node = node;this.state = state;
	}

	// Find a node with a given start, end, and type (all are optional,
	// null can be used as wildcard). Returns a {node, state} object, or
	// undefined when it doesn't find a matching node.
	;

	function findNodeAt(node, start, end, test, base, state) {
	  test = makeTest(test);
	  if (!base) base = exports.base;
	  try {
	    ;(function c(node, st, override) {
	      var type = override || node.type;
	      if ((start == null || node.start <= start) && (end == null || node.end >= end)) base[type](node, st, c);
	      if ((start == null || node.start == start) && (end == null || node.end == end) && test(type, node)) throw new Found(node, st);
	    })(node, state);
	  } catch (e) {
	    if (e instanceof Found) return e;
	    throw e;
	  }
	}

	// Find the innermost node of a given type that contains the given
	// position. Interface similar to findNodeAt.

	function findNodeAround(node, pos, test, base, state) {
	  test = makeTest(test);
	  if (!base) base = exports.base;
	  try {
	    ;(function c(node, st, override) {
	      var type = override || node.type;
	      if (node.start > pos || node.end < pos) return;
	      base[type](node, st, c);
	      if (test(type, node)) throw new Found(node, st);
	    })(node, state);
	  } catch (e) {
	    if (e instanceof Found) return e;
	    throw e;
	  }
	}

	// Find the outermost matching node after a given position.

	function findNodeAfter(node, pos, test, base, state) {
	  test = makeTest(test);
	  if (!base) base = exports.base;
	  try {
	    ;(function c(node, st, override) {
	      if (node.end < pos) return;
	      var type = override || node.type;
	      if (node.start >= pos && test(type, node)) throw new Found(node, st);
	      base[type](node, st, c);
	    })(node, state);
	  } catch (e) {
	    if (e instanceof Found) return e;
	    throw e;
	  }
	}

	// Find the outermost matching node before a given position.

	function findNodeBefore(node, pos, test, base, state) {
	  test = makeTest(test);
	  if (!base) base = exports.base;
	  var max = undefined;(function c(node, st, override) {
	    if (node.start > pos) return;
	    var type = override || node.type;
	    if (node.end <= pos && (!max || max.node.end < node.end) && test(type, node)) max = new Found(node, st);
	    base[type](node, st, c);
	  })(node, state);
	  return max;
	}

	// Used to create a custom walker. Will fill in all missing node
	// type properties with the defaults.

	function make(funcs, base) {
	  if (!base) base = exports.base;
	  var visitor = {};
	  for (var type in base) visitor[type] = base[type];
	  for (var type in funcs) visitor[type] = funcs[type];
	  return visitor;
	}

	function skipThrough(node, st, c) {
	  c(node, st);
	}
	function ignore(_node, _st, _c) {}

	// Node walkers.

	var base = {};

	exports.base = base;
	base.Program = base.BlockStatement = function (node, st, c) {
	  for (var i = 0; i < node.body.length; ++i) {
	    c(node.body[i], st, "Statement");
	  }
	};
	base.Statement = skipThrough;
	base.EmptyStatement = ignore;
	base.ExpressionStatement = base.ParenthesizedExpression = function (node, st, c) {
	  return c(node.expression, st, "Expression");
	};
	base.IfStatement = function (node, st, c) {
	  c(node.test, st, "Expression");
	  c(node.consequent, st, "Statement");
	  if (node.alternate) c(node.alternate, st, "Statement");
	};
	base.LabeledStatement = function (node, st, c) {
	  return c(node.body, st, "Statement");
	};
	base.BreakStatement = base.ContinueStatement = ignore;
	base.WithStatement = function (node, st, c) {
	  c(node.object, st, "Expression");
	  c(node.body, st, "Statement");
	};
	base.SwitchStatement = function (node, st, c) {
	  c(node.discriminant, st, "Expression");
	  for (var i = 0; i < node.cases.length; ++i) {
	    var cs = node.cases[i];
	    if (cs.test) c(cs.test, st, "Expression");
	    for (var j = 0; j < cs.consequent.length; ++j) {
	      c(cs.consequent[j], st, "Statement");
	    }
	  }
	};
	base.ReturnStatement = base.YieldExpression = function (node, st, c) {
	  if (node.argument) c(node.argument, st, "Expression");
	};
	base.ThrowStatement = base.SpreadElement = function (node, st, c) {
	  return c(node.argument, st, "Expression");
	};
	base.TryStatement = function (node, st, c) {
	  c(node.block, st, "Statement");
	  if (node.handler) {
	    c(node.handler.param, st, "Pattern");
	    c(node.handler.body, st, "ScopeBody");
	  }
	  if (node.finalizer) c(node.finalizer, st, "Statement");
	};
	base.WhileStatement = base.DoWhileStatement = function (node, st, c) {
	  c(node.test, st, "Expression");
	  c(node.body, st, "Statement");
	};
	base.ForStatement = function (node, st, c) {
	  if (node.init) c(node.init, st, "ForInit");
	  if (node.test) c(node.test, st, "Expression");
	  if (node.update) c(node.update, st, "Expression");
	  c(node.body, st, "Statement");
	};
	base.ForInStatement = base.ForOfStatement = function (node, st, c) {
	  c(node.left, st, "ForInit");
	  c(node.right, st, "Expression");
	  c(node.body, st, "Statement");
	};
	base.ForInit = function (node, st, c) {
	  if (node.type == "VariableDeclaration") c(node, st);else c(node, st, "Expression");
	};
	base.DebuggerStatement = ignore;

	base.FunctionDeclaration = function (node, st, c) {
	  return c(node, st, "Function");
	};
	base.VariableDeclaration = function (node, st, c) {
	  for (var i = 0; i < node.declarations.length; ++i) {
	    c(node.declarations[i], st);
	  }
	};
	base.VariableDeclarator = function (node, st, c) {
	  c(node.id, st, "Pattern");
	  if (node.init) c(node.init, st, "Expression");
	};

	base.Function = function (node, st, c) {
	  if (node.id) c(node.id, st, "Pattern");
	  for (var i = 0; i < node.params.length; i++) {
	    c(node.params[i], st, "Pattern");
	  }c(node.body, st, node.expression ? "ScopeExpression" : "ScopeBody");
	};
	// FIXME drop these node types in next major version
	// (They are awkward, and in ES6 every block can be a scope.)
	base.ScopeBody = function (node, st, c) {
	  return c(node, st, "Statement");
	};
	base.ScopeExpression = function (node, st, c) {
	  return c(node, st, "Expression");
	};

	base.Pattern = function (node, st, c) {
	  if (node.type == "Identifier") c(node, st, "VariablePattern");else if (node.type == "MemberExpression") c(node, st, "MemberPattern");else c(node, st);
	};
	base.VariablePattern = ignore;
	base.MemberPattern = skipThrough;
	base.RestElement = function (node, st, c) {
	  return c(node.argument, st, "Pattern");
	};
	base.ArrayPattern = function (node, st, c) {
	  for (var i = 0; i < node.elements.length; ++i) {
	    var elt = node.elements[i];
	    if (elt) c(elt, st, "Pattern");
	  }
	};
	base.ObjectPattern = function (node, st, c) {
	  for (var i = 0; i < node.properties.length; ++i) {
	    c(node.properties[i].value, st, "Pattern");
	  }
	};

	base.Expression = skipThrough;
	base.ThisExpression = base.Super = base.MetaProperty = ignore;
	base.ArrayExpression = function (node, st, c) {
	  for (var i = 0; i < node.elements.length; ++i) {
	    var elt = node.elements[i];
	    if (elt) c(elt, st, "Expression");
	  }
	};
	base.ObjectExpression = function (node, st, c) {
	  for (var i = 0; i < node.properties.length; ++i) {
	    c(node.properties[i], st);
	  }
	};
	base.FunctionExpression = base.ArrowFunctionExpression = base.FunctionDeclaration;
	base.SequenceExpression = base.TemplateLiteral = function (node, st, c) {
	  for (var i = 0; i < node.expressions.length; ++i) {
	    c(node.expressions[i], st, "Expression");
	  }
	};
	base.UnaryExpression = base.UpdateExpression = function (node, st, c) {
	  c(node.argument, st, "Expression");
	};
	base.BinaryExpression = base.LogicalExpression = function (node, st, c) {
	  c(node.left, st, "Expression");
	  c(node.right, st, "Expression");
	};
	base.AssignmentExpression = base.AssignmentPattern = function (node, st, c) {
	  c(node.left, st, "Pattern");
	  c(node.right, st, "Expression");
	};
	base.ConditionalExpression = function (node, st, c) {
	  c(node.test, st, "Expression");
	  c(node.consequent, st, "Expression");
	  c(node.alternate, st, "Expression");
	};
	base.NewExpression = base.CallExpression = function (node, st, c) {
	  c(node.callee, st, "Expression");
	  if (node.arguments) for (var i = 0; i < node.arguments.length; ++i) {
	    c(node.arguments[i], st, "Expression");
	  }
	};
	base.MemberExpression = function (node, st, c) {
	  c(node.object, st, "Expression");
	  if (node.computed) c(node.property, st, "Expression");
	};
	base.ExportNamedDeclaration = base.ExportDefaultDeclaration = function (node, st, c) {
	  if (node.declaration) c(node.declaration, st, node.type == "ExportNamedDeclaration" || node.declaration.id ? "Statement" : "Expression");
	  if (node.source) c(node.source, st, "Expression");
	};
	base.ExportAllDeclaration = function (node, st, c) {
	  c(node.source, st, "Expression");
	};
	base.ImportDeclaration = function (node, st, c) {
	  for (var i = 0; i < node.specifiers.length; i++) {
	    c(node.specifiers[i], st);
	  }c(node.source, st, "Expression");
	};
	base.ImportSpecifier = base.ImportDefaultSpecifier = base.ImportNamespaceSpecifier = base.Identifier = base.Literal = ignore;

	base.TaggedTemplateExpression = function (node, st, c) {
	  c(node.tag, st, "Expression");
	  c(node.quasi, st);
	};
	base.ClassDeclaration = base.ClassExpression = function (node, st, c) {
	  return c(node, st, "Class");
	};
	base.Class = function (node, st, c) {
	  if (node.id) c(node.id, st, "Pattern");
	  if (node.superClass) c(node.superClass, st, "Expression");
	  for (var i = 0; i < node.body.body.length; i++) {
	    c(node.body.body[i], st);
	  }
	};
	base.MethodDefinition = base.Property = function (node, st, c) {
	  if (node.computed) c(node.key, st, "Expression");
	  c(node.value, st, "Expression");
	};
	base.ComprehensionExpression = function (node, st, c) {
	  for (var i = 0; i < node.blocks.length; i++) {
	    c(node.blocks[i].right, st, "Expression");
	  }c(node.body, st, "Expression");
	};

	},{}]},{},[1])(1)
	});

/***/ },
/* 36 */
/***/ function(module, exports) {

	/* (ignored) */

/***/ },
/* 37 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var nodes = __webpack_require__(14);
	var filters = __webpack_require__(31);
	var doctypes = __webpack_require__(38);
	var runtime = __webpack_require__(39);
	var utils = __webpack_require__(12);
	var selfClosing = __webpack_require__(40);
	var parseJSExpression = __webpack_require__(13).parseMax;
	var constantinople = __webpack_require__(33);

	function isConstant(src) {
	  return constantinople(src, {jade: runtime, 'jade_interp': undefined});
	}
	function toConstant(src) {
	  return constantinople.toConstant(src, {jade: runtime, 'jade_interp': undefined});
	}
	function errorAtNode(node, error) {
	  error.line = node.line;
	  error.filename = node.filename;
	  return error;
	}

	/**
	 * Initialize `Compiler` with the given `node`.
	 *
	 * @param {Node} node
	 * @param {Object} options
	 * @api public
	 */

	var Compiler = module.exports = function Compiler(node, options) {
	  this.options = options = options || {};
	  this.node = node;
	  this.hasCompiledDoctype = false;
	  this.hasCompiledTag = false;
	  this.pp = options.pretty || false;
	  if (this.pp && typeof this.pp !== 'string') {
	    this.pp = '  ';
	  }
	  this.debug = false !== options.compileDebug;
	  this.indents = 0;
	  this.parentIndents = 0;
	  this.terse = false;
	  this.mixins = {};
	  this.dynamicMixins = false;
	  if (options.doctype) this.setDoctype(options.doctype);
	};

	/**
	 * Compiler prototype.
	 */

	Compiler.prototype = {

	  /**
	   * Compile parse tree to JavaScript.
	   *
	   * @api public
	   */

	  compile: function(){
	    this.buf = [];
	    if (this.pp) this.buf.push("var jade_indent = [];");
	    this.lastBufferedIdx = -1;
	    this.visit(this.node);
	    if (!this.dynamicMixins) {
	      // if there are no dynamic mixins we can remove any un-used mixins
	      var mixinNames = Object.keys(this.mixins);
	      for (var i = 0; i < mixinNames.length; i++) {
	        var mixin = this.mixins[mixinNames[i]];
	        if (!mixin.used) {
	          for (var x = 0; x < mixin.instances.length; x++) {
	            for (var y = mixin.instances[x].start; y < mixin.instances[x].end; y++) {
	              this.buf[y] = '';
	            }
	          }
	        }
	      }
	    }
	    return this.buf.join('\n');
	  },

	  /**
	   * Sets the default doctype `name`. Sets terse mode to `true` when
	   * html 5 is used, causing self-closing tags to end with ">" vs "/>",
	   * and boolean attributes are not mirrored.
	   *
	   * @param {string} name
	   * @api public
	   */

	  setDoctype: function(name){
	    this.doctype = doctypes[name.toLowerCase()] || '<!DOCTYPE ' + name + '>';
	    this.terse = this.doctype.toLowerCase() == '<!doctype html>';
	    this.xml = 0 == this.doctype.indexOf('<?xml');
	  },

	  /**
	   * Buffer the given `str` exactly as is or with interpolation
	   *
	   * @param {String} str
	   * @param {Boolean} interpolate
	   * @api public
	   */

	  buffer: function (str, interpolate) {
	    var self = this;
	    if (interpolate) {
	      var match = /(\\)?([#!]){((?:.|\n)*)$/.exec(str);
	      if (match) {
	        this.buffer(str.substr(0, match.index), false);
	        if (match[1]) { // escape
	          this.buffer(match[2] + '{', false);
	          this.buffer(match[3], true);
	          return;
	        } else {
	          var rest = match[3];
	          var range = parseJSExpression(rest);
	          var code = ('!' == match[2] ? '' : 'jade.escape') + "((jade_interp = " + range.src + ") == null ? '' : jade_interp)";
	          this.bufferExpression(code);
	          this.buffer(rest.substr(range.end + 1), true);
	          return;
	        }
	      }
	    }

	    str = utils.stringify(str);
	    str = str.substr(1, str.length - 2);

	    if (this.lastBufferedIdx == this.buf.length) {
	      if (this.lastBufferedType === 'code') this.lastBuffered += ' + "';
	      this.lastBufferedType = 'text';
	      this.lastBuffered += str;
	      this.buf[this.lastBufferedIdx - 1] = 'buf.push(' + this.bufferStartChar + this.lastBuffered + '");'
	    } else {
	      this.buf.push('buf.push("' + str + '");');
	      this.lastBufferedType = 'text';
	      this.bufferStartChar = '"';
	      this.lastBuffered = str;
	      this.lastBufferedIdx = this.buf.length;
	    }
	  },

	  /**
	   * Buffer the given `src` so it is evaluated at run time
	   *
	   * @param {String} src
	   * @api public
	   */

	  bufferExpression: function (src) {
	    if (isConstant(src)) {
	      return this.buffer(toConstant(src) + '', false)
	    }
	    if (this.lastBufferedIdx == this.buf.length) {
	      if (this.lastBufferedType === 'text') this.lastBuffered += '"';
	      this.lastBufferedType = 'code';
	      this.lastBuffered += ' + (' + src + ')';
	      this.buf[this.lastBufferedIdx - 1] = 'buf.push(' + this.bufferStartChar + this.lastBuffered + ');'
	    } else {
	      this.buf.push('buf.push(' + src + ');');
	      this.lastBufferedType = 'code';
	      this.bufferStartChar = '';
	      this.lastBuffered = '(' + src + ')';
	      this.lastBufferedIdx = this.buf.length;
	    }
	  },

	  /**
	   * Buffer an indent based on the current `indent`
	   * property and an additional `offset`.
	   *
	   * @param {Number} offset
	   * @param {Boolean} newline
	   * @api public
	   */

	  prettyIndent: function(offset, newline){
	    offset = offset || 0;
	    newline = newline ? '\n' : '';
	    this.buffer(newline + Array(this.indents + offset).join(this.pp));
	    if (this.parentIndents)
	      this.buf.push("buf.push.apply(buf, jade_indent);");
	  },

	  /**
	   * Visit `node`.
	   *
	   * @param {Node} node
	   * @api public
	   */

	  visit: function(node){
	    var debug = this.debug;

	    if (debug) {
	      this.buf.push('jade_debug.unshift(new jade.DebugItem( ' + node.line
	        + ', ' + (node.filename
	          ? utils.stringify(node.filename)
	          : 'jade_debug[0].filename')
	        + ' ));');
	    }

	    // Massive hack to fix our context
	    // stack for - else[ if] etc
	    if (false === node.debug && this.debug) {
	      this.buf.pop();
	      this.buf.pop();
	    }

	    this.visitNode(node);

	    if (debug) this.buf.push('jade_debug.shift();');
	  },

	  /**
	   * Visit `node`.
	   *
	   * @param {Node} node
	   * @api public
	   */

	  visitNode: function(node){
	    return this['visit' + node.type](node);
	  },

	  /**
	   * Visit case `node`.
	   *
	   * @param {Literal} node
	   * @api public
	   */

	  visitCase: function(node){
	    var _ = this.withinCase;
	    this.withinCase = true;
	    this.buf.push('switch (' + node.expr + '){');
	    this.visit(node.block);
	    this.buf.push('}');
	    this.withinCase = _;
	  },

	  /**
	   * Visit when `node`.
	   *
	   * @param {Literal} node
	   * @api public
	   */

	  visitWhen: function(node){
	    if ('default' == node.expr) {
	      this.buf.push('default:');
	    } else {
	      this.buf.push('case ' + node.expr + ':');
	    }
	    if (node.block) {
	      this.visit(node.block);
	      this.buf.push('  break;');
	    }
	  },

	  /**
	   * Visit literal `node`.
	   *
	   * @param {Literal} node
	   * @api public
	   */

	  visitLiteral: function(node){
	    this.buffer(node.str);
	  },

	  /**
	   * Visit all nodes in `block`.
	   *
	   * @param {Block} block
	   * @api public
	   */

	  visitBlock: function(block){
	    var len = block.nodes.length
	      , escape = this.escape
	      , pp = this.pp

	    // Pretty print multi-line text
	    if (pp && len > 1 && !escape && block.nodes[0].isText && block.nodes[1].isText)
	      this.prettyIndent(1, true);

	    for (var i = 0; i < len; ++i) {
	      // Pretty print text
	      if (pp && i > 0 && !escape && block.nodes[i].isText && block.nodes[i-1].isText)
	        this.prettyIndent(1, false);

	      this.visit(block.nodes[i]);
	      // Multiple text nodes are separated by newlines
	      if (block.nodes[i+1] && block.nodes[i].isText && block.nodes[i+1].isText)
	        this.buffer('\n');
	    }
	  },

	  /**
	   * Visit a mixin's `block` keyword.
	   *
	   * @param {MixinBlock} block
	   * @api public
	   */

	  visitMixinBlock: function(block){
	    if (this.pp) this.buf.push("jade_indent.push('" + Array(this.indents + 1).join(this.pp) + "');");
	    this.buf.push('block && block();');
	    if (this.pp) this.buf.push("jade_indent.pop();");
	  },

	  /**
	   * Visit `doctype`. Sets terse mode to `true` when html 5
	   * is used, causing self-closing tags to end with ">" vs "/>",
	   * and boolean attributes are not mirrored.
	   *
	   * @param {Doctype} doctype
	   * @api public
	   */

	  visitDoctype: function(doctype){
	    if (doctype && (doctype.val || !this.doctype)) {
	      this.setDoctype(doctype.val || 'default');
	    }

	    if (this.doctype) this.buffer(this.doctype);
	    this.hasCompiledDoctype = true;
	  },

	  /**
	   * Visit `mixin`, generating a function that
	   * may be called within the template.
	   *
	   * @param {Mixin} mixin
	   * @api public
	   */

	  visitMixin: function(mixin){
	    var name = 'jade_mixins[';
	    var args = mixin.args || '';
	    var block = mixin.block;
	    var attrs = mixin.attrs;
	    var attrsBlocks = mixin.attributeBlocks.slice();
	    var pp = this.pp;
	    var dynamic = mixin.name[0]==='#';
	    var key = mixin.name;
	    if (dynamic) this.dynamicMixins = true;
	    name += (dynamic ? mixin.name.substr(2,mixin.name.length-3):'"'+mixin.name+'"')+']';

	    this.mixins[key] = this.mixins[key] || {used: false, instances: []};
	    if (mixin.call) {
	      this.mixins[key].used = true;
	      if (pp) this.buf.push("jade_indent.push('" + Array(this.indents + 1).join(pp) + "');")
	      if (block || attrs.length || attrsBlocks.length) {

	        this.buf.push(name + '.call({');

	        if (block) {
	          this.buf.push('block: function(){');

	          // Render block with no indents, dynamically added when rendered
	          this.parentIndents++;
	          var _indents = this.indents;
	          this.indents = 0;
	          this.visit(mixin.block);
	          this.indents = _indents;
	          this.parentIndents--;

	          if (attrs.length || attrsBlocks.length) {
	            this.buf.push('},');
	          } else {
	            this.buf.push('}');
	          }
	        }

	        if (attrsBlocks.length) {
	          if (attrs.length) {
	            var val = this.attrs(attrs);
	            attrsBlocks.unshift(val);
	          }
	          this.buf.push('attributes: jade.merge([' + attrsBlocks.join(',') + '])');
	        } else if (attrs.length) {
	          var val = this.attrs(attrs);
	          this.buf.push('attributes: ' + val);
	        }

	        if (args) {
	          this.buf.push('}, ' + args + ');');
	        } else {
	          this.buf.push('});');
	        }

	      } else {
	        this.buf.push(name + '(' + args + ');');
	      }
	      if (pp) this.buf.push("jade_indent.pop();")
	    } else {
	      var mixin_start = this.buf.length;
	      args = args ? args.split(',') : [];
	      var rest;
	      if (args.length && /^\.\.\./.test(args[args.length - 1].trim())) {
	        rest = args.pop().trim().replace(/^\.\.\./, '');
	      }
	      // we need use jade_interp here for v8: https://code.google.com/p/v8/issues/detail?id=4165
	      // once fixed, use this: this.buf.push(name + ' = function(' + args.join(',') + '){');
	      this.buf.push(name + ' = jade_interp = function(' + args.join(',') + '){');
	      this.buf.push('var block = (this && this.block), attributes = (this && this.attributes) || {};');
	      if (rest) {
	        this.buf.push('var ' + rest + ' = [];');
	        this.buf.push('for (jade_interp = ' + args.length + '; jade_interp < arguments.length; jade_interp++) {');
	        this.buf.push('  ' + rest + '.push(arguments[jade_interp]);');
	        this.buf.push('}');
	      }
	      this.parentIndents++;
	      this.visit(block);
	      this.parentIndents--;
	      this.buf.push('};');
	      var mixin_end = this.buf.length;
	      this.mixins[key].instances.push({start: mixin_start, end: mixin_end});
	    }
	  },

	  /**
	   * Visit `tag` buffering tag markup, generating
	   * attributes, visiting the `tag`'s code and block.
	   *
	   * @param {Tag} tag
	   * @api public
	   */

	  visitTag: function(tag){
	    this.indents++;
	    var name = tag.name
	      , pp = this.pp
	      , self = this;

	    function bufferName() {
	      if (tag.buffer) self.bufferExpression(name);
	      else self.buffer(name);
	    }

	    if ('pre' == tag.name) this.escape = true;

	    if (!this.hasCompiledTag) {
	      if (!this.hasCompiledDoctype && 'html' == name) {
	        this.visitDoctype();
	      }
	      this.hasCompiledTag = true;
	    }

	    // pretty print
	    if (pp && !tag.isInline())
	      this.prettyIndent(0, true);

	    if (tag.selfClosing || (!this.xml && selfClosing[tag.name])) {
	      this.buffer('<');
	      bufferName();
	      this.visitAttributes(tag.attrs, tag.attributeBlocks.slice());
	      this.terse
	        ? this.buffer('>')
	        : this.buffer('/>');
	      // if it is non-empty throw an error
	      if (tag.block &&
	          !(tag.block.type === 'Block' && tag.block.nodes.length === 0) &&
	          tag.block.nodes.some(function (tag) {
	            return tag.type !== 'Text' || !/^\s*$/.test(tag.val)
	          })) {
	        throw errorAtNode(tag, new Error(name + ' is self closing and should not have content.'));
	      }
	    } else {
	      // Optimize attributes buffering
	      this.buffer('<');
	      bufferName();
	      this.visitAttributes(tag.attrs, tag.attributeBlocks.slice());
	      this.buffer('>');
	      if (tag.code) this.visitCode(tag.code);
	      this.visit(tag.block);

	      // pretty print
	      if (pp && !tag.isInline() && 'pre' != tag.name && !tag.canInline())
	        this.prettyIndent(0, true);

	      this.buffer('</');
	      bufferName();
	      this.buffer('>');
	    }

	    if ('pre' == tag.name) this.escape = false;

	    this.indents--;
	  },

	  /**
	   * Visit `filter`, throwing when the filter does not exist.
	   *
	   * @param {Filter} filter
	   * @api public
	   */

	  visitFilter: function(filter){
	    var text = filter.block.nodes.map(
	      function(node){ return node.val; }
	    ).join('\n');
	    filter.attrs.filename = this.options.filename;
	    try {
	      this.buffer(filters(filter.name, text, filter.attrs), true);
	    } catch (err) {
	      throw errorAtNode(filter, err);
	    }
	  },

	  /**
	   * Visit `text` node.
	   *
	   * @param {Text} text
	   * @api public
	   */

	  visitText: function(text){
	    this.buffer(text.val, true);
	  },

	  /**
	   * Visit a `comment`, only buffering when the buffer flag is set.
	   *
	   * @param {Comment} comment
	   * @api public
	   */

	  visitComment: function(comment){
	    if (!comment.buffer) return;
	    if (this.pp) this.prettyIndent(1, true);
	    this.buffer('<!--' + comment.val + '-->');
	  },

	  /**
	   * Visit a `BlockComment`.
	   *
	   * @param {Comment} comment
	   * @api public
	   */

	  visitBlockComment: function(comment){
	    if (!comment.buffer) return;
	    if (this.pp) this.prettyIndent(1, true);
	    this.buffer('<!--' + comment.val);
	    this.visit(comment.block);
	    if (this.pp) this.prettyIndent(1, true);
	    this.buffer('-->');
	  },

	  /**
	   * Visit `code`, respecting buffer / escape flags.
	   * If the code is followed by a block, wrap it in
	   * a self-calling function.
	   *
	   * @param {Code} code
	   * @api public
	   */

	  visitCode: function(code){
	    // Wrap code blocks with {}.
	    // we only wrap unbuffered code blocks ATM
	    // since they are usually flow control

	    // Buffer code
	    if (code.buffer) {
	      var val = code.val.trim();
	      val = 'null == (jade_interp = '+val+') ? "" : jade_interp';
	      if (code.escape) val = 'jade.escape(' + val + ')';
	      this.bufferExpression(val);
	    } else {
	      this.buf.push(code.val);
	    }

	    // Block support
	    if (code.block) {
	      if (!code.buffer) this.buf.push('{');
	      this.visit(code.block);
	      if (!code.buffer) this.buf.push('}');
	    }
	  },

	  /**
	   * Visit `each` block.
	   *
	   * @param {Each} each
	   * @api public
	   */

	  visitEach: function(each){
	    this.buf.push(''
	      + '// iterate ' + each.obj + '\n'
	      + ';(function(){\n'
	      + '  var $$obj = ' + each.obj + ';\n'
	      + '  if (\'number\' == typeof $$obj.length) {\n');

	    if (each.alternative) {
	      this.buf.push('  if ($$obj.length) {');
	    }

	    this.buf.push(''
	      + '    for (var ' + each.key + ' = 0, $$l = $$obj.length; ' + each.key + ' < $$l; ' + each.key + '++) {\n'
	      + '      var ' + each.val + ' = $$obj[' + each.key + '];\n');

	    this.visit(each.block);

	    this.buf.push('    }\n');

	    if (each.alternative) {
	      this.buf.push('  } else {');
	      this.visit(each.alternative);
	      this.buf.push('  }');
	    }

	    this.buf.push(''
	      + '  } else {\n'
	      + '    var $$l = 0;\n'
	      + '    for (var ' + each.key + ' in $$obj) {\n'
	      + '      $$l++;'
	      + '      var ' + each.val + ' = $$obj[' + each.key + '];\n');

	    this.visit(each.block);

	    this.buf.push('    }\n');
	    if (each.alternative) {
	      this.buf.push('    if ($$l === 0) {');
	      this.visit(each.alternative);
	      this.buf.push('    }');
	    }
	    this.buf.push('  }\n}).call(this);\n');
	  },

	  /**
	   * Visit `attrs`.
	   *
	   * @param {Array} attrs
	   * @api public
	   */

	  visitAttributes: function(attrs, attributeBlocks){
	    if (attributeBlocks.length) {
	      if (attrs.length) {
	        var val = this.attrs(attrs);
	        attributeBlocks.unshift(val);
	      }
	      this.bufferExpression('jade.attrs(jade.merge([' + attributeBlocks.join(',') + ']), ' + utils.stringify(this.terse) + ')');
	    } else if (attrs.length) {
	      this.attrs(attrs, true);
	    }
	  },

	  /**
	   * Compile attributes.
	   */

	  attrs: function(attrs, buffer){
	    var buf = [];
	    var classes = [];
	    var classEscaping = [];

	    attrs.forEach(function(attr){
	      var key = attr.name;
	      var escaped = attr.escaped;

	      if (key === 'class') {
	        classes.push(attr.val);
	        classEscaping.push(attr.escaped);
	      } else if (isConstant(attr.val)) {
	        if (buffer) {
	          this.buffer(runtime.attr(key, toConstant(attr.val), escaped, this.terse));
	        } else {
	          var val = toConstant(attr.val);
	          if (key === 'style') val = runtime.style(val);
	          if (escaped && !(key.indexOf('data') === 0 && typeof val !== 'string')) {
	            val = runtime.escape(val);
	          }
	          buf.push(utils.stringify(key) + ': ' + utils.stringify(val));
	        }
	      } else {
	        if (buffer) {
	          this.bufferExpression('jade.attr("' + key + '", ' + attr.val + ', ' + utils.stringify(escaped) + ', ' + utils.stringify(this.terse) + ')');
	        } else {
	          var val = attr.val;
	          if (key === 'style') {
	            val = 'jade.style(' + val + ')';
	          }
	          if (escaped && !(key.indexOf('data') === 0)) {
	            val = 'jade.escape(' + val + ')';
	          } else if (escaped) {
	            val = '(typeof (jade_interp = ' + val + ') == "string" ? jade.escape(jade_interp) : jade_interp)';
	          }
	          buf.push(utils.stringify(key) + ': ' + val);
	        }
	      }
	    }.bind(this));
	    if (buffer) {
	      if (classes.every(isConstant)) {
	        this.buffer(runtime.cls(classes.map(toConstant), classEscaping));
	      } else {
	        this.bufferExpression('jade.cls([' + classes.join(',') + '], ' + utils.stringify(classEscaping) + ')');
	      }
	    } else if (classes.length) {
	      if (classes.every(isConstant)) {
	        classes = utils.stringify(runtime.joinClasses(classes.map(toConstant).map(runtime.joinClasses).map(function (cls, i) {
	          return classEscaping[i] ? runtime.escape(cls) : cls;
	        })));
	      } else {
	        classes = '(jade_interp = ' + utils.stringify(classEscaping) + ',' +
	          ' jade.joinClasses([' + classes.join(',') + '].map(jade.joinClasses).map(function (cls, i) {' +
	          '   return jade_interp[i] ? jade.escape(cls) : cls' +
	          ' }))' +
	          ')';
	      }
	      if (classes.length)
	        buf.push('"class": ' + classes);
	    }
	    return '{' + buf.join(',') + '}';
	  }
	};


/***/ },
/* 38 */
/***/ function(module, exports) {

	'use strict';

	module.exports = {
	    'default': '<!DOCTYPE html>'
	  , 'xml': '<?xml version="1.0" encoding="utf-8" ?>'
	  , 'transitional': '<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">'
	  , 'strict': '<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">'
	  , 'frameset': '<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Frameset//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-frameset.dtd">'
	  , '1.1': '<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">'
	  , 'basic': '<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML Basic 1.1//EN" "http://www.w3.org/TR/xhtml-basic/xhtml-basic11.dtd">'
	  , 'mobile': '<!DOCTYPE html PUBLIC "-//WAPFORUM//DTD XHTML Mobile 1.2//EN" "http://www.openmobilealliance.org/tech/DTD/xhtml-mobile12.dtd">'
	};

/***/ },
/* 39 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	/**
	 * Merge two attribute objects giving precedence
	 * to values in object `b`. Classes are special-cased
	 * allowing for arrays and merging/joining appropriately
	 * resulting in a string.
	 *
	 * @param {Object} a
	 * @param {Object} b
	 * @return {Object} a
	 * @api private
	 */

	exports.merge = function merge(a, b) {
	  if (arguments.length === 1) {
	    var attrs = a[0];
	    for (var i = 1; i < a.length; i++) {
	      attrs = merge(attrs, a[i]);
	    }
	    return attrs;
	  }
	  var ac = a['class'];
	  var bc = b['class'];

	  if (ac || bc) {
	    ac = ac || [];
	    bc = bc || [];
	    if (!Array.isArray(ac)) ac = [ac];
	    if (!Array.isArray(bc)) bc = [bc];
	    a['class'] = ac.concat(bc).filter(nulls);
	  }

	  for (var key in b) {
	    if (key != 'class') {
	      a[key] = b[key];
	    }
	  }

	  return a;
	};

	/**
	 * Filter null `val`s.
	 *
	 * @param {*} val
	 * @return {Boolean}
	 * @api private
	 */

	function nulls(val) {
	  return val != null && val !== '';
	}

	/**
	 * join array as classes.
	 *
	 * @param {*} val
	 * @return {String}
	 */
	exports.joinClasses = joinClasses;
	function joinClasses(val) {
	  return (Array.isArray(val) ? val.map(joinClasses) :
	    (val && typeof val === 'object') ? Object.keys(val).filter(function (key) { return val[key]; }) :
	    [val]).filter(nulls).join(' ');
	}

	/**
	 * Render the given classes.
	 *
	 * @param {Array} classes
	 * @param {Array.<Boolean>} escaped
	 * @return {String}
	 */
	exports.cls = function cls(classes, escaped) {
	  var buf = [];
	  for (var i = 0; i < classes.length; i++) {
	    if (escaped && escaped[i]) {
	      buf.push(exports.escape(joinClasses([classes[i]])));
	    } else {
	      buf.push(joinClasses(classes[i]));
	    }
	  }
	  var text = joinClasses(buf);
	  if (text.length) {
	    return ' class="' + text + '"';
	  } else {
	    return '';
	  }
	};


	exports.style = function (val) {
	  if (val && typeof val === 'object') {
	    return Object.keys(val).map(function (style) {
	      return style + ':' + val[style];
	    }).join(';');
	  } else {
	    return val;
	  }
	};
	/**
	 * Render the given attribute.
	 *
	 * @param {String} key
	 * @param {String} val
	 * @param {Boolean} escaped
	 * @param {Boolean} terse
	 * @return {String}
	 */
	exports.attr = function attr(key, val, escaped, terse) {
	  if (key === 'style') {
	    val = exports.style(val);
	  }
	  if ('boolean' == typeof val || null == val) {
	    if (val) {
	      return ' ' + (terse ? key : key + '="' + key + '"');
	    } else {
	      return '';
	    }
	  } else if (0 == key.indexOf('data') && 'string' != typeof val) {
	    if (JSON.stringify(val).indexOf('&') !== -1) {
	      console.warn('Since Jade 2.0.0, ampersands (`&`) in data attributes ' +
	                   'will be escaped to `&amp;`');
	    };
	    if (val && typeof val.toISOString === 'function') {
	      console.warn('Jade will eliminate the double quotes around dates in ' +
	                   'ISO form after 2.0.0');
	    }
	    return ' ' + key + "='" + JSON.stringify(val).replace(/'/g, '&apos;') + "'";
	  } else if (escaped) {
	    if (val && typeof val.toISOString === 'function') {
	      console.warn('Jade will stringify dates in ISO form after 2.0.0');
	    }
	    return ' ' + key + '="' + exports.escape(val) + '"';
	  } else {
	    if (val && typeof val.toISOString === 'function') {
	      console.warn('Jade will stringify dates in ISO form after 2.0.0');
	    }
	    return ' ' + key + '="' + val + '"';
	  }
	};

	/**
	 * Render the given attributes object.
	 *
	 * @param {Object} obj
	 * @param {Object} escaped
	 * @return {String}
	 */
	exports.attrs = function attrs(obj, terse){
	  var buf = [];

	  var keys = Object.keys(obj);

	  if (keys.length) {
	    for (var i = 0; i < keys.length; ++i) {
	      var key = keys[i]
	        , val = obj[key];

	      if ('class' == key) {
	        if (val = joinClasses(val)) {
	          buf.push(' ' + key + '="' + val + '"');
	        }
	      } else {
	        buf.push(exports.attr(key, val, false, terse));
	      }
	    }
	  }

	  return buf.join('');
	};

	/**
	 * Escape the given string of `html`.
	 *
	 * @param {String} html
	 * @return {String}
	 * @api private
	 */

	var jade_encode_html_rules = {
	  '&': '&amp;',
	  '<': '&lt;',
	  '>': '&gt;',
	  '"': '&quot;'
	};
	var jade_match_html = /[&<>"]/g;

	function jade_encode_char(c) {
	  return jade_encode_html_rules[c] || c;
	}

	exports.escape = jade_escape;
	function jade_escape(html){
	  var result = String(html).replace(jade_match_html, jade_encode_char);
	  if (result === '' + html) return html;
	  else return result;
	};

	/**
	 * Re-throw the given `err` in context to the
	 * the jade in `filename` at the given `lineno`.
	 *
	 * @param {Error} err
	 * @param {String} filename
	 * @param {String} lineno
	 * @api private
	 */

	exports.rethrow = function rethrow(err, filename, lineno, str){
	  if (!(err instanceof Error)) throw err;
	  if ((typeof window != 'undefined' || !filename) && !str) {
	    err.message += ' on line ' + lineno;
	    throw err;
	  }
	  try {
	    str = str || __webpack_require__(36).readFileSync(filename, 'utf8')
	  } catch (ex) {
	    rethrow(err, null, lineno)
	  }
	  var context = 3
	    , lines = str.split('\n')
	    , start = Math.max(lineno - context, 0)
	    , end = Math.min(lines.length, lineno + context);

	  // Error context
	  var context = lines.slice(start, end).map(function(line, i){
	    var curr = i + start + 1;
	    return (curr == lineno ? '  > ' : '    ')
	      + curr
	      + '| '
	      + line;
	  }).join('\n');

	  // Alter exception message
	  err.path = filename;
	  err.message = (filename || 'Jade') + ':' + lineno
	    + '\n' + context + '\n\n' + err.message;
	  throw err;
	};

	exports.DebugItem = function DebugItem(lineno, filename) {
	  this.lineno = lineno;
	  this.filename = filename;
	}


/***/ },
/* 40 */
/***/ function(module, exports) {

	/**
	 * This file automatically generated from `pre-publish.js`.
	 * Do not manually edit.
	 */

	module.exports = {
	  "area": true,
	  "base": true,
	  "br": true,
	  "col": true,
	  "embed": true,
	  "hr": true,
	  "img": true,
	  "input": true,
	  "keygen": true,
	  "link": true,
	  "menuitem": true,
	  "meta": true,
	  "param": true,
	  "source": true,
	  "track": true,
	  "wbr": true
	};


/***/ },
/* 41 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var detect = __webpack_require__(42);
	var acorn = __webpack_require__(43);
	var walk = __webpack_require__(44);

	// polyfill for https://github.com/marijnh/acorn/pull/231
	walk.base.ExportNamedDeclaration = walk.base.ExportDefaultDeclaration = function (node, st, c) {
	  return c(node.declaration, st);
	};
	walk.base.ImportDefaultSpecifier = walk.base.ImportNamespaceSpecifier = function () {};

	// hacky fix for https://github.com/marijnh/acorn/issues/227
	function reallyParse(source) {
	  try {
	    return acorn.parse(source, {
	      ecmaVersion: 5,
	      allowReturnOutsideFunction: true
	    });
	  } catch (ex) {
	    if (ex.name !== 'SyntaxError') {
	      throw ex;
	    }
	    return acorn.parse(source, {
	      ecmaVersion: 6,
	      allowReturnOutsideFunction: true
	    });
	  }
	}

	module.exports = addWith

	/**
	 * Mimic `with` as far as possible but at compile time
	 *
	 * @param {String} obj The object part of a with expression
	 * @param {String} src The body of the with expression
	 * @param {Array.<String>} exclude A list of variable names to explicitly exclude
	 */
	function addWith(obj, src, exclude) {
	  obj = obj + ''
	  src = src + ''
	  exclude = exclude || []
	  exclude = exclude.concat(detect(obj).map(function (global) { return global.name; }))
	  var vars = detect(src).map(function (global) { return global.name; })
	    .filter(function (v) {
	      return exclude.indexOf(v) === -1
	    })

	  if (vars.length === 0) return src

	  var declareLocal = ''
	  var local = 'locals_for_with'
	  var result = 'result_of_with'
	  if (/^[a-zA-Z0-9$_]+$/.test(obj)) {
	    local = obj
	  } else {
	    while (vars.indexOf(local) != -1 || exclude.indexOf(local) != -1) {
	      local += '_'
	    }
	    declareLocal = 'var ' + local + ' = (' + obj + ')'
	  }
	  while (vars.indexOf(result) != -1 || exclude.indexOf(result) != -1) {
	    result += '_'
	  }

	  var inputVars = vars.map(function (v) {
	    return JSON.stringify(v) + ' in ' + local + '?' +
	      local + '.' + v + ':' +
	      'typeof ' + v + '!=="undefined"?' + v + ':undefined'
	  })

	  src = '(function (' + vars.join(', ') + ') {' +
	    src +
	    '}.call(this' + inputVars.map(function (v) { return ',' + v; }).join('') + '))'

	  return ';' + declareLocal + ';' + unwrapReturns(src, result) + ';'
	}

	/**
	 * Take a self calling function, and unwrap it such that return inside the function
	 * results in return outside the function
	 *
	 * @param {String} src    Some JavaScript code representing a self-calling function
	 * @param {String} result A temporary variable to store the result in
	 */
	function unwrapReturns(src, result) {
	  var originalSource = src
	  var hasReturn = false
	  var ast = reallyParse(src)
	  var ref
	  src = src.split('')

	  // get a reference to the function that was inserted to add an inner context
	  if ((ref = ast.body).length !== 1
	   || (ref = ref[0]).type !== 'ExpressionStatement'
	   || (ref = ref.expression).type !== 'CallExpression'
	   || (ref = ref.callee).type !== 'MemberExpression' || ref.computed !== false || ref.property.name !== 'call'
	   || (ref = ref.object).type !== 'FunctionExpression')
	    throw new Error('AST does not seem to represent a self-calling function')
	  var fn = ref

	  walk.recursive(ast, null, {
	    Function: function (node, st, c) {
	      if (node === fn) {
	        c(node.body, st, "ScopeBody");
	      }
	    },
	    ReturnStatement: function (node) {
	      hasReturn = true
	      replace(node, 'return {value: ' + source(node.argument) + '};');
	    }
	  });
	  function source(node) {
	    return src.slice(node.start, node.end).join('')
	  }
	  function replace(node, str) {
	    for (var i = node.start; i < node.end; i++) {
	      src[i] = ''
	    }
	    src[node.start] = str
	  }
	  if (!hasReturn) return originalSource
	  else return 'var ' + result + '=' + src.join('') + ';if (' + result + ') return ' + result + '.value'
	}


/***/ },
/* 42 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var acorn = __webpack_require__(34);
	var walk = __webpack_require__(35);

	function isScope(node) {
	  return node.type === 'FunctionExpression' || node.type === 'FunctionDeclaration' || node.type === 'ArrowFunctionExpression' || node.type === 'Program';
	}
	function isBlockScope(node) {
	  return node.type === 'BlockStatement' || isScope(node);
	}

	function declaresArguments(node) {
	  return node.type === 'FunctionExpression' || node.type === 'FunctionDeclaration';
	}

	function declaresThis(node) {
	  return node.type === 'FunctionExpression' || node.type === 'FunctionDeclaration';
	}

	function reallyParse(source) {
	  try {
	    return acorn.parse(source, {
	      ecmaVersion: 6,
	      allowReturnOutsideFunction: true,
	      allowImportExportEverywhere: true,
	      allowHashBang: true
	    });
	  } catch (ex) {
	    return acorn.parse(source, {
	      ecmaVersion: 5,
	      allowReturnOutsideFunction: true,
	      allowImportExportEverywhere: true,
	      allowHashBang: true
	    });
	  }
	}
	module.exports = findGlobals;
	module.exports.parse = reallyParse;
	function findGlobals(source) {
	  var globals = [];
	  var ast;
	  // istanbul ignore else
	  if (typeof source === 'string') {
	    ast = reallyParse(source);
	  } else {
	    ast = source;
	  }
	  // istanbul ignore if
	  if (!(ast && typeof ast === 'object' && ast.type === 'Program')) {
	    throw new TypeError('Source must be either a string of JavaScript or an acorn AST');
	  }
	  var declareFunction = function (node) {
	    var fn = node;
	    fn.locals = fn.locals || {};
	    node.params.forEach(function (node) {
	      declarePattern(node, fn);
	    });
	    if (node.id) {
	      fn.locals[node.id.name] = true;
	    }
	  }
	  var declarePattern = function (node, parent) {
	    switch (node.type) {
	      case 'Identifier':
	        parent.locals[node.name] = true;
	        break;
	      case 'ObjectPattern':
	        node.properties.forEach(function (node) {
	          declarePattern(node.value, parent);
	        });
	        break;
	      case 'ArrayPattern':
	        node.elements.forEach(function (node) {
	          if (node) declarePattern(node, parent);
	        });
	        break;
	      case 'RestElement':
	        declarePattern(node.argument, parent);
	        break;
	      case 'AssignmentPattern':
	        declarePattern(node.left, parent);
	        break;
	      // istanbul ignore next
	      default:
	        throw new Error('Unrecognized pattern type: ' + node.type);
	    }
	  }
	  var declareModuleSpecifier = function (node, parents) {
	    ast.locals = ast.locals || {};
	    ast.locals[node.local.name] = true;
	  }
	  walk.ancestor(ast, {
	    'VariableDeclaration': function (node, parents) {
	      var parent = null;
	      for (var i = parents.length - 1; i >= 0 && parent === null; i--) {
	        if (node.kind === 'var' ? isScope(parents[i]) : isBlockScope(parents[i])) {
	          parent = parents[i];
	        }
	      }
	      parent.locals = parent.locals || {};
	      node.declarations.forEach(function (declaration) {
	        declarePattern(declaration.id, parent);
	      });
	    },
	    'FunctionDeclaration': function (node, parents) {
	      var parent = null;
	      for (var i = parents.length - 2; i >= 0 && parent === null; i--) {
	        if (isScope(parents[i])) {
	          parent = parents[i];
	        }
	      }
	      parent.locals = parent.locals || {};
	      parent.locals[node.id.name] = true;
	      declareFunction(node);
	    },
	    'Function': declareFunction,
	    'ClassDeclaration': function (node, parents) {
	      var parent = null;
	      for (var i = parents.length - 2; i >= 0 && parent === null; i--) {
	        if (isScope(parents[i])) {
	          parent = parents[i];
	        }
	      }
	      parent.locals = parent.locals || {};
	      parent.locals[node.id.name] = true;
	    },
	    'TryStatement': function (node) {
	      if (node.handler === null) return;
	      node.handler.body.locals = node.handler.body.locals || {};
	      node.handler.body.locals[node.handler.param.name] = true;
	    },
	    'ImportDefaultSpecifier': declareModuleSpecifier,
	    'ImportSpecifier': declareModuleSpecifier,
	    'ImportNamespaceSpecifier': declareModuleSpecifier
	  });
	  function identifier(node, parents) {
	    var name = node.name;
	    if (name === 'undefined') return;
	    for (var i = 0; i < parents.length; i++) {
	      if (name === 'arguments' && declaresArguments(parents[i])) {
	        return;
	      }
	      if (parents[i].locals && name in parents[i].locals) {
	        return;
	      }
	    }
	    if (
	      parents[parents.length - 2] &&
	      parents[parents.length - 2].type === 'TryStatement' &&
	      parents[parents.length - 2].handler &&
	      node === parents[parents.length - 2].handler.param
	    ) {
	      return;
	    }
	    node.parents = parents;
	    globals.push(node);
	  }
	  walk.ancestor(ast, {
	    'VariablePattern': identifier,
	    'Identifier': identifier,
	    'ThisExpression': function (node, parents) {
	      for (var i = 0; i < parents.length; i++) {
	        if (declaresThis(parents[i])) {
	          return;
	        }
	      }
	      node.parents = parents;
	      globals.push(node);
	    }
	  });
	  var groupedGlobals = {};
	  globals.forEach(function (node) {
	    groupedGlobals[node.name] = (groupedGlobals[node.name] || []);
	    groupedGlobals[node.name].push(node);
	  });
	  return Object.keys(groupedGlobals).sort().map(function (name) {
	    return {name: name, nodes: groupedGlobals[name]};
	  });
	}


/***/ },
/* 43 */
/***/ function(module, exports, __webpack_require__) {

	var require;var require;/* WEBPACK VAR INJECTION */(function(global) {(function(f){if(true){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}g.acorn = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return require(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(_dereq_,module,exports){


	// The main exported interface (under `self.acorn` when in the
	// browser) is a `parse` function that takes a code string and
	// returns an abstract syntax tree as specified by [Mozilla parser
	// API][api].
	//
	// [api]: https://developer.mozilla.org/en-US/docs/SpiderMonkey/Parser_API

	"use strict";

	exports.parse = parse;

	// This function tries to parse a single expression at a given
	// offset in a string. Useful for parsing mixed-language formats
	// that embed JavaScript expressions.

	exports.parseExpressionAt = parseExpressionAt;

	// Acorn is organized as a tokenizer and a recursive-descent parser.
	// The `tokenize` export provides an interface to the tokenizer.

	exports.tokenizer = tokenizer;
	exports.__esModule = true;
	// Acorn is a tiny, fast JavaScript parser written in JavaScript.
	//
	// Acorn was written by Marijn Haverbeke, Ingvar Stepanyan, and
	// various contributors and released under an MIT license.
	//
	// Git repositories for Acorn are available at
	//
	//     http://marijnhaverbeke.nl/git/acorn
	//     https://github.com/marijnh/acorn.git
	//
	// Please use the [github bug tracker][ghbt] to report issues.
	//
	// [ghbt]: https://github.com/marijnh/acorn/issues
	//
	// This file defines the main parser interface. The library also comes
	// with a [error-tolerant parser][dammit] and an
	// [abstract syntax tree walker][walk], defined in other files.
	//
	// [dammit]: acorn_loose.js
	// [walk]: util/walk.js

	var _state = _dereq_("./state");

	var Parser = _state.Parser;

	var _options = _dereq_("./options");

	var getOptions = _options.getOptions;

	_dereq_("./parseutil");

	_dereq_("./statement");

	_dereq_("./lval");

	_dereq_("./expression");

	exports.Parser = _state.Parser;
	exports.plugins = _state.plugins;
	exports.defaultOptions = _options.defaultOptions;

	var _location = _dereq_("./location");

	exports.SourceLocation = _location.SourceLocation;
	exports.getLineInfo = _location.getLineInfo;
	exports.Node = _dereq_("./node").Node;

	var _tokentype = _dereq_("./tokentype");

	exports.TokenType = _tokentype.TokenType;
	exports.tokTypes = _tokentype.types;

	var _tokencontext = _dereq_("./tokencontext");

	exports.TokContext = _tokencontext.TokContext;
	exports.tokContexts = _tokencontext.types;

	var _identifier = _dereq_("./identifier");

	exports.isIdentifierChar = _identifier.isIdentifierChar;
	exports.isIdentifierStart = _identifier.isIdentifierStart;
	exports.Token = _dereq_("./tokenize").Token;

	var _whitespace = _dereq_("./whitespace");

	exports.isNewLine = _whitespace.isNewLine;
	exports.lineBreak = _whitespace.lineBreak;
	exports.lineBreakG = _whitespace.lineBreakG;
	var version = "1.2.2";exports.version = version;

	function parse(input, options) {
	  var p = parser(options, input);
	  var startPos = p.pos,
	      startLoc = p.options.locations && p.curPosition();
	  p.nextToken();
	  return p.parseTopLevel(p.options.program || p.startNodeAt(startPos, startLoc));
	}

	function parseExpressionAt(input, pos, options) {
	  var p = parser(options, input, pos);
	  p.nextToken();
	  return p.parseExpression();
	}

	function tokenizer(input, options) {
	  return parser(options, input);
	}

	function parser(options, input) {
	  return new Parser(getOptions(options), String(input));
	}

	},{"./expression":6,"./identifier":7,"./location":8,"./lval":9,"./node":10,"./options":11,"./parseutil":12,"./state":13,"./statement":14,"./tokencontext":15,"./tokenize":16,"./tokentype":17,"./whitespace":19}],2:[function(_dereq_,module,exports){
	if (typeof Object.create === 'function') {
	  // implementation from standard node.js 'util' module
	  module.exports = function inherits(ctor, superCtor) {
	    ctor.super_ = superCtor
	    ctor.prototype = Object.create(superCtor.prototype, {
	      constructor: {
	        value: ctor,
	        enumerable: false,
	        writable: true,
	        configurable: true
	      }
	    });
	  };
	} else {
	  // old school shim for old browsers
	  module.exports = function inherits(ctor, superCtor) {
	    ctor.super_ = superCtor
	    var TempCtor = function () {}
	    TempCtor.prototype = superCtor.prototype
	    ctor.prototype = new TempCtor()
	    ctor.prototype.constructor = ctor
	  }
	}

	},{}],3:[function(_dereq_,module,exports){
	// shim for using process in browser

	var process = module.exports = {};
	var queue = [];
	var draining = false;

	function drainQueue() {
	    if (draining) {
	        return;
	    }
	    draining = true;
	    var currentQueue;
	    var len = queue.length;
	    while(len) {
	        currentQueue = queue;
	        queue = [];
	        var i = -1;
	        while (++i < len) {
	            currentQueue[i]();
	        }
	        len = queue.length;
	    }
	    draining = false;
	}
	process.nextTick = function (fun) {
	    queue.push(fun);
	    if (!draining) {
	        setTimeout(drainQueue, 0);
	    }
	};

	process.title = 'browser';
	process.browser = true;
	process.env = {};
	process.argv = [];
	process.version = ''; // empty string to avoid regexp issues
	process.versions = {};

	function noop() {}

	process.on = noop;
	process.addListener = noop;
	process.once = noop;
	process.off = noop;
	process.removeListener = noop;
	process.removeAllListeners = noop;
	process.emit = noop;

	process.binding = function (name) {
	    throw new Error('process.binding is not supported');
	};

	// TODO(shtylman)
	process.cwd = function () { return '/' };
	process.chdir = function (dir) {
	    throw new Error('process.chdir is not supported');
	};
	process.umask = function() { return 0; };

	},{}],4:[function(_dereq_,module,exports){
	module.exports = function isBuffer(arg) {
	  return arg && typeof arg === 'object'
	    && typeof arg.copy === 'function'
	    && typeof arg.fill === 'function'
	    && typeof arg.readUInt8 === 'function';
	}
	},{}],5:[function(_dereq_,module,exports){
	(function (process,global){
	// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.

	var formatRegExp = /%[sdj%]/g;
	exports.format = function(f) {
	  if (!isString(f)) {
	    var objects = [];
	    for (var i = 0; i < arguments.length; i++) {
	      objects.push(inspect(arguments[i]));
	    }
	    return objects.join(' ');
	  }

	  var i = 1;
	  var args = arguments;
	  var len = args.length;
	  var str = String(f).replace(formatRegExp, function(x) {
	    if (x === '%%') return '%';
	    if (i >= len) return x;
	    switch (x) {
	      case '%s': return String(args[i++]);
	      case '%d': return Number(args[i++]);
	      case '%j':
	        try {
	          return JSON.stringify(args[i++]);
	        } catch (_) {
	          return '[Circular]';
	        }
	      default:
	        return x;
	    }
	  });
	  for (var x = args[i]; i < len; x = args[++i]) {
	    if (isNull(x) || !isObject(x)) {
	      str += ' ' + x;
	    } else {
	      str += ' ' + inspect(x);
	    }
	  }
	  return str;
	};


	// Mark that a method should not be used.
	// Returns a modified function which warns once by default.
	// If --no-deprecation is set, then it is a no-op.
	exports.deprecate = function(fn, msg) {
	  // Allow for deprecating things in the process of starting up.
	  if (isUndefined(global.process)) {
	    return function() {
	      return exports.deprecate(fn, msg).apply(this, arguments);
	    };
	  }

	  if (process.noDeprecation === true) {
	    return fn;
	  }

	  var warned = false;
	  function deprecated() {
	    if (!warned) {
	      if (process.throwDeprecation) {
	        throw new Error(msg);
	      } else if (process.traceDeprecation) {
	        console.trace(msg);
	      } else {
	        console.error(msg);
	      }
	      warned = true;
	    }
	    return fn.apply(this, arguments);
	  }

	  return deprecated;
	};


	var debugs = {};
	var debugEnviron;
	exports.debuglog = function(set) {
	  if (isUndefined(debugEnviron))
	    debugEnviron = process.env.NODE_DEBUG || '';
	  set = set.toUpperCase();
	  if (!debugs[set]) {
	    if (new RegExp('\\b' + set + '\\b', 'i').test(debugEnviron)) {
	      var pid = process.pid;
	      debugs[set] = function() {
	        var msg = exports.format.apply(exports, arguments);
	        console.error('%s %d: %s', set, pid, msg);
	      };
	    } else {
	      debugs[set] = function() {};
	    }
	  }
	  return debugs[set];
	};


	/**
	 * Echos the value of a value. Trys to print the value out
	 * in the best way possible given the different types.
	 *
	 * @param {Object} obj The object to print out.
	 * @param {Object} opts Optional options object that alters the output.
	 */
	/* legacy: obj, showHidden, depth, colors*/
	function inspect(obj, opts) {
	  // default options
	  var ctx = {
	    seen: [],
	    stylize: stylizeNoColor
	  };
	  // legacy...
	  if (arguments.length >= 3) ctx.depth = arguments[2];
	  if (arguments.length >= 4) ctx.colors = arguments[3];
	  if (isBoolean(opts)) {
	    // legacy...
	    ctx.showHidden = opts;
	  } else if (opts) {
	    // got an "options" object
	    exports._extend(ctx, opts);
	  }
	  // set default options
	  if (isUndefined(ctx.showHidden)) ctx.showHidden = false;
	  if (isUndefined(ctx.depth)) ctx.depth = 2;
	  if (isUndefined(ctx.colors)) ctx.colors = false;
	  if (isUndefined(ctx.customInspect)) ctx.customInspect = true;
	  if (ctx.colors) ctx.stylize = stylizeWithColor;
	  return formatValue(ctx, obj, ctx.depth);
	}
	exports.inspect = inspect;


	// http://en.wikipedia.org/wiki/ANSI_escape_code#graphics
	inspect.colors = {
	  'bold' : [1, 22],
	  'italic' : [3, 23],
	  'underline' : [4, 24],
	  'inverse' : [7, 27],
	  'white' : [37, 39],
	  'grey' : [90, 39],
	  'black' : [30, 39],
	  'blue' : [34, 39],
	  'cyan' : [36, 39],
	  'green' : [32, 39],
	  'magenta' : [35, 39],
	  'red' : [31, 39],
	  'yellow' : [33, 39]
	};

	// Don't use 'blue' not visible on cmd.exe
	inspect.styles = {
	  'special': 'cyan',
	  'number': 'yellow',
	  'boolean': 'yellow',
	  'undefined': 'grey',
	  'null': 'bold',
	  'string': 'green',
	  'date': 'magenta',
	  // "name": intentionally not styling
	  'regexp': 'red'
	};


	function stylizeWithColor(str, styleType) {
	  var style = inspect.styles[styleType];

	  if (style) {
	    return '\u001b[' + inspect.colors[style][0] + 'm' + str +
	           '\u001b[' + inspect.colors[style][1] + 'm';
	  } else {
	    return str;
	  }
	}


	function stylizeNoColor(str, styleType) {
	  return str;
	}


	function arrayToHash(array) {
	  var hash = {};

	  array.forEach(function(val, idx) {
	    hash[val] = true;
	  });

	  return hash;
	}


	function formatValue(ctx, value, recurseTimes) {
	  // Provide a hook for user-specified inspect functions.
	  // Check that value is an object with an inspect function on it
	  if (ctx.customInspect &&
	      value &&
	      isFunction(value.inspect) &&
	      // Filter out the util module, it's inspect function is special
	      value.inspect !== exports.inspect &&
	      // Also filter out any prototype objects using the circular check.
	      !(value.constructor && value.constructor.prototype === value)) {
	    var ret = value.inspect(recurseTimes, ctx);
	    if (!isString(ret)) {
	      ret = formatValue(ctx, ret, recurseTimes);
	    }
	    return ret;
	  }

	  // Primitive types cannot have properties
	  var primitive = formatPrimitive(ctx, value);
	  if (primitive) {
	    return primitive;
	  }

	  // Look up the keys of the object.
	  var keys = Object.keys(value);
	  var visibleKeys = arrayToHash(keys);

	  if (ctx.showHidden) {
	    keys = Object.getOwnPropertyNames(value);
	  }

	  // IE doesn't make error fields non-enumerable
	  // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx
	  if (isError(value)
	      && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {
	    return formatError(value);
	  }

	  // Some type of object without properties can be shortcutted.
	  if (keys.length === 0) {
	    if (isFunction(value)) {
	      var name = value.name ? ': ' + value.name : '';
	      return ctx.stylize('[Function' + name + ']', 'special');
	    }
	    if (isRegExp(value)) {
	      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
	    }
	    if (isDate(value)) {
	      return ctx.stylize(Date.prototype.toString.call(value), 'date');
	    }
	    if (isError(value)) {
	      return formatError(value);
	    }
	  }

	  var base = '', array = false, braces = ['{', '}'];

	  // Make Array say that they are Array
	  if (isArray(value)) {
	    array = true;
	    braces = ['[', ']'];
	  }

	  // Make functions say that they are functions
	  if (isFunction(value)) {
	    var n = value.name ? ': ' + value.name : '';
	    base = ' [Function' + n + ']';
	  }

	  // Make RegExps say that they are RegExps
	  if (isRegExp(value)) {
	    base = ' ' + RegExp.prototype.toString.call(value);
	  }

	  // Make dates with properties first say the date
	  if (isDate(value)) {
	    base = ' ' + Date.prototype.toUTCString.call(value);
	  }

	  // Make error with message first say the error
	  if (isError(value)) {
	    base = ' ' + formatError(value);
	  }

	  if (keys.length === 0 && (!array || value.length == 0)) {
	    return braces[0] + base + braces[1];
	  }

	  if (recurseTimes < 0) {
	    if (isRegExp(value)) {
	      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
	    } else {
	      return ctx.stylize('[Object]', 'special');
	    }
	  }

	  ctx.seen.push(value);

	  var output;
	  if (array) {
	    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
	  } else {
	    output = keys.map(function(key) {
	      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
	    });
	  }

	  ctx.seen.pop();

	  return reduceToSingleString(output, base, braces);
	}


	function formatPrimitive(ctx, value) {
	  if (isUndefined(value))
	    return ctx.stylize('undefined', 'undefined');
	  if (isString(value)) {
	    var simple = '\'' + JSON.stringify(value).replace(/^"|"$/g, '')
	                                             .replace(/'/g, "\\'")
	                                             .replace(/\\"/g, '"') + '\'';
	    return ctx.stylize(simple, 'string');
	  }
	  if (isNumber(value))
	    return ctx.stylize('' + value, 'number');
	  if (isBoolean(value))
	    return ctx.stylize('' + value, 'boolean');
	  // For some reason typeof null is "object", so special case here.
	  if (isNull(value))
	    return ctx.stylize('null', 'null');
	}


	function formatError(value) {
	  return '[' + Error.prototype.toString.call(value) + ']';
	}


	function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
	  var output = [];
	  for (var i = 0, l = value.length; i < l; ++i) {
	    if (hasOwnProperty(value, String(i))) {
	      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
	          String(i), true));
	    } else {
	      output.push('');
	    }
	  }
	  keys.forEach(function(key) {
	    if (!key.match(/^\d+$/)) {
	      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
	          key, true));
	    }
	  });
	  return output;
	}


	function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
	  var name, str, desc;
	  desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };
	  if (desc.get) {
	    if (desc.set) {
	      str = ctx.stylize('[Getter/Setter]', 'special');
	    } else {
	      str = ctx.stylize('[Getter]', 'special');
	    }
	  } else {
	    if (desc.set) {
	      str = ctx.stylize('[Setter]', 'special');
	    }
	  }
	  if (!hasOwnProperty(visibleKeys, key)) {
	    name = '[' + key + ']';
	  }
	  if (!str) {
	    if (ctx.seen.indexOf(desc.value) < 0) {
	      if (isNull(recurseTimes)) {
	        str = formatValue(ctx, desc.value, null);
	      } else {
	        str = formatValue(ctx, desc.value, recurseTimes - 1);
	      }
	      if (str.indexOf('\n') > -1) {
	        if (array) {
	          str = str.split('\n').map(function(line) {
	            return '  ' + line;
	          }).join('\n').substr(2);
	        } else {
	          str = '\n' + str.split('\n').map(function(line) {
	            return '   ' + line;
	          }).join('\n');
	        }
	      }
	    } else {
	      str = ctx.stylize('[Circular]', 'special');
	    }
	  }
	  if (isUndefined(name)) {
	    if (array && key.match(/^\d+$/)) {
	      return str;
	    }
	    name = JSON.stringify('' + key);
	    if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
	      name = name.substr(1, name.length - 2);
	      name = ctx.stylize(name, 'name');
	    } else {
	      name = name.replace(/'/g, "\\'")
	                 .replace(/\\"/g, '"')
	                 .replace(/(^"|"$)/g, "'");
	      name = ctx.stylize(name, 'string');
	    }
	  }

	  return name + ': ' + str;
	}


	function reduceToSingleString(output, base, braces) {
	  var numLinesEst = 0;
	  var length = output.reduce(function(prev, cur) {
	    numLinesEst++;
	    if (cur.indexOf('\n') >= 0) numLinesEst++;
	    return prev + cur.replace(/\u001b\[\d\d?m/g, '').length + 1;
	  }, 0);

	  if (length > 60) {
	    return braces[0] +
	           (base === '' ? '' : base + '\n ') +
	           ' ' +
	           output.join(',\n  ') +
	           ' ' +
	           braces[1];
	  }

	  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
	}


	// NOTE: These type checking functions intentionally don't use `instanceof`
	// because it is fragile and can be easily faked with `Object.create()`.
	function isArray(ar) {
	  return Array.isArray(ar);
	}
	exports.isArray = isArray;

	function isBoolean(arg) {
	  return typeof arg === 'boolean';
	}
	exports.isBoolean = isBoolean;

	function isNull(arg) {
	  return arg === null;
	}
	exports.isNull = isNull;

	function isNullOrUndefined(arg) {
	  return arg == null;
	}
	exports.isNullOrUndefined = isNullOrUndefined;

	function isNumber(arg) {
	  return typeof arg === 'number';
	}
	exports.isNumber = isNumber;

	function isString(arg) {
	  return typeof arg === 'string';
	}
	exports.isString = isString;

	function isSymbol(arg) {
	  return typeof arg === 'symbol';
	}
	exports.isSymbol = isSymbol;

	function isUndefined(arg) {
	  return arg === void 0;
	}
	exports.isUndefined = isUndefined;

	function isRegExp(re) {
	  return isObject(re) && objectToString(re) === '[object RegExp]';
	}
	exports.isRegExp = isRegExp;

	function isObject(arg) {
	  return typeof arg === 'object' && arg !== null;
	}
	exports.isObject = isObject;

	function isDate(d) {
	  return isObject(d) && objectToString(d) === '[object Date]';
	}
	exports.isDate = isDate;

	function isError(e) {
	  return isObject(e) &&
	      (objectToString(e) === '[object Error]' || e instanceof Error);
	}
	exports.isError = isError;

	function isFunction(arg) {
	  return typeof arg === 'function';
	}
	exports.isFunction = isFunction;

	function isPrimitive(arg) {
	  return arg === null ||
	         typeof arg === 'boolean' ||
	         typeof arg === 'number' ||
	         typeof arg === 'string' ||
	         typeof arg === 'symbol' ||  // ES6 symbol
	         typeof arg === 'undefined';
	}
	exports.isPrimitive = isPrimitive;

	exports.isBuffer = _dereq_('./support/isBuffer');

	function objectToString(o) {
	  return Object.prototype.toString.call(o);
	}


	function pad(n) {
	  return n < 10 ? '0' + n.toString(10) : n.toString(10);
	}


	var months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',
	              'Oct', 'Nov', 'Dec'];

	// 26 Feb 16:19:34
	function timestamp() {
	  var d = new Date();
	  var time = [pad(d.getHours()),
	              pad(d.getMinutes()),
	              pad(d.getSeconds())].join(':');
	  return [d.getDate(), months[d.getMonth()], time].join(' ');
	}


	// log is just a thin wrapper to console.log that prepends a timestamp
	exports.log = function() {
	  console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));
	};


	/**
	 * Inherit the prototype methods from one constructor into another.
	 *
	 * The Function.prototype.inherits from lang.js rewritten as a standalone
	 * function (not on Function.prototype). NOTE: If this file is to be loaded
	 * during bootstrapping this function needs to be rewritten using some native
	 * functions as prototype setup using normal JavaScript does not work as
	 * expected during bootstrapping (see mirror.js in r114903).
	 *
	 * @param {function} ctor Constructor function which needs to inherit the
	 *     prototype.
	 * @param {function} superCtor Constructor function to inherit prototype from.
	 */
	exports.inherits = _dereq_('inherits');

	exports._extend = function(origin, add) {
	  // Don't do anything if add isn't an object
	  if (!add || !isObject(add)) return origin;

	  var keys = Object.keys(add);
	  var i = keys.length;
	  while (i--) {
	    origin[keys[i]] = add[keys[i]];
	  }
	  return origin;
	};

	function hasOwnProperty(obj, prop) {
	  return Object.prototype.hasOwnProperty.call(obj, prop);
	}

	}).call(this,_dereq_('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
	},{"./support/isBuffer":4,"_process":3,"inherits":2}],6:[function(_dereq_,module,exports){
	// A recursive descent parser operates by defining functions for all
	// syntactic elements, and recursively calling those, each function
	// advancing the input stream and returning an AST node. Precedence
	// of constructs (for example, the fact that `!x[1]` means `!(x[1])`
	// instead of `(!x)[1]` is handled by the fact that the parser
	// function that parses unary prefix operators is called first, and
	// in turn calls the function that parses `[]` subscripts  that
	// way, it'll receive the node for `x[1]` already parsed, and wraps
	// *that* in the unary operator node.
	//
	// Acorn uses an [operator precedence parser][opp] to handle binary
	// operator precedence, because it is much more compact than using
	// the technique outlined above, which uses different, nesting
	// functions to specify precedence, for all of the ten binary
	// precedence levels that JavaScript defines.
	//
	// [opp]: http://en.wikipedia.org/wiki/Operator-precedence_parser

	"use strict";

	var tt = _dereq_("./tokentype").types;

	var Parser = _dereq_("./state").Parser;

	var reservedWords = _dereq_("./identifier").reservedWords;

	var has = _dereq_("./util").has;

	var pp = Parser.prototype;

	// Check if property name clashes with already added.
	// Object/class getters and setters are not allowed to clash 
	// either with each other or with an init property  and in
	// strict mode, init properties are also not allowed to be repeated.

	pp.checkPropClash = function (prop, propHash) {
	  if (this.options.ecmaVersion >= 6) return;
	  var key = prop.key,
	      name = undefined;
	  switch (key.type) {
	    case "Identifier":
	      name = key.name;break;
	    case "Literal":
	      name = String(key.value);break;
	    default:
	      return;
	  }
	  var kind = prop.kind || "init",
	      other = undefined;
	  if (has(propHash, name)) {
	    other = propHash[name];
	    var isGetSet = kind !== "init";
	    if ((this.strict || isGetSet) && other[kind] || !(isGetSet ^ other.init)) this.raise(key.start, "Redefinition of property");
	  } else {
	    other = propHash[name] = {
	      init: false,
	      get: false,
	      set: false
	    };
	  }
	  other[kind] = true;
	};

	// ### Expression parsing

	// These nest, from the most general expression type at the top to
	// 'atomic', nondivisible expression types at the bottom. Most of
	// the functions will simply let the function(s) below them parse,
	// and, *if* the syntactic construct they handle is present, wrap
	// the AST node that the inner parser gave them in another node.

	// Parse a full expression. The optional arguments are used to
	// forbid the `in` operator (in for loops initalization expressions)
	// and provide reference for storing '=' operator inside shorthand
	// property assignment in contexts where both object expression
	// and object pattern might appear (so it's possible to raise
	// delayed syntax error at correct position).

	pp.parseExpression = function (noIn, refShorthandDefaultPos) {
	  var startPos = this.start,
	      startLoc = this.startLoc;
	  var expr = this.parseMaybeAssign(noIn, refShorthandDefaultPos);
	  if (this.type === tt.comma) {
	    var node = this.startNodeAt(startPos, startLoc);
	    node.expressions = [expr];
	    while (this.eat(tt.comma)) node.expressions.push(this.parseMaybeAssign(noIn, refShorthandDefaultPos));
	    return this.finishNode(node, "SequenceExpression");
	  }
	  return expr;
	};

	// Parse an assignment expression. This includes applications of
	// operators like `+=`.

	pp.parseMaybeAssign = function (noIn, refShorthandDefaultPos, afterLeftParse) {
	  if (this.type == tt._yield && this.inGenerator) return this.parseYield();

	  var failOnShorthandAssign = undefined;
	  if (!refShorthandDefaultPos) {
	    refShorthandDefaultPos = { start: 0 };
	    failOnShorthandAssign = true;
	  } else {
	    failOnShorthandAssign = false;
	  }
	  var startPos = this.start,
	      startLoc = this.startLoc;
	  if (this.type == tt.parenL || this.type == tt.name) this.potentialArrowAt = this.start;
	  var left = this.parseMaybeConditional(noIn, refShorthandDefaultPos);
	  if (afterLeftParse) left = afterLeftParse.call(this, left, startPos, startLoc);
	  if (this.type.isAssign) {
	    var node = this.startNodeAt(startPos, startLoc);
	    node.operator = this.value;
	    node.left = this.type === tt.eq ? this.toAssignable(left) : left;
	    refShorthandDefaultPos.start = 0; // reset because shorthand default was used correctly
	    this.checkLVal(left);
	    this.next();
	    node.right = this.parseMaybeAssign(noIn);
	    return this.finishNode(node, "AssignmentExpression");
	  } else if (failOnShorthandAssign && refShorthandDefaultPos.start) {
	    this.unexpected(refShorthandDefaultPos.start);
	  }
	  return left;
	};

	// Parse a ternary conditional (`?:`) operator.

	pp.parseMaybeConditional = function (noIn, refShorthandDefaultPos) {
	  var startPos = this.start,
	      startLoc = this.startLoc;
	  var expr = this.parseExprOps(noIn, refShorthandDefaultPos);
	  if (refShorthandDefaultPos && refShorthandDefaultPos.start) return expr;
	  if (this.eat(tt.question)) {
	    var node = this.startNodeAt(startPos, startLoc);
	    node.test = expr;
	    node.consequent = this.parseMaybeAssign();
	    this.expect(tt.colon);
	    node.alternate = this.parseMaybeAssign(noIn);
	    return this.finishNode(node, "ConditionalExpression");
	  }
	  return expr;
	};

	// Start the precedence parser.

	pp.parseExprOps = function (noIn, refShorthandDefaultPos) {
	  var startPos = this.start,
	      startLoc = this.startLoc;
	  var expr = this.parseMaybeUnary(refShorthandDefaultPos);
	  if (refShorthandDefaultPos && refShorthandDefaultPos.start) return expr;
	  return this.parseExprOp(expr, startPos, startLoc, -1, noIn);
	};

	// Parse binary operators with the operator precedence parsing
	// algorithm. `left` is the left-hand side of the operator.
	// `minPrec` provides context that allows the function to stop and
	// defer further parser to one of its callers when it encounters an
	// operator that has a lower precedence than the set it is parsing.

	pp.parseExprOp = function (left, leftStartPos, leftStartLoc, minPrec, noIn) {
	  var prec = this.type.binop;
	  if (Array.isArray(leftStartPos)) {
	    if (this.options.locations && noIn === undefined) {
	      // shift arguments to left by one
	      noIn = minPrec;
	      minPrec = leftStartLoc;
	      // flatten leftStartPos
	      leftStartLoc = leftStartPos[1];
	      leftStartPos = leftStartPos[0];
	    }
	  }
	  if (prec != null && (!noIn || this.type !== tt._in)) {
	    if (prec > minPrec) {
	      var node = this.startNodeAt(leftStartPos, leftStartLoc);
	      node.left = left;
	      node.operator = this.value;
	      var op = this.type;
	      this.next();
	      var startPos = this.start,
	          startLoc = this.startLoc;
	      node.right = this.parseExprOp(this.parseMaybeUnary(), startPos, startLoc, prec, noIn);
	      this.finishNode(node, op === tt.logicalOR || op === tt.logicalAND ? "LogicalExpression" : "BinaryExpression");
	      return this.parseExprOp(node, leftStartPos, leftStartLoc, minPrec, noIn);
	    }
	  }
	  return left;
	};

	// Parse unary operators, both prefix and postfix.

	pp.parseMaybeUnary = function (refShorthandDefaultPos) {
	  if (this.type.prefix) {
	    var node = this.startNode(),
	        update = this.type === tt.incDec;
	    node.operator = this.value;
	    node.prefix = true;
	    this.next();
	    node.argument = this.parseMaybeUnary();
	    if (refShorthandDefaultPos && refShorthandDefaultPos.start) this.unexpected(refShorthandDefaultPos.start);
	    if (update) this.checkLVal(node.argument);else if (this.strict && node.operator === "delete" && node.argument.type === "Identifier") this.raise(node.start, "Deleting local variable in strict mode");
	    return this.finishNode(node, update ? "UpdateExpression" : "UnaryExpression");
	  }
	  var startPos = this.start,
	      startLoc = this.startLoc;
	  var expr = this.parseExprSubscripts(refShorthandDefaultPos);
	  if (refShorthandDefaultPos && refShorthandDefaultPos.start) return expr;
	  while (this.type.postfix && !this.canInsertSemicolon()) {
	    var node = this.startNodeAt(startPos, startLoc);
	    node.operator = this.value;
	    node.prefix = false;
	    node.argument = expr;
	    this.checkLVal(expr);
	    this.next();
	    expr = this.finishNode(node, "UpdateExpression");
	  }
	  return expr;
	};

	// Parse call, dot, and `[]`-subscript expressions.

	pp.parseExprSubscripts = function (refShorthandDefaultPos) {
	  var startPos = this.start,
	      startLoc = this.startLoc;
	  var expr = this.parseExprAtom(refShorthandDefaultPos);
	  if (refShorthandDefaultPos && refShorthandDefaultPos.start) return expr;
	  return this.parseSubscripts(expr, startPos, startLoc);
	};

	pp.parseSubscripts = function (base, startPos, startLoc, noCalls) {
	  if (Array.isArray(startPos)) {
	    if (this.options.locations && noCalls === undefined) {
	      // shift arguments to left by one
	      noCalls = startLoc;
	      // flatten startPos
	      startLoc = startPos[1];
	      startPos = startPos[0];
	    }
	  }
	  for (;;) {
	    if (this.eat(tt.dot)) {
	      var node = this.startNodeAt(startPos, startLoc);
	      node.object = base;
	      node.property = this.parseIdent(true);
	      node.computed = false;
	      base = this.finishNode(node, "MemberExpression");
	    } else if (this.eat(tt.bracketL)) {
	      var node = this.startNodeAt(startPos, startLoc);
	      node.object = base;
	      node.property = this.parseExpression();
	      node.computed = true;
	      this.expect(tt.bracketR);
	      base = this.finishNode(node, "MemberExpression");
	    } else if (!noCalls && this.eat(tt.parenL)) {
	      var node = this.startNodeAt(startPos, startLoc);
	      node.callee = base;
	      node.arguments = this.parseExprList(tt.parenR, false);
	      base = this.finishNode(node, "CallExpression");
	    } else if (this.type === tt.backQuote) {
	      var node = this.startNodeAt(startPos, startLoc);
	      node.tag = base;
	      node.quasi = this.parseTemplate();
	      base = this.finishNode(node, "TaggedTemplateExpression");
	    } else {
	      return base;
	    }
	  }
	};

	// Parse an atomic expression  either a single token that is an
	// expression, an expression started by a keyword like `function` or
	// `new`, or an expression wrapped in punctuation like `()`, `[]`,
	// or `{}`.

	pp.parseExprAtom = function (refShorthandDefaultPos) {
	  var node = undefined,
	      canBeArrow = this.potentialArrowAt == this.start;
	  switch (this.type) {
	    case tt._this:
	    case tt._super:
	      var type = this.type === tt._this ? "ThisExpression" : "Super";
	      node = this.startNode();
	      this.next();
	      return this.finishNode(node, type);

	    case tt._yield:
	      if (this.inGenerator) this.unexpected();

	    case tt.name:
	      var startPos = this.start,
	          startLoc = this.startLoc;
	      var id = this.parseIdent(this.type !== tt.name);
	      if (canBeArrow && !this.canInsertSemicolon() && this.eat(tt.arrow)) return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), [id]);
	      return id;

	    case tt.regexp:
	      var value = this.value;
	      node = this.parseLiteral(value.value);
	      node.regex = { pattern: value.pattern, flags: value.flags };
	      return node;

	    case tt.num:case tt.string:
	      return this.parseLiteral(this.value);

	    case tt._null:case tt._true:case tt._false:
	      node = this.startNode();
	      node.value = this.type === tt._null ? null : this.type === tt._true;
	      node.raw = this.type.keyword;
	      this.next();
	      return this.finishNode(node, "Literal");

	    case tt.parenL:
	      return this.parseParenAndDistinguishExpression(canBeArrow);

	    case tt.bracketL:
	      node = this.startNode();
	      this.next();
	      // check whether this is array comprehension or regular array
	      if (this.options.ecmaVersion >= 7 && this.type === tt._for) {
	        return this.parseComprehension(node, false);
	      }
	      node.elements = this.parseExprList(tt.bracketR, true, true, refShorthandDefaultPos);
	      return this.finishNode(node, "ArrayExpression");

	    case tt.braceL:
	      return this.parseObj(false, refShorthandDefaultPos);

	    case tt._function:
	      node = this.startNode();
	      this.next();
	      return this.parseFunction(node, false);

	    case tt._class:
	      return this.parseClass(this.startNode(), false);

	    case tt._new:
	      return this.parseNew();

	    case tt.backQuote:
	      return this.parseTemplate();

	    default:
	      this.unexpected();
	  }
	};

	pp.parseLiteral = function (value) {
	  var node = this.startNode();
	  node.value = value;
	  node.raw = this.input.slice(this.start, this.end);
	  this.next();
	  return this.finishNode(node, "Literal");
	};

	pp.parseParenExpression = function () {
	  this.expect(tt.parenL);
	  var val = this.parseExpression();
	  this.expect(tt.parenR);
	  return val;
	};

	pp.parseParenAndDistinguishExpression = function (canBeArrow) {
	  var startPos = this.start,
	      startLoc = this.startLoc,
	      val = undefined;
	  if (this.options.ecmaVersion >= 6) {
	    this.next();

	    if (this.options.ecmaVersion >= 7 && this.type === tt._for) {
	      return this.parseComprehension(this.startNodeAt(startPos, startLoc), true);
	    }

	    var innerStartPos = this.start,
	        innerStartLoc = this.startLoc;
	    var exprList = [],
	        first = true;
	    var refShorthandDefaultPos = { start: 0 },
	        spreadStart = undefined,
	        innerParenStart = undefined;
	    while (this.type !== tt.parenR) {
	      first ? first = false : this.expect(tt.comma);
	      if (this.type === tt.ellipsis) {
	        spreadStart = this.start;
	        exprList.push(this.parseParenItem(this.parseRest()));
	        break;
	      } else {
	        if (this.type === tt.parenL && !innerParenStart) {
	          innerParenStart = this.start;
	        }
	        exprList.push(this.parseMaybeAssign(false, refShorthandDefaultPos, this.parseParenItem));
	      }
	    }
	    var innerEndPos = this.start,
	        innerEndLoc = this.startLoc;
	    this.expect(tt.parenR);

	    if (canBeArrow && !this.canInsertSemicolon() && this.eat(tt.arrow)) {
	      if (innerParenStart) this.unexpected(innerParenStart);
	      return this.parseParenArrowList(startPos, startLoc, exprList);
	    }

	    if (!exprList.length) this.unexpected(this.lastTokStart);
	    if (spreadStart) this.unexpected(spreadStart);
	    if (refShorthandDefaultPos.start) this.unexpected(refShorthandDefaultPos.start);

	    if (exprList.length > 1) {
	      val = this.startNodeAt(innerStartPos, innerStartLoc);
	      val.expressions = exprList;
	      this.finishNodeAt(val, "SequenceExpression", innerEndPos, innerEndLoc);
	    } else {
	      val = exprList[0];
	    }
	  } else {
	    val = this.parseParenExpression();
	  }

	  if (this.options.preserveParens) {
	    var par = this.startNodeAt(startPos, startLoc);
	    par.expression = val;
	    return this.finishNode(par, "ParenthesizedExpression");
	  } else {
	    return val;
	  }
	};

	pp.parseParenItem = function (item) {
	  return item;
	};

	pp.parseParenArrowList = function (startPos, startLoc, exprList) {
	  return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), exprList);
	};

	// New's precedence is slightly tricky. It must allow its argument
	// to be a `[]` or dot subscript expression, but not a call  at
	// least, not without wrapping it in parentheses. Thus, it uses the

	var empty = [];

	pp.parseNew = function () {
	  var node = this.startNode();
	  var meta = this.parseIdent(true);
	  if (this.options.ecmaVersion >= 6 && this.eat(tt.dot)) {
	    node.meta = meta;
	    node.property = this.parseIdent(true);
	    if (node.property.name !== "target") this.raise(node.property.start, "The only valid meta property for new is new.target");
	    return this.finishNode(node, "MetaProperty");
	  }
	  var startPos = this.start,
	      startLoc = this.startLoc;
	  node.callee = this.parseSubscripts(this.parseExprAtom(), startPos, startLoc, true);
	  if (this.eat(tt.parenL)) node.arguments = this.parseExprList(tt.parenR, false);else node.arguments = empty;
	  return this.finishNode(node, "NewExpression");
	};

	// Parse template expression.

	pp.parseTemplateElement = function () {
	  var elem = this.startNode();
	  elem.value = {
	    raw: this.input.slice(this.start, this.end),
	    cooked: this.value
	  };
	  this.next();
	  elem.tail = this.type === tt.backQuote;
	  return this.finishNode(elem, "TemplateElement");
	};

	pp.parseTemplate = function () {
	  var node = this.startNode();
	  this.next();
	  node.expressions = [];
	  var curElt = this.parseTemplateElement();
	  node.quasis = [curElt];
	  while (!curElt.tail) {
	    this.expect(tt.dollarBraceL);
	    node.expressions.push(this.parseExpression());
	    this.expect(tt.braceR);
	    node.quasis.push(curElt = this.parseTemplateElement());
	  }
	  this.next();
	  return this.finishNode(node, "TemplateLiteral");
	};

	// Parse an object literal or binding pattern.

	pp.parseObj = function (isPattern, refShorthandDefaultPos) {
	  var node = this.startNode(),
	      first = true,
	      propHash = {};
	  node.properties = [];
	  this.next();
	  while (!this.eat(tt.braceR)) {
	    if (!first) {
	      this.expect(tt.comma);
	      if (this.afterTrailingComma(tt.braceR)) break;
	    } else first = false;

	    var prop = this.startNode(),
	        isGenerator = undefined,
	        startPos = undefined,
	        startLoc = undefined;
	    if (this.options.ecmaVersion >= 6) {
	      prop.method = false;
	      prop.shorthand = false;
	      if (isPattern || refShorthandDefaultPos) {
	        startPos = this.start;
	        startLoc = this.startLoc;
	      }
	      if (!isPattern) isGenerator = this.eat(tt.star);
	    }
	    this.parsePropertyName(prop);
	    this.parsePropertyValue(prop, isPattern, isGenerator, startPos, startLoc, refShorthandDefaultPos);
	    this.checkPropClash(prop, propHash);
	    node.properties.push(this.finishNode(prop, "Property"));
	  }
	  return this.finishNode(node, isPattern ? "ObjectPattern" : "ObjectExpression");
	};

	pp.parsePropertyValue = function (prop, isPattern, isGenerator, startPos, startLoc, refShorthandDefaultPos) {
	  if (this.eat(tt.colon)) {
	    prop.value = isPattern ? this.parseMaybeDefault(this.start, this.startLoc) : this.parseMaybeAssign(false, refShorthandDefaultPos);
	    prop.kind = "init";
	  } else if (this.options.ecmaVersion >= 6 && this.type === tt.parenL) {
	    if (isPattern) this.unexpected();
	    prop.kind = "init";
	    prop.method = true;
	    prop.value = this.parseMethod(isGenerator);
	  } else if (this.options.ecmaVersion >= 5 && !prop.computed && prop.key.type === "Identifier" && (prop.key.name === "get" || prop.key.name === "set") && (this.type != tt.comma && this.type != tt.braceR)) {
	    if (isGenerator || isPattern) this.unexpected();
	    prop.kind = prop.key.name;
	    this.parsePropertyName(prop);
	    prop.value = this.parseMethod(false);
	  } else if (this.options.ecmaVersion >= 6 && !prop.computed && prop.key.type === "Identifier") {
	    prop.kind = "init";
	    if (isPattern) {
	      if (this.isKeyword(prop.key.name) || this.strict && (reservedWords.strictBind(prop.key.name) || reservedWords.strict(prop.key.name)) || !this.options.allowReserved && this.isReservedWord(prop.key.name)) this.raise(prop.key.start, "Binding " + prop.key.name);
	      prop.value = this.parseMaybeDefault(startPos, startLoc, prop.key);
	    } else if (this.type === tt.eq && refShorthandDefaultPos) {
	      if (!refShorthandDefaultPos.start) refShorthandDefaultPos.start = this.start;
	      prop.value = this.parseMaybeDefault(startPos, startLoc, prop.key);
	    } else {
	      prop.value = prop.key;
	    }
	    prop.shorthand = true;
	  } else this.unexpected();
	};

	pp.parsePropertyName = function (prop) {
	  if (this.options.ecmaVersion >= 6) {
	    if (this.eat(tt.bracketL)) {
	      prop.computed = true;
	      prop.key = this.parseMaybeAssign();
	      this.expect(tt.bracketR);
	      return prop.key;
	    } else {
	      prop.computed = false;
	    }
	  }
	  return prop.key = this.type === tt.num || this.type === tt.string ? this.parseExprAtom() : this.parseIdent(true);
	};

	// Initialize empty function node.

	pp.initFunction = function (node) {
	  node.id = null;
	  if (this.options.ecmaVersion >= 6) {
	    node.generator = false;
	    node.expression = false;
	  }
	};

	// Parse object or class method.

	pp.parseMethod = function (isGenerator) {
	  var node = this.startNode();
	  this.initFunction(node);
	  this.expect(tt.parenL);
	  node.params = this.parseBindingList(tt.parenR, false, false);
	  var allowExpressionBody = undefined;
	  if (this.options.ecmaVersion >= 6) {
	    node.generator = isGenerator;
	    allowExpressionBody = true;
	  } else {
	    allowExpressionBody = false;
	  }
	  this.parseFunctionBody(node, allowExpressionBody);
	  return this.finishNode(node, "FunctionExpression");
	};

	// Parse arrow function expression with given parameters.

	pp.parseArrowExpression = function (node, params) {
	  this.initFunction(node);
	  node.params = this.toAssignableList(params, true);
	  this.parseFunctionBody(node, true);
	  return this.finishNode(node, "ArrowFunctionExpression");
	};

	// Parse function body and check parameters.

	pp.parseFunctionBody = function (node, allowExpression) {
	  var isExpression = allowExpression && this.type !== tt.braceL;

	  if (isExpression) {
	    node.body = this.parseMaybeAssign();
	    node.expression = true;
	  } else {
	    // Start a new scope with regard to labels and the `inFunction`
	    // flag (restore them to their old value afterwards).
	    var oldInFunc = this.inFunction,
	        oldInGen = this.inGenerator,
	        oldLabels = this.labels;
	    this.inFunction = true;this.inGenerator = node.generator;this.labels = [];
	    node.body = this.parseBlock(true);
	    node.expression = false;
	    this.inFunction = oldInFunc;this.inGenerator = oldInGen;this.labels = oldLabels;
	  }

	  // If this is a strict mode function, verify that argument names
	  // are not repeated, and it does not try to bind the words `eval`
	  // or `arguments`.
	  if (this.strict || !isExpression && node.body.body.length && this.isUseStrict(node.body.body[0])) {
	    var nameHash = {},
	        oldStrict = this.strict;
	    this.strict = true;
	    if (node.id) this.checkLVal(node.id, true);
	    for (var i = 0; i < node.params.length; i++) {
	      this.checkLVal(node.params[i], true, nameHash);
	    }this.strict = oldStrict;
	  }
	};

	// Parses a comma-separated list of expressions, and returns them as
	// an array. `close` is the token type that ends the list, and
	// `allowEmpty` can be turned on to allow subsequent commas with
	// nothing in between them to be parsed as `null` (which is needed
	// for array literals).

	pp.parseExprList = function (close, allowTrailingComma, allowEmpty, refShorthandDefaultPos) {
	  var elts = [],
	      first = true;
	  while (!this.eat(close)) {
	    if (!first) {
	      this.expect(tt.comma);
	      if (allowTrailingComma && this.afterTrailingComma(close)) break;
	    } else first = false;

	    if (allowEmpty && this.type === tt.comma) {
	      elts.push(null);
	    } else {
	      if (this.type === tt.ellipsis) elts.push(this.parseSpread(refShorthandDefaultPos));else elts.push(this.parseMaybeAssign(false, refShorthandDefaultPos));
	    }
	  }
	  return elts;
	};

	// Parse the next token as an identifier. If `liberal` is true (used
	// when parsing properties), it will also convert keywords into
	// identifiers.

	pp.parseIdent = function (liberal) {
	  var node = this.startNode();
	  if (liberal && this.options.allowReserved == "never") liberal = false;
	  if (this.type === tt.name) {
	    if (!liberal && (!this.options.allowReserved && this.isReservedWord(this.value) || this.strict && reservedWords.strict(this.value) && (this.options.ecmaVersion >= 6 || this.input.slice(this.start, this.end).indexOf("\\") == -1))) this.raise(this.start, "The keyword '" + this.value + "' is reserved");
	    node.name = this.value;
	  } else if (liberal && this.type.keyword) {
	    node.name = this.type.keyword;
	  } else {
	    this.unexpected();
	  }
	  this.next();
	  return this.finishNode(node, "Identifier");
	};

	// Parses yield expression inside generator.

	pp.parseYield = function () {
	  var node = this.startNode();
	  this.next();
	  if (this.type == tt.semi || this.canInsertSemicolon() || this.type != tt.star && !this.type.startsExpr) {
	    node.delegate = false;
	    node.argument = null;
	  } else {
	    node.delegate = this.eat(tt.star);
	    node.argument = this.parseMaybeAssign();
	  }
	  return this.finishNode(node, "YieldExpression");
	};

	// Parses array and generator comprehensions.

	pp.parseComprehension = function (node, isGenerator) {
	  node.blocks = [];
	  while (this.type === tt._for) {
	    var block = this.startNode();
	    this.next();
	    this.expect(tt.parenL);
	    block.left = this.parseBindingAtom();
	    this.checkLVal(block.left, true);
	    this.expectContextual("of");
	    block.right = this.parseExpression();
	    this.expect(tt.parenR);
	    node.blocks.push(this.finishNode(block, "ComprehensionBlock"));
	  }
	  node.filter = this.eat(tt._if) ? this.parseParenExpression() : null;
	  node.body = this.parseExpression();
	  this.expect(isGenerator ? tt.parenR : tt.bracketR);
	  node.generator = isGenerator;
	  return this.finishNode(node, "ComprehensionExpression");
	};

	},{"./identifier":7,"./state":13,"./tokentype":17,"./util":18}],7:[function(_dereq_,module,exports){


	// Test whether a given character code starts an identifier.

	"use strict";

	exports.isIdentifierStart = isIdentifierStart;

	// Test whether a given character is part of an identifier.

	exports.isIdentifierChar = isIdentifierChar;
	exports.__esModule = true;
	// This is a trick taken from Esprima. It turns out that, on
	// non-Chrome browsers, to check whether a string is in a set, a
	// predicate containing a big ugly `switch` statement is faster than
	// a regular expression, and on Chrome the two are about on par.
	// This function uses `eval` (non-lexical) to produce such a
	// predicate from a space-separated string of words.
	//
	// It starts by sorting the words by length.

	function makePredicate(words) {
	  words = words.split(" ");
	  var f = "",
	      cats = [];
	  out: for (var i = 0; i < words.length; ++i) {
	    for (var j = 0; j < cats.length; ++j) {
	      if (cats[j][0].length == words[i].length) {
	        cats[j].push(words[i]);
	        continue out;
	      }
	    }cats.push([words[i]]);
	  }
	  function compareTo(arr) {
	    if (arr.length == 1) {
	      return f += "return str === " + JSON.stringify(arr[0]) + ";";
	    }f += "switch(str){";
	    for (var i = 0; i < arr.length; ++i) {
	      f += "case " + JSON.stringify(arr[i]) + ":";
	    }f += "return true}return false;";
	  }

	  // When there are more than three length categories, an outer
	  // switch first dispatches on the lengths, to save on comparisons.

	  if (cats.length > 3) {
	    cats.sort(function (a, b) {
	      return b.length - a.length;
	    });
	    f += "switch(str.length){";
	    for (var i = 0; i < cats.length; ++i) {
	      var cat = cats[i];
	      f += "case " + cat[0].length + ":";
	      compareTo(cat);
	    }
	    f += "}"

	    // Otherwise, simply generate a flat `switch` statement.

	    ;
	  } else {
	    compareTo(words);
	  }
	  return new Function("str", f);
	}

	// Reserved word lists for various dialects of the language

	var reservedWords = {
	  3: makePredicate("abstract boolean byte char class double enum export extends final float goto implements import int interface long native package private protected public short static super synchronized throws transient volatile"),
	  5: makePredicate("class enum extends super const export import"),
	  6: makePredicate("enum await"),
	  strict: makePredicate("implements interface let package private protected public static yield"),
	  strictBind: makePredicate("eval arguments")
	};

	exports.reservedWords = reservedWords;
	// And the keywords

	var ecma5AndLessKeywords = "break case catch continue debugger default do else finally for function if return switch throw try var while with null true false instanceof typeof void delete new in this";

	var keywords = {
	  5: makePredicate(ecma5AndLessKeywords),
	  6: makePredicate(ecma5AndLessKeywords + " let const class extends export import yield super")
	};

	exports.keywords = keywords;
	// ## Character categories

	// Big ugly regular expressions that match characters in the
	// whitespace, identifier, and identifier-start categories. These
	// are only applied when a character is found to actually have a
	// code point above 128.
	// Generated by `tools/generate-identifier-regex.js`.

	var nonASCIIidentifierStartChars = "-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------";
	var nonASCIIidentifierChars = "-------------------------------------------------------------------------------------------------------------------------------------------------";

	var nonASCIIidentifierStart = new RegExp("[" + nonASCIIidentifierStartChars + "]");
	var nonASCIIidentifier = new RegExp("[" + nonASCIIidentifierStartChars + nonASCIIidentifierChars + "]");

	nonASCIIidentifierStartChars = nonASCIIidentifierChars = null;

	// These are a run-length and offset encoded representation of the
	// >0xffff code points that are a valid part of identifiers. The
	// offset starts at 0x10000, and each pair of numbers represents an
	// offset to the next range, and then a size of the range. They were
	// generated by tools/generate-identifier-regex.js
	var astralIdentifierStartCodes = [0, 11, 2, 25, 2, 18, 2, 1, 2, 14, 3, 13, 35, 122, 70, 52, 268, 28, 4, 48, 48, 31, 17, 26, 6, 37, 11, 29, 3, 35, 5, 7, 2, 4, 43, 157, 99, 39, 9, 51, 157, 310, 10, 21, 11, 7, 153, 5, 3, 0, 2, 43, 2, 1, 4, 0, 3, 22, 11, 22, 10, 30, 98, 21, 11, 25, 71, 55, 7, 1, 65, 0, 16, 3, 2, 2, 2, 26, 45, 28, 4, 28, 36, 7, 2, 27, 28, 53, 11, 21, 11, 18, 14, 17, 111, 72, 955, 52, 76, 44, 33, 24, 27, 35, 42, 34, 4, 0, 13, 47, 15, 3, 22, 0, 38, 17, 2, 24, 133, 46, 39, 7, 3, 1, 3, 21, 2, 6, 2, 1, 2, 4, 4, 0, 32, 4, 287, 47, 21, 1, 2, 0, 185, 46, 82, 47, 21, 0, 60, 42, 502, 63, 32, 0, 449, 56, 1288, 920, 104, 110, 2962, 1070, 13266, 568, 8, 30, 114, 29, 19, 47, 17, 3, 32, 20, 6, 18, 881, 68, 12, 0, 67, 12, 16481, 1, 3071, 106, 6, 12, 4, 8, 8, 9, 5991, 84, 2, 70, 2, 1, 3, 0, 3, 1, 3, 3, 2, 11, 2, 0, 2, 6, 2, 64, 2, 3, 3, 7, 2, 6, 2, 27, 2, 3, 2, 4, 2, 0, 4, 6, 2, 339, 3, 24, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 7, 4149, 196, 1340, 3, 2, 26, 2, 1, 2, 0, 3, 0, 2, 9, 2, 3, 2, 0, 2, 0, 7, 0, 5, 0, 2, 0, 2, 0, 2, 2, 2, 1, 2, 0, 3, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 1, 2, 0, 3, 3, 2, 6, 2, 3, 2, 3, 2, 0, 2, 9, 2, 16, 6, 2, 2, 4, 2, 16, 4421, 42710, 42, 4148, 12, 221, 16355, 541];
	var astralIdentifierCodes = [509, 0, 227, 0, 150, 4, 294, 9, 1368, 2, 2, 1, 6, 3, 41, 2, 5, 0, 166, 1, 1306, 2, 54, 14, 32, 9, 16, 3, 46, 10, 54, 9, 7, 2, 37, 13, 2, 9, 52, 0, 13, 2, 49, 13, 16, 9, 83, 11, 168, 11, 6, 9, 8, 2, 57, 0, 2, 6, 3, 1, 3, 2, 10, 0, 11, 1, 3, 6, 4, 4, 316, 19, 13, 9, 214, 6, 3, 8, 112, 16, 16, 9, 82, 12, 9, 9, 535, 9, 20855, 9, 135, 4, 60, 6, 26, 9, 1016, 45, 17, 3, 19723, 1, 5319, 4, 4, 5, 9, 7, 3, 6, 31, 3, 149, 2, 1418, 49, 4305, 6, 792618, 239];

	// This has a complexity linear to the value of the code. The
	// assumption is that looking up astral identifier characters is
	// rare.
	function isInAstralSet(code, set) {
	  var pos = 65536;
	  for (var i = 0; i < set.length; i += 2) {
	    pos += set[i];
	    if (pos > code) {
	      return false;
	    }pos += set[i + 1];
	    if (pos >= code) {
	      return true;
	    }
	  }
	}
	function isIdentifierStart(code, astral) {
	  if (code < 65) {
	    return code === 36;
	  }if (code < 91) {
	    return true;
	  }if (code < 97) {
	    return code === 95;
	  }if (code < 123) {
	    return true;
	  }if (code <= 65535) {
	    return code >= 170 && nonASCIIidentifierStart.test(String.fromCharCode(code));
	  }if (astral === false) {
	    return false;
	  }return isInAstralSet(code, astralIdentifierStartCodes);
	}

	function isIdentifierChar(code, astral) {
	  if (code < 48) {
	    return code === 36;
	  }if (code < 58) {
	    return true;
	  }if (code < 65) {
	    return false;
	  }if (code < 91) {
	    return true;
	  }if (code < 97) {
	    return code === 95;
	  }if (code < 123) {
	    return true;
	  }if (code <= 65535) {
	    return code >= 170 && nonASCIIidentifier.test(String.fromCharCode(code));
	  }if (astral === false) {
	    return false;
	  }return isInAstralSet(code, astralIdentifierStartCodes) || isInAstralSet(code, astralIdentifierCodes);
	}

	},{}],8:[function(_dereq_,module,exports){
	"use strict";

	var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } };

	// The `getLineInfo` function is mostly useful when the
	// `locations` option is off (for performance reasons) and you
	// want to find the line/column position for a given character
	// offset. `input` should be the code string that the offset refers
	// into.

	exports.getLineInfo = getLineInfo;
	exports.__esModule = true;

	var Parser = _dereq_("./state").Parser;

	var lineBreakG = _dereq_("./whitespace").lineBreakG;

	var deprecate = _dereq_("util").deprecate;

	// These are used when `options.locations` is on, for the
	// `startLoc` and `endLoc` properties.

	var Position = exports.Position = (function () {
	  function Position(line, col) {
	    _classCallCheck(this, Position);

	    this.line = line;
	    this.column = col;
	  }

	  Position.prototype.offset = function offset(n) {
	    return new Position(this.line, this.column + n);
	  };

	  return Position;
	})();

	var SourceLocation = exports.SourceLocation = function SourceLocation(p, start, end) {
	  _classCallCheck(this, SourceLocation);

	  this.start = start;
	  this.end = end;
	  if (p.sourceFile !== null) this.source = p.sourceFile;
	};

	function getLineInfo(input, offset) {
	  for (var line = 1, cur = 0;;) {
	    lineBreakG.lastIndex = cur;
	    var match = lineBreakG.exec(input);
	    if (match && match.index < offset) {
	      ++line;
	      cur = match.index + match[0].length;
	    } else {
	      return new Position(line, offset - cur);
	    }
	  }
	}

	var pp = Parser.prototype;

	// This function is used to raise exceptions on parse errors. It
	// takes an offset integer (into the current `input`) to indicate
	// the location of the error, attaches the position to the end
	// of the error message, and then raises a `SyntaxError` with that
	// message.

	pp.raise = function (pos, message) {
	  var loc = getLineInfo(this.input, pos);
	  message += " (" + loc.line + ":" + loc.column + ")";
	  var err = new SyntaxError(message);
	  err.pos = pos;err.loc = loc;err.raisedAt = this.pos;
	  throw err;
	};

	pp.curPosition = function () {
	  return new Position(this.curLine, this.pos - this.lineStart);
	};

	pp.markPosition = function () {
	  return this.options.locations ? [this.start, this.startLoc] : this.start;
	};

	},{"./state":13,"./whitespace":19,"util":5}],9:[function(_dereq_,module,exports){
	"use strict";

	var tt = _dereq_("./tokentype").types;

	var Parser = _dereq_("./state").Parser;

	var reservedWords = _dereq_("./identifier").reservedWords;

	var has = _dereq_("./util").has;

	var pp = Parser.prototype;

	// Convert existing expression atom to assignable pattern
	// if possible.

	pp.toAssignable = function (node, isBinding) {
	  if (this.options.ecmaVersion >= 6 && node) {
	    switch (node.type) {
	      case "Identifier":
	      case "ObjectPattern":
	      case "ArrayPattern":
	      case "AssignmentPattern":
	        break;

	      case "ObjectExpression":
	        node.type = "ObjectPattern";
	        for (var i = 0; i < node.properties.length; i++) {
	          var prop = node.properties[i];
	          if (prop.kind !== "init") this.raise(prop.key.start, "Object pattern can't contain getter or setter");
	          this.toAssignable(prop.value, isBinding);
	        }
	        break;

	      case "ArrayExpression":
	        node.type = "ArrayPattern";
	        this.toAssignableList(node.elements, isBinding);
	        break;

	      case "AssignmentExpression":
	        if (node.operator === "=") {
	          node.type = "AssignmentPattern";
	        } else {
	          this.raise(node.left.end, "Only '=' operator can be used for specifying default value.");
	        }
	        break;

	      case "ParenthesizedExpression":
	        node.expression = this.toAssignable(node.expression, isBinding);
	        break;

	      case "MemberExpression":
	        if (!isBinding) break;

	      default:
	        this.raise(node.start, "Assigning to rvalue");
	    }
	  }
	  return node;
	};

	// Convert list of expression atoms to binding list.

	pp.toAssignableList = function (exprList, isBinding) {
	  var end = exprList.length;
	  if (end) {
	    var last = exprList[end - 1];
	    if (last && last.type == "RestElement") {
	      --end;
	    } else if (last && last.type == "SpreadElement") {
	      last.type = "RestElement";
	      var arg = last.argument;
	      this.toAssignable(arg, isBinding);
	      if (arg.type !== "Identifier" && arg.type !== "MemberExpression" && arg.type !== "ArrayPattern") this.unexpected(arg.start);
	      --end;
	    }
	  }
	  for (var i = 0; i < end; i++) {
	    var elt = exprList[i];
	    if (elt) this.toAssignable(elt, isBinding);
	  }
	  return exprList;
	};

	// Parses spread element.

	pp.parseSpread = function (refShorthandDefaultPos) {
	  var node = this.startNode();
	  this.next();
	  node.argument = this.parseMaybeAssign(refShorthandDefaultPos);
	  return this.finishNode(node, "SpreadElement");
	};

	pp.parseRest = function () {
	  var node = this.startNode();
	  this.next();
	  node.argument = this.type === tt.name || this.type === tt.bracketL ? this.parseBindingAtom() : this.unexpected();
	  return this.finishNode(node, "RestElement");
	};

	// Parses lvalue (assignable) atom.

	pp.parseBindingAtom = function () {
	  if (this.options.ecmaVersion < 6) return this.parseIdent();
	  switch (this.type) {
	    case tt.name:
	      return this.parseIdent();

	    case tt.bracketL:
	      var node = this.startNode();
	      this.next();
	      node.elements = this.parseBindingList(tt.bracketR, true, true);
	      return this.finishNode(node, "ArrayPattern");

	    case tt.braceL:
	      return this.parseObj(true);

	    default:
	      this.unexpected();
	  }
	};

	pp.parseBindingList = function (close, allowEmpty, allowTrailingComma) {
	  var elts = [],
	      first = true;
	  while (!this.eat(close)) {
	    if (first) first = false;else this.expect(tt.comma);
	    if (allowEmpty && this.type === tt.comma) {
	      elts.push(null);
	    } else if (allowTrailingComma && this.afterTrailingComma(close)) {
	      break;
	    } else if (this.type === tt.ellipsis) {
	      var rest = this.parseRest();
	      this.parseBindingListItem(rest);
	      elts.push(rest);
	      this.expect(close);
	      break;
	    } else {
	      var elem = this.parseMaybeDefault(this.start, this.startLoc);
	      this.parseBindingListItem(elem);
	      elts.push(elem);
	    }
	  }
	  return elts;
	};

	pp.parseBindingListItem = function (param) {
	  return param;
	};

	// Parses assignment pattern around given atom if possible.

	pp.parseMaybeDefault = function (startPos, startLoc, left) {
	  if (Array.isArray(startPos)) {
	    if (this.options.locations && noCalls === undefined) {
	      // shift arguments to left by one
	      left = startLoc;
	      // flatten startPos
	      startLoc = startPos[1];
	      startPos = startPos[0];
	    }
	  }
	  left = left || this.parseBindingAtom();
	  if (!this.eat(tt.eq)) return left;
	  var node = this.startNodeAt(startPos, startLoc);
	  node.operator = "=";
	  node.left = left;
	  node.right = this.parseMaybeAssign();
	  return this.finishNode(node, "AssignmentPattern");
	};

	// Verify that a node is an lval  something that can be assigned
	// to.

	pp.checkLVal = function (expr, isBinding, checkClashes) {
	  switch (expr.type) {
	    case "Identifier":
	      if (this.strict && (reservedWords.strictBind(expr.name) || reservedWords.strict(expr.name))) this.raise(expr.start, (isBinding ? "Binding " : "Assigning to ") + expr.name + " in strict mode");
	      if (checkClashes) {
	        if (has(checkClashes, expr.name)) this.raise(expr.start, "Argument name clash in strict mode");
	        checkClashes[expr.name] = true;
	      }
	      break;

	    case "MemberExpression":
	      if (isBinding) this.raise(expr.start, (isBinding ? "Binding" : "Assigning to") + " member expression");
	      break;

	    case "ObjectPattern":
	      for (var i = 0; i < expr.properties.length; i++) {
	        this.checkLVal(expr.properties[i].value, isBinding, checkClashes);
	      }break;

	    case "ArrayPattern":
	      for (var i = 0; i < expr.elements.length; i++) {
	        var elem = expr.elements[i];
	        if (elem) this.checkLVal(elem, isBinding, checkClashes);
	      }
	      break;

	    case "AssignmentPattern":
	      this.checkLVal(expr.left, isBinding, checkClashes);
	      break;

	    case "RestElement":
	      this.checkLVal(expr.argument, isBinding, checkClashes);
	      break;

	    case "ParenthesizedExpression":
	      this.checkLVal(expr.expression, isBinding, checkClashes);
	      break;

	    default:
	      this.raise(expr.start, (isBinding ? "Binding" : "Assigning to") + " rvalue");
	  }
	};

	},{"./identifier":7,"./state":13,"./tokentype":17,"./util":18}],10:[function(_dereq_,module,exports){
	"use strict";

	var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } };

	exports.__esModule = true;

	var Parser = _dereq_("./state").Parser;

	var SourceLocation = _dereq_("./location").SourceLocation;

	// Start an AST node, attaching a start offset.

	var pp = Parser.prototype;

	var Node = exports.Node = function Node() {
	  _classCallCheck(this, Node);
	};

	pp.startNode = function () {
	  var node = new Node();
	  node.start = this.start;
	  if (this.options.locations) node.loc = new SourceLocation(this, this.startLoc);
	  if (this.options.directSourceFile) node.sourceFile = this.options.directSourceFile;
	  if (this.options.ranges) node.range = [this.start, 0];
	  return node;
	};

	pp.startNodeAt = function (pos, loc) {
	  var node = new Node();
	  if (Array.isArray(pos)) {
	    if (this.options.locations && loc === undefined) {
	      // flatten pos
	      loc = pos[1];
	      pos = pos[0];
	    }
	  }
	  node.start = pos;
	  if (this.options.locations) node.loc = new SourceLocation(this, loc);
	  if (this.options.directSourceFile) node.sourceFile = this.options.directSourceFile;
	  if (this.options.ranges) node.range = [pos, 0];
	  return node;
	};

	// Finish an AST node, adding `type` and `end` properties.

	pp.finishNode = function (node, type) {
	  node.type = type;
	  node.end = this.lastTokEnd;
	  if (this.options.locations) node.loc.end = this.lastTokEndLoc;
	  if (this.options.ranges) node.range[1] = this.lastTokEnd;
	  return node;
	};

	// Finish node at given position

	pp.finishNodeAt = function (node, type, pos, loc) {
	  node.type = type;
	  if (Array.isArray(pos)) {
	    if (this.options.locations && loc === undefined) {
	      // flatten pos
	      loc = pos[1];
	      pos = pos[0];
	    }
	  }
	  node.end = pos;
	  if (this.options.locations) node.loc.end = loc;
	  if (this.options.ranges) node.range[1] = pos;
	  return node;
	};

	},{"./location":8,"./state":13}],11:[function(_dereq_,module,exports){


	// Interpret and default an options object

	"use strict";

	exports.getOptions = getOptions;
	exports.__esModule = true;

	var _util = _dereq_("./util");

	var has = _util.has;
	var isArray = _util.isArray;

	var SourceLocation = _dereq_("./location").SourceLocation;

	// A second optional argument can be given to further configure
	// the parser process. These options are recognized:

	var defaultOptions = {
	  // `ecmaVersion` indicates the ECMAScript version to parse. Must
	  // be either 3, or 5, or 6. This influences support for strict
	  // mode, the set of reserved words, support for getters and
	  // setters and other features.
	  ecmaVersion: 5,
	  // Source type ("script" or "module") for different semantics
	  sourceType: "script",
	  // `onInsertedSemicolon` can be a callback that will be called
	  // when a semicolon is automatically inserted. It will be passed
	  // th position of the comma as an offset, and if `locations` is
	  // enabled, it is given the location as a `{line, column}` object
	  // as second argument.
	  onInsertedSemicolon: null,
	  // `onTrailingComma` is similar to `onInsertedSemicolon`, but for
	  // trailing commas.
	  onTrailingComma: null,
	  // By default, reserved words are not enforced. Disable
	  // `allowReserved` to enforce them. When this option has the
	  // value "never", reserved words and keywords can also not be
	  // used as property names.
	  allowReserved: true,
	  // When enabled, a return at the top level is not considered an
	  // error.
	  allowReturnOutsideFunction: false,
	  // When enabled, import/export statements are not constrained to
	  // appearing at the top of the program.
	  allowImportExportEverywhere: false,
	  // When enabled, hashbang directive in the beginning of file
	  // is allowed and treated as a line comment.
	  allowHashBang: false,
	  // When `locations` is on, `loc` properties holding objects with
	  // `start` and `end` properties in `{line, column}` form (with
	  // line being 1-based and column 0-based) will be attached to the
	  // nodes.
	  locations: false,
	  // A function can be passed as `onToken` option, which will
	  // cause Acorn to call that function with object in the same
	  // format as tokenize() returns. Note that you are not
	  // allowed to call the parser from the callbackthat will
	  // corrupt its internal state.
	  onToken: null,
	  // A function can be passed as `onComment` option, which will
	  // cause Acorn to call that function with `(block, text, start,
	  // end)` parameters whenever a comment is skipped. `block` is a
	  // boolean indicating whether this is a block (`/* */`) comment,
	  // `text` is the content of the comment, and `start` and `end` are
	  // character offsets that denote the start and end of the comment.
	  // When the `locations` option is on, two more parameters are
	  // passed, the full `{line, column}` locations of the start and
	  // end of the comments. Note that you are not allowed to call the
	  // parser from the callbackthat will corrupt its internal state.
	  onComment: null,
	  // Nodes have their start and end characters offsets recorded in
	  // `start` and `end` properties (directly on the node, rather than
	  // the `loc` object, which holds line/column data. To also add a
	  // [semi-standardized][range] `range` property holding a `[start,
	  // end]` array with the same numbers, set the `ranges` option to
	  // `true`.
	  //
	  // [range]: https://bugzilla.mozilla.org/show_bug.cgi?id=745678
	  ranges: false,
	  // It is possible to parse multiple files into a single AST by
	  // passing the tree produced by parsing the first file as
	  // `program` option in subsequent parses. This will add the
	  // toplevel forms of the parsed file to the `Program` (top) node
	  // of an existing parse tree.
	  program: null,
	  // When `locations` is on, you can pass this to record the source
	  // file in every node's `loc` object.
	  sourceFile: null,
	  // This value, if given, is stored in every node, whether
	  // `locations` is on or off.
	  directSourceFile: null,
	  // When enabled, parenthesized expressions are represented by
	  // (non-standard) ParenthesizedExpression nodes
	  preserveParens: false,
	  plugins: {}
	};exports.defaultOptions = defaultOptions;

	function getOptions(opts) {
	  var options = {};
	  for (var opt in defaultOptions) {
	    options[opt] = opts && has(opts, opt) ? opts[opt] : defaultOptions[opt];
	  }if (isArray(options.onToken)) {
	    (function () {
	      var tokens = options.onToken;
	      options.onToken = function (token) {
	        return tokens.push(token);
	      };
	    })();
	  }
	  if (isArray(options.onComment)) options.onComment = pushComment(options, options.onComment);

	  return options;
	}

	function pushComment(options, array) {
	  return function (block, text, start, end, startLoc, endLoc) {
	    var comment = {
	      type: block ? "Block" : "Line",
	      value: text,
	      start: start,
	      end: end
	    };
	    if (options.locations) comment.loc = new SourceLocation(this, startLoc, endLoc);
	    if (options.ranges) comment.range = [start, end];
	    array.push(comment);
	  };
	}

	},{"./location":8,"./util":18}],12:[function(_dereq_,module,exports){
	"use strict";

	var tt = _dereq_("./tokentype").types;

	var Parser = _dereq_("./state").Parser;

	var lineBreak = _dereq_("./whitespace").lineBreak;

	var pp = Parser.prototype;

	// ## Parser utilities

	// Test whether a statement node is the string literal `"use strict"`.

	pp.isUseStrict = function (stmt) {
	  return this.options.ecmaVersion >= 5 && stmt.type === "ExpressionStatement" && stmt.expression.type === "Literal" && stmt.expression.value === "use strict";
	};

	// Predicate that tests whether the next token is of the given
	// type, and if yes, consumes it as a side effect.

	pp.eat = function (type) {
	  if (this.type === type) {
	    this.next();
	    return true;
	  } else {
	    return false;
	  }
	};

	// Tests whether parsed token is a contextual keyword.

	pp.isContextual = function (name) {
	  return this.type === tt.name && this.value === name;
	};

	// Consumes contextual keyword if possible.

	pp.eatContextual = function (name) {
	  return this.value === name && this.eat(tt.name);
	};

	// Asserts that following token is given contextual keyword.

	pp.expectContextual = function (name) {
	  if (!this.eatContextual(name)) this.unexpected();
	};

	// Test whether a semicolon can be inserted at the current position.

	pp.canInsertSemicolon = function () {
	  return this.type === tt.eof || this.type === tt.braceR || lineBreak.test(this.input.slice(this.lastTokEnd, this.start));
	};

	pp.insertSemicolon = function () {
	  if (this.canInsertSemicolon()) {
	    if (this.options.onInsertedSemicolon) this.options.onInsertedSemicolon(this.lastTokEnd, this.lastTokEndLoc);
	    return true;
	  }
	};

	// Consume a semicolon, or, failing that, see if we are allowed to
	// pretend that there is a semicolon at this position.

	pp.semicolon = function () {
	  if (!this.eat(tt.semi) && !this.insertSemicolon()) this.unexpected();
	};

	pp.afterTrailingComma = function (tokType) {
	  if (this.type == tokType) {
	    if (this.options.onTrailingComma) this.options.onTrailingComma(this.lastTokStart, this.lastTokStartLoc);
	    this.next();
	    return true;
	  }
	};

	// Expect a token of a given type. If found, consume it, otherwise,
	// raise an unexpected token error.

	pp.expect = function (type) {
	  this.eat(type) || this.unexpected();
	};

	// Raise an unexpected token error.

	pp.unexpected = function (pos) {
	  this.raise(pos != null ? pos : this.start, "Unexpected token");
	};

	},{"./state":13,"./tokentype":17,"./whitespace":19}],13:[function(_dereq_,module,exports){
	"use strict";

	exports.Parser = Parser;
	exports.__esModule = true;

	var _identifier = _dereq_("./identifier");

	var reservedWords = _identifier.reservedWords;
	var keywords = _identifier.keywords;

	var tt = _dereq_("./tokentype").types;

	var lineBreak = _dereq_("./whitespace").lineBreak;

	function Parser(options, input, startPos) {
	  this.options = options;
	  this.sourceFile = this.options.sourceFile || null;
	  this.isKeyword = keywords[this.options.ecmaVersion >= 6 ? 6 : 5];
	  this.isReservedWord = reservedWords[this.options.ecmaVersion];
	  this.input = input;

	  // Load plugins
	  this.loadPlugins(this.options.plugins);

	  // Set up token state

	  // The current position of the tokenizer in the input.
	  if (startPos) {
	    this.pos = startPos;
	    this.lineStart = Math.max(0, this.input.lastIndexOf("\n", startPos));
	    this.curLine = this.input.slice(0, this.lineStart).split(lineBreak).length;
	  } else {
	    this.pos = this.lineStart = 0;
	    this.curLine = 1;
	  }

	  // Properties of the current token:
	  // Its type
	  this.type = tt.eof;
	  // For tokens that include more information than their type, the value
	  this.value = null;
	  // Its start and end offset
	  this.start = this.end = this.pos;
	  // And, if locations are used, the {line, column} object
	  // corresponding to those offsets
	  this.startLoc = this.endLoc = null;

	  // Position information for the previous token
	  this.lastTokEndLoc = this.lastTokStartLoc = null;
	  this.lastTokStart = this.lastTokEnd = this.pos;

	  // The context stack is used to superficially track syntactic
	  // context to predict whether a regular expression is allowed in a
	  // given position.
	  this.context = this.initialContext();
	  this.exprAllowed = true;

	  // Figure out if it's a module code.
	  this.strict = this.inModule = this.options.sourceType === "module";

	  // Used to signify the start of a potential arrow function
	  this.potentialArrowAt = -1;

	  // Flags to track whether we are in a function, a generator.
	  this.inFunction = this.inGenerator = false;
	  // Labels in scope.
	  this.labels = [];

	  // If enabled, skip leading hashbang line.
	  if (this.pos === 0 && this.options.allowHashBang && this.input.slice(0, 2) === "#!") this.skipLineComment(2);
	}

	Parser.prototype.extend = function (name, f) {
	  this[name] = f(this[name]);
	};

	// Registered plugins

	var plugins = {};

	exports.plugins = plugins;
	Parser.prototype.loadPlugins = function (plugins) {
	  for (var _name in plugins) {
	    var plugin = exports.plugins[_name];
	    if (!plugin) throw new Error("Plugin '" + _name + "' not found");
	    plugin(this, plugins[_name]);
	  }
	};

	},{"./identifier":7,"./tokentype":17,"./whitespace":19}],14:[function(_dereq_,module,exports){
	"use strict";

	var tt = _dereq_("./tokentype").types;

	var Parser = _dereq_("./state").Parser;

	var lineBreak = _dereq_("./whitespace").lineBreak;

	var pp = Parser.prototype;

	// ### Statement parsing

	// Parse a program. Initializes the parser, reads any number of
	// statements, and wraps them in a Program node.  Optionally takes a
	// `program` argument.  If present, the statements will be appended
	// to its body instead of creating a new node.

	pp.parseTopLevel = function (node) {
	  var first = true;
	  if (!node.body) node.body = [];
	  while (this.type !== tt.eof) {
	    var stmt = this.parseStatement(true, true);
	    node.body.push(stmt);
	    if (first && this.isUseStrict(stmt)) this.setStrict(true);
	    first = false;
	  }
	  this.next();
	  if (this.options.ecmaVersion >= 6) {
	    node.sourceType = this.options.sourceType;
	  }
	  return this.finishNode(node, "Program");
	};

	var loopLabel = { kind: "loop" },
	    switchLabel = { kind: "switch" };

	// Parse a single statement.
	//
	// If expecting a statement and finding a slash operator, parse a
	// regular expression literal. This is to handle cases like
	// `if (foo) /blah/.exec(foo)`, where looking at the previous token
	// does not help.

	pp.parseStatement = function (declaration, topLevel) {
	  var starttype = this.type,
	      node = this.startNode();

	  // Most types of statements are recognized by the keyword they
	  // start with. Many are trivial to parse, some require a bit of
	  // complexity.

	  switch (starttype) {
	    case tt._break:case tt._continue:
	      return this.parseBreakContinueStatement(node, starttype.keyword);
	    case tt._debugger:
	      return this.parseDebuggerStatement(node);
	    case tt._do:
	      return this.parseDoStatement(node);
	    case tt._for:
	      return this.parseForStatement(node);
	    case tt._function:
	      if (!declaration && this.options.ecmaVersion >= 6) this.unexpected();
	      return this.parseFunctionStatement(node);
	    case tt._class:
	      if (!declaration) this.unexpected();
	      return this.parseClass(node, true);
	    case tt._if:
	      return this.parseIfStatement(node);
	    case tt._return:
	      return this.parseReturnStatement(node);
	    case tt._switch:
	      return this.parseSwitchStatement(node);
	    case tt._throw:
	      return this.parseThrowStatement(node);
	    case tt._try:
	      return this.parseTryStatement(node);
	    case tt._let:case tt._const:
	      if (!declaration) this.unexpected(); // NOTE: falls through to _var
	    case tt._var:
	      return this.parseVarStatement(node, starttype);
	    case tt._while:
	      return this.parseWhileStatement(node);
	    case tt._with:
	      return this.parseWithStatement(node);
	    case tt.braceL:
	      return this.parseBlock();
	    case tt.semi:
	      return this.parseEmptyStatement(node);
	    case tt._export:
	    case tt._import:
	      if (!this.options.allowImportExportEverywhere) {
	        if (!topLevel) this.raise(this.start, "'import' and 'export' may only appear at the top level");
	        if (!this.inModule) this.raise(this.start, "'import' and 'export' may appear only with 'sourceType: module'");
	      }
	      return starttype === tt._import ? this.parseImport(node) : this.parseExport(node);

	    // If the statement does not start with a statement keyword or a
	    // brace, it's an ExpressionStatement or LabeledStatement. We
	    // simply start parsing an expression, and afterwards, if the
	    // next token is a colon and the expression was a simple
	    // Identifier node, we switch to interpreting it as a label.
	    default:
	      var maybeName = this.value,
	          expr = this.parseExpression();
	      if (starttype === tt.name && expr.type === "Identifier" && this.eat(tt.colon)) return this.parseLabeledStatement(node, maybeName, expr);else return this.parseExpressionStatement(node, expr);
	  }
	};

	pp.parseBreakContinueStatement = function (node, keyword) {
	  var isBreak = keyword == "break";
	  this.next();
	  if (this.eat(tt.semi) || this.insertSemicolon()) node.label = null;else if (this.type !== tt.name) this.unexpected();else {
	    node.label = this.parseIdent();
	    this.semicolon();
	  }

	  // Verify that there is an actual destination to break or
	  // continue to.
	  for (var i = 0; i < this.labels.length; ++i) {
	    var lab = this.labels[i];
	    if (node.label == null || lab.name === node.label.name) {
	      if (lab.kind != null && (isBreak || lab.kind === "loop")) break;
	      if (node.label && isBreak) break;
	    }
	  }
	  if (i === this.labels.length) this.raise(node.start, "Unsyntactic " + keyword);
	  return this.finishNode(node, isBreak ? "BreakStatement" : "ContinueStatement");
	};

	pp.parseDebuggerStatement = function (node) {
	  this.next();
	  this.semicolon();
	  return this.finishNode(node, "DebuggerStatement");
	};

	pp.parseDoStatement = function (node) {
	  this.next();
	  this.labels.push(loopLabel);
	  node.body = this.parseStatement(false);
	  this.labels.pop();
	  this.expect(tt._while);
	  node.test = this.parseParenExpression();
	  if (this.options.ecmaVersion >= 6) this.eat(tt.semi);else this.semicolon();
	  return this.finishNode(node, "DoWhileStatement");
	};

	// Disambiguating between a `for` and a `for`/`in` or `for`/`of`
	// loop is non-trivial. Basically, we have to parse the init `var`
	// statement or expression, disallowing the `in` operator (see
	// the second parameter to `parseExpression`), and then check
	// whether the next token is `in` or `of`. When there is no init
	// part (semicolon immediately after the opening parenthesis), it
	// is a regular `for` loop.

	pp.parseForStatement = function (node) {
	  this.next();
	  this.labels.push(loopLabel);
	  this.expect(tt.parenL);
	  if (this.type === tt.semi) return this.parseFor(node, null);
	  if (this.type === tt._var || this.type === tt._let || this.type === tt._const) {
	    var _init = this.startNode(),
	        varKind = this.type;
	    this.next();
	    this.parseVar(_init, true, varKind);
	    this.finishNode(_init, "VariableDeclaration");
	    if ((this.type === tt._in || this.options.ecmaVersion >= 6 && this.isContextual("of")) && _init.declarations.length === 1 && !(varKind !== tt._var && _init.declarations[0].init)) return this.parseForIn(node, _init);
	    return this.parseFor(node, _init);
	  }
	  var refShorthandDefaultPos = { start: 0 };
	  var init = this.parseExpression(true, refShorthandDefaultPos);
	  if (this.type === tt._in || this.options.ecmaVersion >= 6 && this.isContextual("of")) {
	    this.toAssignable(init);
	    this.checkLVal(init);
	    return this.parseForIn(node, init);
	  } else if (refShorthandDefaultPos.start) {
	    this.unexpected(refShorthandDefaultPos.start);
	  }
	  return this.parseFor(node, init);
	};

	pp.parseFunctionStatement = function (node) {
	  this.next();
	  return this.parseFunction(node, true);
	};

	pp.parseIfStatement = function (node) {
	  this.next();
	  node.test = this.parseParenExpression();
	  node.consequent = this.parseStatement(false);
	  node.alternate = this.eat(tt._else) ? this.parseStatement(false) : null;
	  return this.finishNode(node, "IfStatement");
	};

	pp.parseReturnStatement = function (node) {
	  if (!this.inFunction && !this.options.allowReturnOutsideFunction) this.raise(this.start, "'return' outside of function");
	  this.next();

	  // In `return` (and `break`/`continue`), the keywords with
	  // optional arguments, we eagerly look for a semicolon or the
	  // possibility to insert one.

	  if (this.eat(tt.semi) || this.insertSemicolon()) node.argument = null;else {
	    node.argument = this.parseExpression();this.semicolon();
	  }
	  return this.finishNode(node, "ReturnStatement");
	};

	pp.parseSwitchStatement = function (node) {
	  this.next();
	  node.discriminant = this.parseParenExpression();
	  node.cases = [];
	  this.expect(tt.braceL);
	  this.labels.push(switchLabel);

	  // Statements under must be grouped (by label) in SwitchCase
	  // nodes. `cur` is used to keep the node that we are currently
	  // adding statements to.

	  for (var cur, sawDefault; this.type != tt.braceR;) {
	    if (this.type === tt._case || this.type === tt._default) {
	      var isCase = this.type === tt._case;
	      if (cur) this.finishNode(cur, "SwitchCase");
	      node.cases.push(cur = this.startNode());
	      cur.consequent = [];
	      this.next();
	      if (isCase) {
	        cur.test = this.parseExpression();
	      } else {
	        if (sawDefault) this.raise(this.lastTokStart, "Multiple default clauses");
	        sawDefault = true;
	        cur.test = null;
	      }
	      this.expect(tt.colon);
	    } else {
	      if (!cur) this.unexpected();
	      cur.consequent.push(this.parseStatement(true));
	    }
	  }
	  if (cur) this.finishNode(cur, "SwitchCase");
	  this.next(); // Closing brace
	  this.labels.pop();
	  return this.finishNode(node, "SwitchStatement");
	};

	pp.parseThrowStatement = function (node) {
	  this.next();
	  if (lineBreak.test(this.input.slice(this.lastTokEnd, this.start))) this.raise(this.lastTokEnd, "Illegal newline after throw");
	  node.argument = this.parseExpression();
	  this.semicolon();
	  return this.finishNode(node, "ThrowStatement");
	};

	// Reused empty array added for node fields that are always empty.

	var empty = [];

	pp.parseTryStatement = function (node) {
	  this.next();
	  node.block = this.parseBlock();
	  node.handler = null;
	  if (this.type === tt._catch) {
	    var clause = this.startNode();
	    this.next();
	    this.expect(tt.parenL);
	    clause.param = this.parseBindingAtom();
	    this.checkLVal(clause.param, true);
	    this.expect(tt.parenR);
	    clause.guard = null;
	    clause.body = this.parseBlock();
	    node.handler = this.finishNode(clause, "CatchClause");
	  }
	  node.guardedHandlers = empty;
	  node.finalizer = this.eat(tt._finally) ? this.parseBlock() : null;
	  if (!node.handler && !node.finalizer) this.raise(node.start, "Missing catch or finally clause");
	  return this.finishNode(node, "TryStatement");
	};

	pp.parseVarStatement = function (node, kind) {
	  this.next();
	  this.parseVar(node, false, kind);
	  this.semicolon();
	  return this.finishNode(node, "VariableDeclaration");
	};

	pp.parseWhileStatement = function (node) {
	  this.next();
	  node.test = this.parseParenExpression();
	  this.labels.push(loopLabel);
	  node.body = this.parseStatement(false);
	  this.labels.pop();
	  return this.finishNode(node, "WhileStatement");
	};

	pp.parseWithStatement = function (node) {
	  if (this.strict) this.raise(this.start, "'with' in strict mode");
	  this.next();
	  node.object = this.parseParenExpression();
	  node.body = this.parseStatement(false);
	  return this.finishNode(node, "WithStatement");
	};

	pp.parseEmptyStatement = function (node) {
	  this.next();
	  return this.finishNode(node, "EmptyStatement");
	};

	pp.parseLabeledStatement = function (node, maybeName, expr) {
	  for (var i = 0; i < this.labels.length; ++i) {
	    if (this.labels[i].name === maybeName) this.raise(expr.start, "Label '" + maybeName + "' is already declared");
	  }var kind = this.type.isLoop ? "loop" : this.type === tt._switch ? "switch" : null;
	  this.labels.push({ name: maybeName, kind: kind });
	  node.body = this.parseStatement(true);
	  this.labels.pop();
	  node.label = expr;
	  return this.finishNode(node, "LabeledStatement");
	};

	pp.parseExpressionStatement = function (node, expr) {
	  node.expression = expr;
	  this.semicolon();
	  return this.finishNode(node, "ExpressionStatement");
	};

	// Parse a semicolon-enclosed block of statements, handling `"use
	// strict"` declarations when `allowStrict` is true (used for
	// function bodies).

	pp.parseBlock = function (allowStrict) {
	  var node = this.startNode(),
	      first = true,
	      oldStrict = undefined;
	  node.body = [];
	  this.expect(tt.braceL);
	  while (!this.eat(tt.braceR)) {
	    var stmt = this.parseStatement(true);
	    node.body.push(stmt);
	    if (first && allowStrict && this.isUseStrict(stmt)) {
	      oldStrict = this.strict;
	      this.setStrict(this.strict = true);
	    }
	    first = false;
	  }
	  if (oldStrict === false) this.setStrict(false);
	  return this.finishNode(node, "BlockStatement");
	};

	// Parse a regular `for` loop. The disambiguation code in
	// `parseStatement` will already have parsed the init statement or
	// expression.

	pp.parseFor = function (node, init) {
	  node.init = init;
	  this.expect(tt.semi);
	  node.test = this.type === tt.semi ? null : this.parseExpression();
	  this.expect(tt.semi);
	  node.update = this.type === tt.parenR ? null : this.parseExpression();
	  this.expect(tt.parenR);
	  node.body = this.parseStatement(false);
	  this.labels.pop();
	  return this.finishNode(node, "ForStatement");
	};

	// Parse a `for`/`in` and `for`/`of` loop, which are almost
	// same from parser's perspective.

	pp.parseForIn = function (node, init) {
	  var type = this.type === tt._in ? "ForInStatement" : "ForOfStatement";
	  this.next();
	  node.left = init;
	  node.right = this.parseExpression();
	  this.expect(tt.parenR);
	  node.body = this.parseStatement(false);
	  this.labels.pop();
	  return this.finishNode(node, type);
	};

	// Parse a list of variable declarations.

	pp.parseVar = function (node, isFor, kind) {
	  node.declarations = [];
	  node.kind = kind.keyword;
	  for (;;) {
	    var decl = this.startNode();
	    this.parseVarId(decl);
	    if (this.eat(tt.eq)) {
	      decl.init = this.parseMaybeAssign(isFor);
	    } else if (kind === tt._const && !(this.type === tt._in || this.options.ecmaVersion >= 6 && this.isContextual("of"))) {
	      this.unexpected();
	    } else if (decl.id.type != "Identifier" && !(isFor && (this.type === tt._in || this.isContextual("of")))) {
	      this.raise(this.lastTokEnd, "Complex binding patterns require an initialization value");
	    } else {
	      decl.init = null;
	    }
	    node.declarations.push(this.finishNode(decl, "VariableDeclarator"));
	    if (!this.eat(tt.comma)) break;
	  }
	  return node;
	};

	pp.parseVarId = function (decl) {
	  decl.id = this.parseBindingAtom();
	  this.checkLVal(decl.id, true);
	};

	// Parse a function declaration or literal (depending on the
	// `isStatement` parameter).

	pp.parseFunction = function (node, isStatement, allowExpressionBody) {
	  this.initFunction(node);
	  if (this.options.ecmaVersion >= 6) node.generator = this.eat(tt.star);
	  if (isStatement || this.type === tt.name) node.id = this.parseIdent();
	  this.parseFunctionParams(node);
	  this.parseFunctionBody(node, allowExpressionBody);
	  return this.finishNode(node, isStatement ? "FunctionDeclaration" : "FunctionExpression");
	};

	pp.parseFunctionParams = function (node) {
	  this.expect(tt.parenL);
	  node.params = this.parseBindingList(tt.parenR, false, false);
	};

	// Parse a class declaration or literal (depending on the
	// `isStatement` parameter).

	pp.parseClass = function (node, isStatement) {
	  this.next();
	  this.parseClassId(node, isStatement);
	  this.parseClassSuper(node);
	  var classBody = this.startNode();
	  var hadConstructor = false;
	  classBody.body = [];
	  this.expect(tt.braceL);
	  while (!this.eat(tt.braceR)) {
	    if (this.eat(tt.semi)) continue;
	    var method = this.startNode();
	    var isGenerator = this.eat(tt.star);
	    var isMaybeStatic = this.type === tt.name && this.value === "static";
	    this.parsePropertyName(method);
	    method["static"] = isMaybeStatic && this.type !== tt.parenL;
	    if (method["static"]) {
	      if (isGenerator) this.unexpected();
	      isGenerator = this.eat(tt.star);
	      this.parsePropertyName(method);
	    }
	    method.kind = "method";
	    if (!method.computed) {
	      var key = method.key;

	      var isGetSet = false;
	      if (!isGenerator && key.type === "Identifier" && this.type !== tt.parenL && (key.name === "get" || key.name === "set")) {
	        isGetSet = true;
	        method.kind = key.name;
	        key = this.parsePropertyName(method);
	      }
	      if (!method["static"] && (key.type === "Identifier" && key.name === "constructor" || key.type === "Literal" && key.value === "constructor")) {
	        if (hadConstructor) this.raise(key.start, "Duplicate constructor in the same class");
	        if (isGetSet) this.raise(key.start, "Constructor can't have get/set modifier");
	        if (isGenerator) this.raise(key.start, "Constructor can't be a generator");
	        method.kind = "constructor";
	        hadConstructor = true;
	      }
	    }
	    this.parseClassMethod(classBody, method, isGenerator);
	  }
	  node.body = this.finishNode(classBody, "ClassBody");
	  return this.finishNode(node, isStatement ? "ClassDeclaration" : "ClassExpression");
	};

	pp.parseClassMethod = function (classBody, method, isGenerator) {
	  method.value = this.parseMethod(isGenerator);
	  classBody.body.push(this.finishNode(method, "MethodDefinition"));
	};

	pp.parseClassId = function (node, isStatement) {
	  node.id = this.type === tt.name ? this.parseIdent() : isStatement ? this.unexpected() : null;
	};

	pp.parseClassSuper = function (node) {
	  node.superClass = this.eat(tt._extends) ? this.parseExprSubscripts() : null;
	};

	// Parses module export declaration.

	pp.parseExport = function (node) {
	  this.next();
	  // export * from '...'
	  if (this.eat(tt.star)) {
	    this.expectContextual("from");
	    node.source = this.type === tt.string ? this.parseExprAtom() : this.unexpected();
	    this.semicolon();
	    return this.finishNode(node, "ExportAllDeclaration");
	  }
	  if (this.eat(tt._default)) {
	    // export default ...
	    var expr = this.parseMaybeAssign();
	    var needsSemi = true;
	    if (expr.type == "FunctionExpression" || expr.type == "ClassExpression") {
	      needsSemi = false;
	      if (expr.id) {
	        expr.type = expr.type == "FunctionExpression" ? "FunctionDeclaration" : "ClassDeclaration";
	      }
	    }
	    node.declaration = expr;
	    if (needsSemi) this.semicolon();
	    return this.finishNode(node, "ExportDefaultDeclaration");
	  }
	  // export var|const|let|function|class ...
	  if (this.shouldParseExportStatement()) {
	    node.declaration = this.parseStatement(true);
	    node.specifiers = [];
	    node.source = null;
	  } else {
	    // export { x, y as z } [from '...']
	    node.declaration = null;
	    node.specifiers = this.parseExportSpecifiers();
	    if (this.eatContextual("from")) {
	      node.source = this.type === tt.string ? this.parseExprAtom() : this.unexpected();
	    } else {
	      node.source = null;
	    }
	    this.semicolon();
	  }
	  return this.finishNode(node, "ExportNamedDeclaration");
	};

	pp.shouldParseExportStatement = function () {
	  return this.type.keyword;
	};

	// Parses a comma-separated list of module exports.

	pp.parseExportSpecifiers = function () {
	  var nodes = [],
	      first = true;
	  // export { x, y as z } [from '...']
	  this.expect(tt.braceL);
	  while (!this.eat(tt.braceR)) {
	    if (!first) {
	      this.expect(tt.comma);
	      if (this.afterTrailingComma(tt.braceR)) break;
	    } else first = false;

	    var node = this.startNode();
	    node.local = this.parseIdent(this.type === tt._default);
	    node.exported = this.eatContextual("as") ? this.parseIdent(true) : node.local;
	    nodes.push(this.finishNode(node, "ExportSpecifier"));
	  }
	  return nodes;
	};

	// Parses import declaration.

	pp.parseImport = function (node) {
	  this.next();
	  // import '...'
	  if (this.type === tt.string) {
	    node.specifiers = empty;
	    node.source = this.parseExprAtom();
	    node.kind = "";
	  } else {
	    node.specifiers = this.parseImportSpecifiers();
	    this.expectContextual("from");
	    node.source = this.type === tt.string ? this.parseExprAtom() : this.unexpected();
	  }
	  this.semicolon();
	  return this.finishNode(node, "ImportDeclaration");
	};

	// Parses a comma-separated list of module imports.

	pp.parseImportSpecifiers = function () {
	  var nodes = [],
	      first = true;
	  if (this.type === tt.name) {
	    // import defaultObj, { x, y as z } from '...'
	    var node = this.startNode();
	    node.local = this.parseIdent();
	    this.checkLVal(node.local, true);
	    nodes.push(this.finishNode(node, "ImportDefaultSpecifier"));
	    if (!this.eat(tt.comma)) return nodes;
	  }
	  if (this.type === tt.star) {
	    var node = this.startNode();
	    this.next();
	    this.expectContextual("as");
	    node.local = this.parseIdent();
	    this.checkLVal(node.local, true);
	    nodes.push(this.finishNode(node, "ImportNamespaceSpecifier"));
	    return nodes;
	  }
	  this.expect(tt.braceL);
	  while (!this.eat(tt.braceR)) {
	    if (!first) {
	      this.expect(tt.comma);
	      if (this.afterTrailingComma(tt.braceR)) break;
	    } else first = false;

	    var node = this.startNode();
	    node.imported = this.parseIdent(true);
	    node.local = this.eatContextual("as") ? this.parseIdent() : node.imported;
	    this.checkLVal(node.local, true);
	    nodes.push(this.finishNode(node, "ImportSpecifier"));
	  }
	  return nodes;
	};

	},{"./state":13,"./tokentype":17,"./whitespace":19}],15:[function(_dereq_,module,exports){
	"use strict";

	var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } };

	exports.__esModule = true;
	// The algorithm used to determine whether a regexp can appear at a
	// given point in the program is loosely based on sweet.js' approach.
	// See https://github.com/mozilla/sweet.js/wiki/design

	var Parser = _dereq_("./state").Parser;

	var tt = _dereq_("./tokentype").types;

	var lineBreak = _dereq_("./whitespace").lineBreak;

	var TokContext = exports.TokContext = function TokContext(token, isExpr, preserveSpace, override) {
	  _classCallCheck(this, TokContext);

	  this.token = token;
	  this.isExpr = isExpr;
	  this.preserveSpace = preserveSpace;
	  this.override = override;
	};

	var types = {
	  b_stat: new TokContext("{", false),
	  b_expr: new TokContext("{", true),
	  b_tmpl: new TokContext("${", true),
	  p_stat: new TokContext("(", false),
	  p_expr: new TokContext("(", true),
	  q_tmpl: new TokContext("`", true, true, function (p) {
	    return p.readTmplToken();
	  }),
	  f_expr: new TokContext("function", true)
	};

	exports.types = types;
	var pp = Parser.prototype;

	pp.initialContext = function () {
	  return [types.b_stat];
	};

	pp.braceIsBlock = function (prevType) {
	  var parent = undefined;
	  if (prevType === tt.colon && (parent = this.curContext()).token == "{") return !parent.isExpr;
	  if (prevType === tt._return) return lineBreak.test(this.input.slice(this.lastTokEnd, this.start));
	  if (prevType === tt._else || prevType === tt.semi || prevType === tt.eof) return true;
	  if (prevType == tt.braceL) return this.curContext() === types.b_stat;
	  return !this.exprAllowed;
	};

	pp.updateContext = function (prevType) {
	  var update = undefined,
	      type = this.type;
	  if (type.keyword && prevType == tt.dot) this.exprAllowed = false;else if (update = type.updateContext) update.call(this, prevType);else this.exprAllowed = type.beforeExpr;
	};

	// Token-specific context update code

	tt.parenR.updateContext = tt.braceR.updateContext = function () {
	  if (this.context.length == 1) {
	    this.exprAllowed = true;
	    return;
	  }
	  var out = this.context.pop();
	  if (out === types.b_stat && this.curContext() === types.f_expr) {
	    this.context.pop();
	    this.exprAllowed = false;
	  } else if (out === types.b_tmpl) {
	    this.exprAllowed = true;
	  } else {
	    this.exprAllowed = !out.isExpr;
	  }
	};

	tt.braceL.updateContext = function (prevType) {
	  this.context.push(this.braceIsBlock(prevType) ? types.b_stat : types.b_expr);
	  this.exprAllowed = true;
	};

	tt.dollarBraceL.updateContext = function () {
	  this.context.push(types.b_tmpl);
	  this.exprAllowed = true;
	};

	tt.parenL.updateContext = function (prevType) {
	  var statementParens = prevType === tt._if || prevType === tt._for || prevType === tt._with || prevType === tt._while;
	  this.context.push(statementParens ? types.p_stat : types.p_expr);
	  this.exprAllowed = true;
	};

	tt.incDec.updateContext = function () {};

	tt._function.updateContext = function () {
	  if (this.curContext() !== types.b_stat) this.context.push(types.f_expr);
	  this.exprAllowed = false;
	};

	tt.backQuote.updateContext = function () {
	  if (this.curContext() === types.q_tmpl) this.context.pop();else this.context.push(types.q_tmpl);
	  this.exprAllowed = false;
	};

	// tokExprAllowed stays unchanged

	},{"./state":13,"./tokentype":17,"./whitespace":19}],16:[function(_dereq_,module,exports){
	"use strict";

	var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } };

	exports.__esModule = true;

	var _identifier = _dereq_("./identifier");

	var isIdentifierStart = _identifier.isIdentifierStart;
	var isIdentifierChar = _identifier.isIdentifierChar;

	var _tokentype = _dereq_("./tokentype");

	var tt = _tokentype.types;
	var keywordTypes = _tokentype.keywords;

	var Parser = _dereq_("./state").Parser;

	var SourceLocation = _dereq_("./location").SourceLocation;

	var _whitespace = _dereq_("./whitespace");

	var lineBreak = _whitespace.lineBreak;
	var lineBreakG = _whitespace.lineBreakG;
	var isNewLine = _whitespace.isNewLine;
	var nonASCIIwhitespace = _whitespace.nonASCIIwhitespace;

	// Object type used to represent tokens. Note that normally, tokens
	// simply exist as properties on the parser object. This is only
	// used for the onToken callback and the external tokenizer.

	var Token = exports.Token = function Token(p) {
	  _classCallCheck(this, Token);

	  this.type = p.type;
	  this.value = p.value;
	  this.start = p.start;
	  this.end = p.end;
	  if (p.options.locations) this.loc = new SourceLocation(p, p.startLoc, p.endLoc);
	  if (p.options.ranges) this.range = [p.start, p.end];
	};

	// ## Tokenizer

	var pp = Parser.prototype;

	// Are we running under Rhino?
	var isRhino = typeof Packages !== "undefined";

	// Move to the next token

	pp.next = function () {
	  if (this.options.onToken) this.options.onToken(new Token(this));

	  this.lastTokEnd = this.end;
	  this.lastTokStart = this.start;
	  this.lastTokEndLoc = this.endLoc;
	  this.lastTokStartLoc = this.startLoc;
	  this.nextToken();
	};

	pp.getToken = function () {
	  this.next();
	  return new Token(this);
	};

	// If we're in an ES6 environment, make parsers iterable
	if (typeof Symbol !== "undefined") pp[Symbol.iterator] = function () {
	  var self = this;
	  return { next: function next() {
	      var token = self.getToken();
	      return {
	        done: token.type === tt.eof,
	        value: token
	      };
	    } };
	};

	// Toggle strict mode. Re-reads the next number or string to please
	// pedantic tests (`"use strict"; 010;` should fail).

	pp.setStrict = function (strict) {
	  this.strict = strict;
	  if (this.type !== tt.num && this.type !== tt.string) return;
	  this.pos = this.start;
	  if (this.options.locations) {
	    while (this.pos < this.lineStart) {
	      this.lineStart = this.input.lastIndexOf("\n", this.lineStart - 2) + 1;
	      --this.curLine;
	    }
	  }
	  this.nextToken();
	};

	pp.curContext = function () {
	  return this.context[this.context.length - 1];
	};

	// Read a single token, updating the parser object's token-related
	// properties.

	pp.nextToken = function () {
	  var curContext = this.curContext();
	  if (!curContext || !curContext.preserveSpace) this.skipSpace();

	  this.start = this.pos;
	  if (this.options.locations) this.startLoc = this.curPosition();
	  if (this.pos >= this.input.length) return this.finishToken(tt.eof);

	  if (curContext.override) return curContext.override(this);else this.readToken(this.fullCharCodeAtPos());
	};

	pp.readToken = function (code) {
	  // Identifier or keyword. '\uXXXX' sequences are allowed in
	  // identifiers, so '\' also dispatches to that.
	  if (isIdentifierStart(code, this.options.ecmaVersion >= 6) || code === 92 /* '\' */) return this.readWord();

	  return this.getTokenFromCode(code);
	};

	pp.fullCharCodeAtPos = function () {
	  var code = this.input.charCodeAt(this.pos);
	  if (code <= 55295 || code >= 57344) return code;
	  var next = this.input.charCodeAt(this.pos + 1);
	  return (code << 10) + next - 56613888;
	};

	pp.skipBlockComment = function () {
	  var startLoc = this.options.onComment && this.options.locations && this.curPosition();
	  var start = this.pos,
	      end = this.input.indexOf("*/", this.pos += 2);
	  if (end === -1) this.raise(this.pos - 2, "Unterminated comment");
	  this.pos = end + 2;
	  if (this.options.locations) {
	    lineBreakG.lastIndex = start;
	    var match = undefined;
	    while ((match = lineBreakG.exec(this.input)) && match.index < this.pos) {
	      ++this.curLine;
	      this.lineStart = match.index + match[0].length;
	    }
	  }
	  if (this.options.onComment) this.options.onComment(true, this.input.slice(start + 2, end), start, this.pos, startLoc, this.options.locations && this.curPosition());
	};

	pp.skipLineComment = function (startSkip) {
	  var start = this.pos;
	  var startLoc = this.options.onComment && this.options.locations && this.curPosition();
	  var ch = this.input.charCodeAt(this.pos += startSkip);
	  while (this.pos < this.input.length && ch !== 10 && ch !== 13 && ch !== 8232 && ch !== 8233) {
	    ++this.pos;
	    ch = this.input.charCodeAt(this.pos);
	  }
	  if (this.options.onComment) this.options.onComment(false, this.input.slice(start + startSkip, this.pos), start, this.pos, startLoc, this.options.locations && this.curPosition());
	};

	// Called at the start of the parse and after every token. Skips
	// whitespace and comments, and.

	pp.skipSpace = function () {
	  while (this.pos < this.input.length) {
	    var ch = this.input.charCodeAt(this.pos);
	    if (ch === 32) {
	      // ' '
	      ++this.pos;
	    } else if (ch === 13) {
	      ++this.pos;
	      var next = this.input.charCodeAt(this.pos);
	      if (next === 10) {
	        ++this.pos;
	      }
	      if (this.options.locations) {
	        ++this.curLine;
	        this.lineStart = this.pos;
	      }
	    } else if (ch === 10 || ch === 8232 || ch === 8233) {
	      ++this.pos;
	      if (this.options.locations) {
	        ++this.curLine;
	        this.lineStart = this.pos;
	      }
	    } else if (ch > 8 && ch < 14) {
	      ++this.pos;
	    } else if (ch === 47) {
	      // '/'
	      var next = this.input.charCodeAt(this.pos + 1);
	      if (next === 42) {
	        // '*'
	        this.skipBlockComment();
	      } else if (next === 47) {
	        // '/'
	        this.skipLineComment(2);
	      } else break;
	    } else if (ch === 160) {
	      // '\xa0'
	      ++this.pos;
	    } else if (ch >= 5760 && nonASCIIwhitespace.test(String.fromCharCode(ch))) {
	      ++this.pos;
	    } else {
	      break;
	    }
	  }
	};

	// Called at the end of every token. Sets `end`, `val`, and
	// maintains `context` and `exprAllowed`, and skips the space after
	// the token, so that the next one's `start` will point at the
	// right position.

	pp.finishToken = function (type, val) {
	  this.end = this.pos;
	  if (this.options.locations) this.endLoc = this.curPosition();
	  var prevType = this.type;
	  this.type = type;
	  this.value = val;

	  this.updateContext(prevType);
	};

	// ### Token reading

	// This is the function that is called to fetch the next token. It
	// is somewhat obscure, because it works in character codes rather
	// than characters, and because operator parsing has been inlined
	// into it.
	//
	// All in the name of speed.
	//
	pp.readToken_dot = function () {
	  var next = this.input.charCodeAt(this.pos + 1);
	  if (next >= 48 && next <= 57) return this.readNumber(true);
	  var next2 = this.input.charCodeAt(this.pos + 2);
	  if (this.options.ecmaVersion >= 6 && next === 46 && next2 === 46) {
	    // 46 = dot '.'
	    this.pos += 3;
	    return this.finishToken(tt.ellipsis);
	  } else {
	    ++this.pos;
	    return this.finishToken(tt.dot);
	  }
	};

	pp.readToken_slash = function () {
	  // '/'
	  var next = this.input.charCodeAt(this.pos + 1);
	  if (this.exprAllowed) {
	    ++this.pos;return this.readRegexp();
	  }
	  if (next === 61) return this.finishOp(tt.assign, 2);
	  return this.finishOp(tt.slash, 1);
	};

	pp.readToken_mult_modulo = function (code) {
	  // '%*'
	  var next = this.input.charCodeAt(this.pos + 1);
	  if (next === 61) return this.finishOp(tt.assign, 2);
	  return this.finishOp(code === 42 ? tt.star : tt.modulo, 1);
	};

	pp.readToken_pipe_amp = function (code) {
	  // '|&'
	  var next = this.input.charCodeAt(this.pos + 1);
	  if (next === code) return this.finishOp(code === 124 ? tt.logicalOR : tt.logicalAND, 2);
	  if (next === 61) return this.finishOp(tt.assign, 2);
	  return this.finishOp(code === 124 ? tt.bitwiseOR : tt.bitwiseAND, 1);
	};

	pp.readToken_caret = function () {
	  // '^'
	  var next = this.input.charCodeAt(this.pos + 1);
	  if (next === 61) return this.finishOp(tt.assign, 2);
	  return this.finishOp(tt.bitwiseXOR, 1);
	};

	pp.readToken_plus_min = function (code) {
	  // '+-'
	  var next = this.input.charCodeAt(this.pos + 1);
	  if (next === code) {
	    if (next == 45 && this.input.charCodeAt(this.pos + 2) == 62 && lineBreak.test(this.input.slice(this.lastTokEnd, this.pos))) {
	      // A `-->` line comment
	      this.skipLineComment(3);
	      this.skipSpace();
	      return this.nextToken();
	    }
	    return this.finishOp(tt.incDec, 2);
	  }
	  if (next === 61) return this.finishOp(tt.assign, 2);
	  return this.finishOp(tt.plusMin, 1);
	};

	pp.readToken_lt_gt = function (code) {
	  // '<>'
	  var next = this.input.charCodeAt(this.pos + 1);
	  var size = 1;
	  if (next === code) {
	    size = code === 62 && this.input.charCodeAt(this.pos + 2) === 62 ? 3 : 2;
	    if (this.input.charCodeAt(this.pos + size) === 61) return this.finishOp(tt.assign, size + 1);
	    return this.finishOp(tt.bitShift, size);
	  }
	  if (next == 33 && code == 60 && this.input.charCodeAt(this.pos + 2) == 45 && this.input.charCodeAt(this.pos + 3) == 45) {
	    if (this.inModule) this.unexpected();
	    // `<!--`, an XML-style comment that should be interpreted as a line comment
	    this.skipLineComment(4);
	    this.skipSpace();
	    return this.nextToken();
	  }
	  if (next === 61) size = this.input.charCodeAt(this.pos + 2) === 61 ? 3 : 2;
	  return this.finishOp(tt.relational, size);
	};

	pp.readToken_eq_excl = function (code) {
	  // '=!'
	  var next = this.input.charCodeAt(this.pos + 1);
	  if (next === 61) return this.finishOp(tt.equality, this.input.charCodeAt(this.pos + 2) === 61 ? 3 : 2);
	  if (code === 61 && next === 62 && this.options.ecmaVersion >= 6) {
	    // '=>'
	    this.pos += 2;
	    return this.finishToken(tt.arrow);
	  }
	  return this.finishOp(code === 61 ? tt.eq : tt.prefix, 1);
	};

	pp.getTokenFromCode = function (code) {
	  switch (code) {
	    // The interpretation of a dot depends on whether it is followed
	    // by a digit or another two dots.
	    case 46:
	      // '.'
	      return this.readToken_dot();

	    // Punctuation tokens.
	    case 40:
	      ++this.pos;return this.finishToken(tt.parenL);
	    case 41:
	      ++this.pos;return this.finishToken(tt.parenR);
	    case 59:
	      ++this.pos;return this.finishToken(tt.semi);
	    case 44:
	      ++this.pos;return this.finishToken(tt.comma);
	    case 91:
	      ++this.pos;return this.finishToken(tt.bracketL);
	    case 93:
	      ++this.pos;return this.finishToken(tt.bracketR);
	    case 123:
	      ++this.pos;return this.finishToken(tt.braceL);
	    case 125:
	      ++this.pos;return this.finishToken(tt.braceR);
	    case 58:
	      ++this.pos;return this.finishToken(tt.colon);
	    case 63:
	      ++this.pos;return this.finishToken(tt.question);

	    case 96:
	      // '`'
	      if (this.options.ecmaVersion < 6) break;
	      ++this.pos;
	      return this.finishToken(tt.backQuote);

	    case 48:
	      // '0'
	      var next = this.input.charCodeAt(this.pos + 1);
	      if (next === 120 || next === 88) return this.readRadixNumber(16); // '0x', '0X' - hex number
	      if (this.options.ecmaVersion >= 6) {
	        if (next === 111 || next === 79) return this.readRadixNumber(8); // '0o', '0O' - octal number
	        if (next === 98 || next === 66) return this.readRadixNumber(2); // '0b', '0B' - binary number
	      }
	    // Anything else beginning with a digit is an integer, octal
	    // number, or float.
	    case 49:case 50:case 51:case 52:case 53:case 54:case 55:case 56:case 57:
	      // 1-9
	      return this.readNumber(false);

	    // Quotes produce strings.
	    case 34:case 39:
	      // '"', "'"
	      return this.readString(code);

	    // Operators are parsed inline in tiny state machines. '=' (61) is
	    // often referred to. `finishOp` simply skips the amount of
	    // characters it is given as second argument, and returns a token
	    // of the type given by its first argument.

	    case 47:
	      // '/'
	      return this.readToken_slash();

	    case 37:case 42:
	      // '%*'
	      return this.readToken_mult_modulo(code);

	    case 124:case 38:
	      // '|&'
	      return this.readToken_pipe_amp(code);

	    case 94:
	      // '^'
	      return this.readToken_caret();

	    case 43:case 45:
	      // '+-'
	      return this.readToken_plus_min(code);

	    case 60:case 62:
	      // '<>'
	      return this.readToken_lt_gt(code);

	    case 61:case 33:
	      // '=!'
	      return this.readToken_eq_excl(code);

	    case 126:
	      // '~'
	      return this.finishOp(tt.prefix, 1);
	  }

	  this.raise(this.pos, "Unexpected character '" + codePointToString(code) + "'");
	};

	pp.finishOp = function (type, size) {
	  var str = this.input.slice(this.pos, this.pos + size);
	  this.pos += size;
	  return this.finishToken(type, str);
	};

	var regexpUnicodeSupport = false;
	try {
	  new RegExp("", "u");regexpUnicodeSupport = true;
	} catch (e) {}

	// Parse a regular expression. Some context-awareness is necessary,
	// since a '/' inside a '[]' set does not end the expression.

	pp.readRegexp = function () {
	  var escaped = undefined,
	      inClass = undefined,
	      start = this.pos;
	  for (;;) {
	    if (this.pos >= this.input.length) this.raise(start, "Unterminated regular expression");
	    var ch = this.input.charAt(this.pos);
	    if (lineBreak.test(ch)) this.raise(start, "Unterminated regular expression");
	    if (!escaped) {
	      if (ch === "[") inClass = true;else if (ch === "]" && inClass) inClass = false;else if (ch === "/" && !inClass) break;
	      escaped = ch === "\\";
	    } else escaped = false;
	    ++this.pos;
	  }
	  var content = this.input.slice(start, this.pos);
	  ++this.pos;
	  // Need to use `readWord1` because '\uXXXX' sequences are allowed
	  // here (don't ask).
	  var mods = this.readWord1();
	  var tmp = content;
	  if (mods) {
	    var validFlags = /^[gmsiy]*$/;
	    if (this.options.ecmaVersion >= 6) validFlags = /^[gmsiyu]*$/;
	    if (!validFlags.test(mods)) this.raise(start, "Invalid regular expression flag");
	    if (mods.indexOf("u") >= 0 && !regexpUnicodeSupport) {
	      // Replace each astral symbol and every Unicode escape sequence that
	      // possibly represents an astral symbol or a paired surrogate with a
	      // single ASCII symbol to avoid throwing on regular expressions that
	      // are only valid in combination with the `/u` flag.
	      // Note: replacing with the ASCII symbol `x` might cause false
	      // negatives in unlikely scenarios. For example, `[\u{61}-b]` is a
	      // perfectly valid pattern that is equivalent to `[a-b]`, but it would
	      // be replaced by `[x-b]` which throws an error.
	      tmp = tmp.replace(/\\u([a-fA-F0-9]{4})|\\u\{([0-9a-fA-F]+)\}|[\uD800-\uDBFF][\uDC00-\uDFFF]/g, "x");
	    }
	  }
	  // Detect invalid regular expressions.
	  var value = null;
	  // Rhino's regular expression parser is flaky and throws uncatchable exceptions,
	  // so don't do detection if we are running under Rhino
	  if (!isRhino) {
	    try {
	      new RegExp(tmp);
	    } catch (e) {
	      if (e instanceof SyntaxError) this.raise(start, "Error parsing regular expression: " + e.message);
	      this.raise(e);
	    }
	    // Get a regular expression object for this pattern-flag pair, or `null` in
	    // case the current environment doesn't support the flags it uses.
	    try {
	      value = new RegExp(content, mods);
	    } catch (err) {}
	  }
	  return this.finishToken(tt.regexp, { pattern: content, flags: mods, value: value });
	};

	// Read an integer in the given radix. Return null if zero digits
	// were read, the integer value otherwise. When `len` is given, this
	// will return `null` unless the integer has exactly `len` digits.

	pp.readInt = function (radix, len) {
	  var start = this.pos,
	      total = 0;
	  for (var i = 0, e = len == null ? Infinity : len; i < e; ++i) {
	    var code = this.input.charCodeAt(this.pos),
	        val = undefined;
	    if (code >= 97) val = code - 97 + 10; // a
	    else if (code >= 65) val = code - 65 + 10; // A
	    else if (code >= 48 && code <= 57) val = code - 48; // 0-9
	    else val = Infinity;
	    if (val >= radix) break;
	    ++this.pos;
	    total = total * radix + val;
	  }
	  if (this.pos === start || len != null && this.pos - start !== len) return null;

	  return total;
	};

	pp.readRadixNumber = function (radix) {
	  this.pos += 2; // 0x
	  var val = this.readInt(radix);
	  if (val == null) this.raise(this.start + 2, "Expected number in radix " + radix);
	  if (isIdentifierStart(this.fullCharCodeAtPos())) this.raise(this.pos, "Identifier directly after number");
	  return this.finishToken(tt.num, val);
	};

	// Read an integer, octal integer, or floating-point number.

	pp.readNumber = function (startsWithDot) {
	  var start = this.pos,
	      isFloat = false,
	      octal = this.input.charCodeAt(this.pos) === 48;
	  if (!startsWithDot && this.readInt(10) === null) this.raise(start, "Invalid number");
	  if (this.input.charCodeAt(this.pos) === 46) {
	    ++this.pos;
	    this.readInt(10);
	    isFloat = true;
	  }
	  var next = this.input.charCodeAt(this.pos);
	  if (next === 69 || next === 101) {
	    // 'eE'
	    next = this.input.charCodeAt(++this.pos);
	    if (next === 43 || next === 45) ++this.pos; // '+-'
	    if (this.readInt(10) === null) this.raise(start, "Invalid number");
	    isFloat = true;
	  }
	  if (isIdentifierStart(this.fullCharCodeAtPos())) this.raise(this.pos, "Identifier directly after number");

	  var str = this.input.slice(start, this.pos),
	      val = undefined;
	  if (isFloat) val = parseFloat(str);else if (!octal || str.length === 1) val = parseInt(str, 10);else if (/[89]/.test(str) || this.strict) this.raise(start, "Invalid number");else val = parseInt(str, 8);
	  return this.finishToken(tt.num, val);
	};

	// Read a string value, interpreting backslash-escapes.

	pp.readCodePoint = function () {
	  var ch = this.input.charCodeAt(this.pos),
	      code = undefined;

	  if (ch === 123) {
	    if (this.options.ecmaVersion < 6) this.unexpected();
	    ++this.pos;
	    code = this.readHexChar(this.input.indexOf("}", this.pos) - this.pos);
	    ++this.pos;
	    if (code > 1114111) this.unexpected();
	  } else {
	    code = this.readHexChar(4);
	  }
	  return code;
	};

	function codePointToString(code) {
	  // UTF-16 Decoding
	  if (code <= 65535) {
	    return String.fromCharCode(code);
	  }return String.fromCharCode((code - 65536 >> 10) + 55296, (code - 65536 & 1023) + 56320);
	}

	pp.readString = function (quote) {
	  var out = "",
	      chunkStart = ++this.pos;
	  for (;;) {
	    if (this.pos >= this.input.length) this.raise(this.start, "Unterminated string constant");
	    var ch = this.input.charCodeAt(this.pos);
	    if (ch === quote) break;
	    if (ch === 92) {
	      // '\'
	      out += this.input.slice(chunkStart, this.pos);
	      out += this.readEscapedChar();
	      chunkStart = this.pos;
	    } else {
	      if (isNewLine(ch)) this.raise(this.start, "Unterminated string constant");
	      ++this.pos;
	    }
	  }
	  out += this.input.slice(chunkStart, this.pos++);
	  return this.finishToken(tt.string, out);
	};

	// Reads template string tokens.

	pp.readTmplToken = function () {
	  var out = "",
	      chunkStart = this.pos;
	  for (;;) {
	    if (this.pos >= this.input.length) this.raise(this.start, "Unterminated template");
	    var ch = this.input.charCodeAt(this.pos);
	    if (ch === 96 || ch === 36 && this.input.charCodeAt(this.pos + 1) === 123) {
	      // '`', '${'
	      if (this.pos === this.start && this.type === tt.template) {
	        if (ch === 36) {
	          this.pos += 2;
	          return this.finishToken(tt.dollarBraceL);
	        } else {
	          ++this.pos;
	          return this.finishToken(tt.backQuote);
	        }
	      }
	      out += this.input.slice(chunkStart, this.pos);
	      return this.finishToken(tt.template, out);
	    }
	    if (ch === 92) {
	      // '\'
	      out += this.input.slice(chunkStart, this.pos);
	      out += this.readEscapedChar();
	      chunkStart = this.pos;
	    } else if (isNewLine(ch)) {
	      out += this.input.slice(chunkStart, this.pos);
	      ++this.pos;
	      if (ch === 13 && this.input.charCodeAt(this.pos) === 10) {
	        ++this.pos;
	        out += "\n";
	      } else {
	        out += String.fromCharCode(ch);
	      }
	      if (this.options.locations) {
	        ++this.curLine;
	        this.lineStart = this.pos;
	      }
	      chunkStart = this.pos;
	    } else {
	      ++this.pos;
	    }
	  }
	};

	// Used to read escaped characters

	pp.readEscapedChar = function () {
	  var ch = this.input.charCodeAt(++this.pos);
	  var octal = /^[0-7]+/.exec(this.input.slice(this.pos, this.pos + 3));
	  if (octal) octal = octal[0];
	  while (octal && parseInt(octal, 8) > 255) octal = octal.slice(0, -1);
	  if (octal === "0") octal = null;
	  ++this.pos;
	  if (octal) {
	    if (this.strict) this.raise(this.pos - 2, "Octal literal in strict mode");
	    this.pos += octal.length - 1;
	    return String.fromCharCode(parseInt(octal, 8));
	  } else {
	    switch (ch) {
	      case 110:
	        return "\n"; // 'n' -> '\n'
	      case 114:
	        return "\r"; // 'r' -> '\r'
	      case 120:
	        return String.fromCharCode(this.readHexChar(2)); // 'x'
	      case 117:
	        return codePointToString(this.readCodePoint()); // 'u'
	      case 116:
	        return "\t"; // 't' -> '\t'
	      case 98:
	        return "\b"; // 'b' -> '\b'
	      case 118:
	        return "\u000b"; // 'v' -> '\u000b'
	      case 102:
	        return "\f"; // 'f' -> '\f'
	      case 48:
	        return "\u0000"; // 0 -> '\0'
	      case 13:
	        if (this.input.charCodeAt(this.pos) === 10) ++this.pos; // '\r\n'
	      case 10:
	        // ' \n'
	        if (this.options.locations) {
	          this.lineStart = this.pos;++this.curLine;
	        }
	        return "";
	      default:
	        return String.fromCharCode(ch);
	    }
	  }
	};

	// Used to read character escape sequences ('\x', '\u', '\U').

	pp.readHexChar = function (len) {
	  var n = this.readInt(16, len);
	  if (n === null) this.raise(this.start, "Bad character escape sequence");
	  return n;
	};

	// Used to signal to callers of `readWord1` whether the word
	// contained any escape sequences. This is needed because words with
	// escape sequences must not be interpreted as keywords.

	var containsEsc;

	// Read an identifier, and return it as a string. Sets `containsEsc`
	// to whether the word contained a '\u' escape.
	//
	// Incrementally adds only escaped chars, adding other chunks as-is
	// as a micro-optimization.

	pp.readWord1 = function () {
	  containsEsc = false;
	  var word = "",
	      first = true,
	      chunkStart = this.pos;
	  var astral = this.options.ecmaVersion >= 6;
	  while (this.pos < this.input.length) {
	    var ch = this.fullCharCodeAtPos();
	    if (isIdentifierChar(ch, astral)) {
	      this.pos += ch <= 65535 ? 1 : 2;
	    } else if (ch === 92) {
	      // "\"
	      containsEsc = true;
	      word += this.input.slice(chunkStart, this.pos);
	      var escStart = this.pos;
	      if (this.input.charCodeAt(++this.pos) != 117) // "u"
	        this.raise(this.pos, "Expecting Unicode escape sequence \\uXXXX");
	      ++this.pos;
	      var esc = this.readCodePoint();
	      if (!(first ? isIdentifierStart : isIdentifierChar)(esc, astral)) this.raise(escStart, "Invalid Unicode escape");
	      word += codePointToString(esc);
	      chunkStart = this.pos;
	    } else {
	      break;
	    }
	    first = false;
	  }
	  return word + this.input.slice(chunkStart, this.pos);
	};

	// Read an identifier or keyword token. Will check for reserved
	// words when necessary.

	pp.readWord = function () {
	  var word = this.readWord1();
	  var type = tt.name;
	  if ((this.options.ecmaVersion >= 6 || !containsEsc) && this.isKeyword(word)) type = keywordTypes[word];
	  return this.finishToken(type, word);
	};

	},{"./identifier":7,"./location":8,"./state":13,"./tokentype":17,"./whitespace":19}],17:[function(_dereq_,module,exports){
	"use strict";

	var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } };

	exports.__esModule = true;
	// ## Token types

	// The assignment of fine-grained, information-carrying type objects
	// allows the tokenizer to store the information it has about a
	// token in a way that is very cheap for the parser to look up.

	// All token type variables start with an underscore, to make them
	// easy to recognize.

	// The `beforeExpr` property is used to disambiguate between regular
	// expressions and divisions. It is set on all token types that can
	// be followed by an expression (thus, a slash after them would be a
	// regular expression).
	//
	// `isLoop` marks a keyword as starting a loop, which is important
	// to know when parsing a label, in order to allow or disallow
	// continue jumps to that label.

	var TokenType = exports.TokenType = function TokenType(label) {
	  var conf = arguments[1] === undefined ? {} : arguments[1];

	  _classCallCheck(this, TokenType);

	  this.label = label;
	  this.keyword = conf.keyword;
	  this.beforeExpr = !!conf.beforeExpr;
	  this.startsExpr = !!conf.startsExpr;
	  this.isLoop = !!conf.isLoop;
	  this.isAssign = !!conf.isAssign;
	  this.prefix = !!conf.prefix;
	  this.postfix = !!conf.postfix;
	  this.binop = conf.binop || null;
	  this.updateContext = null;
	};

	function binop(name, prec) {
	  return new TokenType(name, { beforeExpr: true, binop: prec });
	}
	var beforeExpr = { beforeExpr: true },
	    startsExpr = { startsExpr: true };

	var types = {
	  num: new TokenType("num", startsExpr),
	  regexp: new TokenType("regexp", startsExpr),
	  string: new TokenType("string", startsExpr),
	  name: new TokenType("name", startsExpr),
	  eof: new TokenType("eof"),

	  // Punctuation token types.
	  bracketL: new TokenType("[", { beforeExpr: true, startsExpr: true }),
	  bracketR: new TokenType("]"),
	  braceL: new TokenType("{", { beforeExpr: true, startsExpr: true }),
	  braceR: new TokenType("}"),
	  parenL: new TokenType("(", { beforeExpr: true, startsExpr: true }),
	  parenR: new TokenType(")"),
	  comma: new TokenType(",", beforeExpr),
	  semi: new TokenType(";", beforeExpr),
	  colon: new TokenType(":", beforeExpr),
	  dot: new TokenType("."),
	  question: new TokenType("?", beforeExpr),
	  arrow: new TokenType("=>", beforeExpr),
	  template: new TokenType("template"),
	  ellipsis: new TokenType("...", beforeExpr),
	  backQuote: new TokenType("`", startsExpr),
	  dollarBraceL: new TokenType("${", { beforeExpr: true, startsExpr: true }),

	  // Operators. These carry several kinds of properties to help the
	  // parser use them properly (the presence of these properties is
	  // what categorizes them as operators).
	  //
	  // `binop`, when present, specifies that this operator is a binary
	  // operator, and will refer to its precedence.
	  //
	  // `prefix` and `postfix` mark the operator as a prefix or postfix
	  // unary operator.
	  //
	  // `isAssign` marks all of `=`, `+=`, `-=` etcetera, which act as
	  // binary operators with a very low precedence, that should result
	  // in AssignmentExpression nodes.

	  eq: new TokenType("=", { beforeExpr: true, isAssign: true }),
	  assign: new TokenType("_=", { beforeExpr: true, isAssign: true }),
	  incDec: new TokenType("++/--", { prefix: true, postfix: true, startsExpr: true }),
	  prefix: new TokenType("prefix", { beforeExpr: true, prefix: true, startsExpr: true }),
	  logicalOR: binop("||", 1),
	  logicalAND: binop("&&", 2),
	  bitwiseOR: binop("|", 3),
	  bitwiseXOR: binop("^", 4),
	  bitwiseAND: binop("&", 5),
	  equality: binop("==/!=", 6),
	  relational: binop("</>", 7),
	  bitShift: binop("<</>>", 8),
	  plusMin: new TokenType("+/-", { beforeExpr: true, binop: 9, prefix: true, startsExpr: true }),
	  modulo: binop("%", 10),
	  star: binop("*", 10),
	  slash: binop("/", 10)
	};

	exports.types = types;
	// Map keyword names to token types.

	var keywords = {};

	exports.keywords = keywords;
	// Succinct definitions of keyword token types
	function kw(name) {
	  var options = arguments[1] === undefined ? {} : arguments[1];

	  options.keyword = name;
	  keywords[name] = types["_" + name] = new TokenType(name, options);
	}

	kw("break");
	kw("case", beforeExpr);
	kw("catch");
	kw("continue");
	kw("debugger");
	kw("default");
	kw("do", { isLoop: true });
	kw("else", beforeExpr);
	kw("finally");
	kw("for", { isLoop: true });
	kw("function", startsExpr);
	kw("if");
	kw("return", beforeExpr);
	kw("switch");
	kw("throw", beforeExpr);
	kw("try");
	kw("var");
	kw("let");
	kw("const");
	kw("while", { isLoop: true });
	kw("with");
	kw("new", { beforeExpr: true, startsExpr: true });
	kw("this", startsExpr);
	kw("super", startsExpr);
	kw("class");
	kw("extends", beforeExpr);
	kw("export");
	kw("import");
	kw("yield", { beforeExpr: true, startsExpr: true });
	kw("null", startsExpr);
	kw("true", startsExpr);
	kw("false", startsExpr);
	kw("in", { beforeExpr: true, binop: 7 });
	kw("instanceof", { beforeExpr: true, binop: 7 });
	kw("typeof", { beforeExpr: true, prefix: true, startsExpr: true });
	kw("void", { beforeExpr: true, prefix: true, startsExpr: true });
	kw("delete", { beforeExpr: true, prefix: true, startsExpr: true });

	},{}],18:[function(_dereq_,module,exports){
	"use strict";

	exports.isArray = isArray;

	// Checks if an object has a property.

	exports.has = has;
	exports.__esModule = true;

	function isArray(obj) {
	  return Object.prototype.toString.call(obj) === "[object Array]";
	}

	function has(obj, propName) {
	  return Object.prototype.hasOwnProperty.call(obj, propName);
	}

	},{}],19:[function(_dereq_,module,exports){
	"use strict";

	exports.isNewLine = isNewLine;
	exports.__esModule = true;
	// Matches a whole line break (where CRLF is considered a single
	// line break). Used to count lines.

	var lineBreak = /\r\n?|\n|\u2028|\u2029/;
	exports.lineBreak = lineBreak;
	var lineBreakG = new RegExp(lineBreak.source, "g");

	exports.lineBreakG = lineBreakG;

	function isNewLine(code) {
	  return code === 10 || code === 13 || code === 8232 || code == 8233;
	}

	var nonASCIIwhitespace = /[\u1680\u180e\u2000-\u200a\u202f\u205f\u3000\ufeff]/;
	exports.nonASCIIwhitespace = nonASCIIwhitespace;

	},{}]},{},[1])(1)
	});
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 44 */
/***/ function(module, exports, __webpack_require__) {

	var require;var require;(function(f){if(true){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}(g.acorn || (g.acorn = {})).walk = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return require(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(_dereq_,module,exports){
	"use strict";

	var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } };

	// AST walker module for Mozilla Parser API compatible trees

	// A simple walk is one where you simply specify callbacks to be
	// called on specific nodes. The last two arguments are optional. A
	// simple use would be
	//
	//     walk.simple(myTree, {
	//         Expression: function(node) { ... }
	//     });
	//
	// to do something with all expressions. All Parser API node types
	// can be used to identify node types, as well as Expression,
	// Statement, and ScopeBody, which denote categories of nodes.
	//
	// The base argument can be used to pass a custom (recursive)
	// walker, and state can be used to give this walked an initial
	// state.

	exports.simple = simple;

	// An ancestor walk builds up an array of ancestor nodes (including
	// the current node) and passes them to the callback as the state parameter.
	exports.ancestor = ancestor;

	// A recursive walk is one where your functions override the default
	// walkers. They can modify and replace the state parameter that's
	// threaded through the walk, and can opt how and whether to walk
	// their child nodes (by calling their third argument on these
	// nodes).
	exports.recursive = recursive;

	// Find a node with a given start, end, and type (all are optional,
	// null can be used as wildcard). Returns a {node, state} object, or
	// undefined when it doesn't find a matching node.
	exports.findNodeAt = findNodeAt;

	// Find the innermost node of a given type that contains the given
	// position. Interface similar to findNodeAt.
	exports.findNodeAround = findNodeAround;

	// Find the outermost matching node after a given position.
	exports.findNodeAfter = findNodeAfter;

	// Find the outermost matching node before a given position.
	exports.findNodeBefore = findNodeBefore;

	// Used to create a custom walker. Will fill in all missing node
	// type properties with the defaults.
	exports.make = make;
	exports.__esModule = true;

	function simple(node, visitors, base, state) {
	  if (!base) base = exports.base;(function c(node, st, override) {
	    var type = override || node.type,
	        found = visitors[type];
	    base[type](node, st, c);
	    if (found) found(node, st);
	  })(node, state);
	}

	function ancestor(node, visitors, base, state) {
	  if (!base) base = exports.base;
	  if (!state) state = [];(function c(node, st, override) {
	    var type = override || node.type,
	        found = visitors[type];
	    if (node != st[st.length - 1]) {
	      st = st.slice();
	      st.push(node);
	    }
	    base[type](node, st, c);
	    if (found) found(node, st);
	  })(node, state);
	}

	function recursive(node, state, funcs, base) {
	  var visitor = funcs ? exports.make(funcs, base) : base;(function c(node, st, override) {
	    visitor[override || node.type](node, st, c);
	  })(node, state);
	}

	function makeTest(test) {
	  if (typeof test == "string") {
	    return function (type) {
	      return type == test;
	    };
	  } else if (!test) {
	    return function () {
	      return true;
	    };
	  } else {
	    return test;
	  }
	}

	var Found = function Found(node, state) {
	  _classCallCheck(this, Found);

	  this.node = node;this.state = state;
	};

	function findNodeAt(node, start, end, test, base, state) {
	  test = makeTest(test);
	  if (!base) base = exports.base;
	  try {
	    ;(function c(node, st, override) {
	      var type = override || node.type;
	      if ((start == null || node.start <= start) && (end == null || node.end >= end)) base[type](node, st, c);
	      if (test(type, node) && (start == null || node.start == start) && (end == null || node.end == end)) throw new Found(node, st);
	    })(node, state);
	  } catch (e) {
	    if (e instanceof Found) {
	      return e;
	    }throw e;
	  }
	}

	function findNodeAround(node, pos, test, base, state) {
	  test = makeTest(test);
	  if (!base) base = exports.base;
	  try {
	    ;(function c(node, st, override) {
	      var type = override || node.type;
	      if (node.start > pos || node.end < pos) {
	        return;
	      }base[type](node, st, c);
	      if (test(type, node)) throw new Found(node, st);
	    })(node, state);
	  } catch (e) {
	    if (e instanceof Found) {
	      return e;
	    }throw e;
	  }
	}

	function findNodeAfter(node, pos, test, base, state) {
	  test = makeTest(test);
	  if (!base) base = exports.base;
	  try {
	    ;(function c(node, st, override) {
	      if (node.end < pos) {
	        return;
	      }var type = override || node.type;
	      if (node.start >= pos && test(type, node)) throw new Found(node, st);
	      base[type](node, st, c);
	    })(node, state);
	  } catch (e) {
	    if (e instanceof Found) {
	      return e;
	    }throw e;
	  }
	}

	function findNodeBefore(node, pos, test, base, state) {
	  test = makeTest(test);
	  if (!base) base = exports.base;
	  var max = undefined;(function c(node, st, override) {
	    if (node.start > pos) {
	      return;
	    }var type = override || node.type;
	    if (node.end <= pos && (!max || max.node.end < node.end) && test(type, node)) max = new Found(node, st);
	    base[type](node, st, c);
	  })(node, state);
	  return max;
	}

	function make(funcs, base) {
	  if (!base) base = exports.base;
	  var visitor = {};
	  for (var type in base) visitor[type] = base[type];
	  for (var type in funcs) visitor[type] = funcs[type];
	  return visitor;
	}

	function skipThrough(node, st, c) {
	  c(node, st);
	}
	function ignore(_node, _st, _c) {}

	// Node walkers.

	var base = {};

	exports.base = base;
	base.Program = base.BlockStatement = function (node, st, c) {
	  for (var i = 0; i < node.body.length; ++i) {
	    c(node.body[i], st, "Statement");
	  }
	};
	base.Statement = skipThrough;
	base.EmptyStatement = ignore;
	base.ExpressionStatement = base.ParenthesizedExpression = function (node, st, c) {
	  return c(node.expression, st, "Expression");
	};
	base.IfStatement = function (node, st, c) {
	  c(node.test, st, "Expression");
	  c(node.consequent, st, "Statement");
	  if (node.alternate) c(node.alternate, st, "Statement");
	};
	base.LabeledStatement = function (node, st, c) {
	  return c(node.body, st, "Statement");
	};
	base.BreakStatement = base.ContinueStatement = ignore;
	base.WithStatement = function (node, st, c) {
	  c(node.object, st, "Expression");
	  c(node.body, st, "Statement");
	};
	base.SwitchStatement = function (node, st, c) {
	  c(node.discriminant, st, "Expression");
	  for (var i = 0; i < node.cases.length; ++i) {
	    var cs = node.cases[i];
	    if (cs.test) c(cs.test, st, "Expression");
	    for (var j = 0; j < cs.consequent.length; ++j) {
	      c(cs.consequent[j], st, "Statement");
	    }
	  }
	};
	base.ReturnStatement = base.YieldExpression = function (node, st, c) {
	  if (node.argument) c(node.argument, st, "Expression");
	};
	base.ThrowStatement = base.SpreadElement = base.RestElement = function (node, st, c) {
	  return c(node.argument, st, "Expression");
	};
	base.TryStatement = function (node, st, c) {
	  c(node.block, st, "Statement");
	  if (node.handler) c(node.handler.body, st, "ScopeBody");
	  if (node.finalizer) c(node.finalizer, st, "Statement");
	};
	base.WhileStatement = base.DoWhileStatement = function (node, st, c) {
	  c(node.test, st, "Expression");
	  c(node.body, st, "Statement");
	};
	base.ForStatement = function (node, st, c) {
	  if (node.init) c(node.init, st, "ForInit");
	  if (node.test) c(node.test, st, "Expression");
	  if (node.update) c(node.update, st, "Expression");
	  c(node.body, st, "Statement");
	};
	base.ForInStatement = base.ForOfStatement = function (node, st, c) {
	  c(node.left, st, "ForInit");
	  c(node.right, st, "Expression");
	  c(node.body, st, "Statement");
	};
	base.ForInit = function (node, st, c) {
	  if (node.type == "VariableDeclaration") c(node, st);else c(node, st, "Expression");
	};
	base.DebuggerStatement = ignore;

	base.FunctionDeclaration = function (node, st, c) {
	  return c(node, st, "Function");
	};
	base.VariableDeclaration = function (node, st, c) {
	  for (var i = 0; i < node.declarations.length; ++i) {
	    var decl = node.declarations[i];
	    if (decl.init) c(decl.init, st, "Expression");
	  }
	};

	base.Function = function (node, st, c) {
	  return c(node.body, st, "ScopeBody");
	};
	base.ScopeBody = function (node, st, c) {
	  return c(node, st, "Statement");
	};

	base.Expression = skipThrough;
	base.ThisExpression = base.Super = base.MetaProperty = ignore;
	base.ArrayExpression = base.ArrayPattern = function (node, st, c) {
	  for (var i = 0; i < node.elements.length; ++i) {
	    var elt = node.elements[i];
	    if (elt) c(elt, st, "Expression");
	  }
	};
	base.ObjectExpression = base.ObjectPattern = function (node, st, c) {
	  for (var i = 0; i < node.properties.length; ++i) {
	    c(node.properties[i], st);
	  }
	};
	base.FunctionExpression = base.ArrowFunctionExpression = base.FunctionDeclaration;
	base.SequenceExpression = base.TemplateLiteral = function (node, st, c) {
	  for (var i = 0; i < node.expressions.length; ++i) {
	    c(node.expressions[i], st, "Expression");
	  }
	};
	base.UnaryExpression = base.UpdateExpression = function (node, st, c) {
	  c(node.argument, st, "Expression");
	};
	base.BinaryExpression = base.AssignmentExpression = base.AssignmentPattern = base.LogicalExpression = function (node, st, c) {
	  c(node.left, st, "Expression");
	  c(node.right, st, "Expression");
	};
	base.ConditionalExpression = function (node, st, c) {
	  c(node.test, st, "Expression");
	  c(node.consequent, st, "Expression");
	  c(node.alternate, st, "Expression");
	};
	base.NewExpression = base.CallExpression = function (node, st, c) {
	  c(node.callee, st, "Expression");
	  if (node.arguments) for (var i = 0; i < node.arguments.length; ++i) {
	    c(node.arguments[i], st, "Expression");
	  }
	};
	base.MemberExpression = function (node, st, c) {
	  c(node.object, st, "Expression");
	  if (node.computed) c(node.property, st, "Expression");
	};
	base.ExportNamedDeclaration = base.ExportDefaultDeclaration = function (node, st, c) {
	  return c(node.declaration, st);
	};
	base.ImportDeclaration = function (node, st, c) {
	  for (var i = 0; i < node.specifiers.length; i++) {
	    c(node.specifiers[i], st);
	  }
	};
	base.ImportSpecifier = base.ImportDefaultSpecifier = base.ImportNamespaceSpecifier = base.Identifier = base.Literal = ignore;

	base.TaggedTemplateExpression = function (node, st, c) {
	  c(node.tag, st, "Expression");
	  c(node.quasi, st);
	};
	base.ClassDeclaration = base.ClassExpression = function (node, st, c) {
	  if (node.superClass) c(node.superClass, st, "Expression");
	  for (var i = 0; i < node.body.body.length; i++) {
	    c(node.body.body[i], st);
	  }
	};
	base.MethodDefinition = base.Property = function (node, st, c) {
	  if (node.computed) c(node.key, st, "Expression");
	  c(node.value, st, "Expression");
	};
	base.ComprehensionExpression = function (node, st, c) {
	  for (var i = 0; i < node.blocks.length; i++) {
	    c(node.blocks[i].right, st, "Expression");
	  }c(node.body, st, "Expression");
	};

	},{}]},{},[1])(1)
	});

/***/ },
/* 45 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/**
	The following batches are equivalent:

	var beautify_js = require('js-beautify');
	var beautify_js = require('js-beautify').js;
	var beautify_js = require('js-beautify').js_beautify;

	var beautify_css = require('js-beautify').css;
	var beautify_css = require('js-beautify').css_beautify;

	var beautify_html = require('js-beautify').html;
	var beautify_html = require('js-beautify').html_beautify;

	All methods returned accept two arguments, the source string and an options object.
	**/

	function get_beautify(js_beautify, css_beautify, html_beautify) {
	    // the default is js
	    var beautify = function (src, config) {
	        return js_beautify.js_beautify(src, config);
	    };

	    // short aliases
	    beautify.js   = js_beautify.js_beautify;
	    beautify.css  = css_beautify.css_beautify;
	    beautify.html = html_beautify.html_beautify;

	    // legacy aliases
	    beautify.js_beautify   = js_beautify.js_beautify;
	    beautify.css_beautify  = css_beautify.css_beautify;
	    beautify.html_beautify = html_beautify.html_beautify;

	    return beautify;
	}

	if (true) {
	    // Add support for AMD ( https://github.com/amdjs/amdjs-api/wiki/AMD#defineamd-property- )
	    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	        __webpack_require__(46),
	        __webpack_require__(47),
	        __webpack_require__(48)
	    ], __WEBPACK_AMD_DEFINE_RESULT__ = function(js_beautify, css_beautify, html_beautify) {
	        return get_beautify(js_beautify, css_beautify, html_beautify);
	    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	} else {
	    (function(mod) {
	        var js_beautify = require('./lib/beautify');
	        var css_beautify = require('./lib/beautify-css');
	        var html_beautify = require('./lib/beautify-html');

	        mod.exports = get_beautify(js_beautify, css_beautify, html_beautify);

	    })(module);
	}



/***/ },
/* 46 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*jshint curly:true, eqeqeq:true, laxbreak:true, noempty:false */
	/*

	  The MIT License (MIT)

	  Copyright (c) 2007-2013 Einar Lielmanis and contributors.

	  Permission is hereby granted, free of charge, to any person
	  obtaining a copy of this software and associated documentation files
	  (the "Software"), to deal in the Software without restriction,
	  including without limitation the rights to use, copy, modify, merge,
	  publish, distribute, sublicense, and/or sell copies of the Software,
	  and to permit persons to whom the Software is furnished to do so,
	  subject to the following conditions:

	  The above copyright notice and this permission notice shall be
	  included in all copies or substantial portions of the Software.

	  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
	  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
	  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
	  BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
	  ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
	  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
	  SOFTWARE.

	 JS Beautifier
	---------------


	  Written by Einar Lielmanis, <einar@jsbeautifier.org>
	      http://jsbeautifier.org/

	  Originally converted to javascript by Vital, <vital76@gmail.com>
	  "End braces on own line" added by Chris J. Shull, <chrisjshull@gmail.com>
	  Parsing improvements for brace-less statements by Liam Newman <bitwiseman@gmail.com>


	  Usage:
	    js_beautify(js_source_text);
	    js_beautify(js_source_text, options);

	  The options are:
	    indent_size (default 4)          - indentation size,
	    indent_char (default space)      - character to indent with,
	    preserve_newlines (default true) - whether existing line breaks should be preserved,
	    max_preserve_newlines (default unlimited) - maximum number of line breaks to be preserved in one chunk,

	    jslint_happy (default false) - if true, then jslint-stricter mode is enforced.

	            jslint_happy        !jslint_happy
	            ---------------------------------
	            function ()         function()

	            switch () {         switch() {
	            case 1:               case 1:
	              break;                break;
	            }                   }

	    space_after_anon_function (default false) - should the space before an anonymous function's parens be added, "function()" vs "function ()",
	          NOTE: This option is overriden by jslint_happy (i.e. if jslint_happy is true, space_after_anon_function is true by design)

	    brace_style (default "collapse") - "collapse" | "expand" | "end-expand" | "none"
	            put braces on the same line as control statements (default), or put braces on own line (Allman / ANSI style), or just put end braces on own line, or attempt to keep them where they are.

	    space_before_conditional (default true) - should the space before conditional statement be added, "if(true)" vs "if (true)",

	    unescape_strings (default false) - should printable characters in strings encoded in \xNN notation be unescaped, "example" vs "\x65\x78\x61\x6d\x70\x6c\x65"

	    wrap_line_length (default unlimited) - lines should wrap at next opportunity after this number of characters.
	          NOTE: This is not a hard limit. Lines will continue until a point where a newline would
	                be preserved if it were present.

	    end_with_newline (default false)  - end output with a newline


	    e.g

	    js_beautify(js_source_text, {
	      'indent_size': 1,
	      'indent_char': '\t'
	    });

	*/

	(function() {

	    var acorn = {};
	    (function (exports) {
	      // This section of code is taken from acorn.
	      //
	      // Acorn was written by Marijn Haverbeke and released under an MIT
	      // license. The Unicode regexps (for identifiers and whitespace) were
	      // taken from [Esprima](http://esprima.org) by Ariya Hidayat.
	      //
	      // Git repositories for Acorn are available at
	      //
	      //     http://marijnhaverbeke.nl/git/acorn
	      //     https://github.com/marijnh/acorn.git

	      // ## Character categories

	      // Big ugly regular expressions that match characters in the
	      // whitespace, identifier, and identifier-start categories. These
	      // are only applied when a character is found to actually have a
	      // code point above 128.

	      var nonASCIIwhitespace = /[\u1680\u180e\u2000-\u200a\u202f\u205f\u3000\ufeff]/;
	      var nonASCIIidentifierStartChars = "\xaa\xb5\xba\xc0-\xd6\xd8-\xf6\xf8-\u02c1\u02c6-\u02d1\u02e0-\u02e4\u02ec\u02ee\u0370-\u0374\u0376\u0377\u037a-\u037d\u0386\u0388-\u038a\u038c\u038e-\u03a1\u03a3-\u03f5\u03f7-\u0481\u048a-\u0527\u0531-\u0556\u0559\u0561-\u0587\u05d0-\u05ea\u05f0-\u05f2\u0620-\u064a\u066e\u066f\u0671-\u06d3\u06d5\u06e5\u06e6\u06ee\u06ef\u06fa-\u06fc\u06ff\u0710\u0712-\u072f\u074d-\u07a5\u07b1\u07ca-\u07ea\u07f4\u07f5\u07fa\u0800-\u0815\u081a\u0824\u0828\u0840-\u0858\u08a0\u08a2-\u08ac\u0904-\u0939\u093d\u0950\u0958-\u0961\u0971-\u0977\u0979-\u097f\u0985-\u098c\u098f\u0990\u0993-\u09a8\u09aa-\u09b0\u09b2\u09b6-\u09b9\u09bd\u09ce\u09dc\u09dd\u09df-\u09e1\u09f0\u09f1\u0a05-\u0a0a\u0a0f\u0a10\u0a13-\u0a28\u0a2a-\u0a30\u0a32\u0a33\u0a35\u0a36\u0a38\u0a39\u0a59-\u0a5c\u0a5e\u0a72-\u0a74\u0a85-\u0a8d\u0a8f-\u0a91\u0a93-\u0aa8\u0aaa-\u0ab0\u0ab2\u0ab3\u0ab5-\u0ab9\u0abd\u0ad0\u0ae0\u0ae1\u0b05-\u0b0c\u0b0f\u0b10\u0b13-\u0b28\u0b2a-\u0b30\u0b32\u0b33\u0b35-\u0b39\u0b3d\u0b5c\u0b5d\u0b5f-\u0b61\u0b71\u0b83\u0b85-\u0b8a\u0b8e-\u0b90\u0b92-\u0b95\u0b99\u0b9a\u0b9c\u0b9e\u0b9f\u0ba3\u0ba4\u0ba8-\u0baa\u0bae-\u0bb9\u0bd0\u0c05-\u0c0c\u0c0e-\u0c10\u0c12-\u0c28\u0c2a-\u0c33\u0c35-\u0c39\u0c3d\u0c58\u0c59\u0c60\u0c61\u0c85-\u0c8c\u0c8e-\u0c90\u0c92-\u0ca8\u0caa-\u0cb3\u0cb5-\u0cb9\u0cbd\u0cde\u0ce0\u0ce1\u0cf1\u0cf2\u0d05-\u0d0c\u0d0e-\u0d10\u0d12-\u0d3a\u0d3d\u0d4e\u0d60\u0d61\u0d7a-\u0d7f\u0d85-\u0d96\u0d9a-\u0db1\u0db3-\u0dbb\u0dbd\u0dc0-\u0dc6\u0e01-\u0e30\u0e32\u0e33\u0e40-\u0e46\u0e81\u0e82\u0e84\u0e87\u0e88\u0e8a\u0e8d\u0e94-\u0e97\u0e99-\u0e9f\u0ea1-\u0ea3\u0ea5\u0ea7\u0eaa\u0eab\u0ead-\u0eb0\u0eb2\u0eb3\u0ebd\u0ec0-\u0ec4\u0ec6\u0edc-\u0edf\u0f00\u0f40-\u0f47\u0f49-\u0f6c\u0f88-\u0f8c\u1000-\u102a\u103f\u1050-\u1055\u105a-\u105d\u1061\u1065\u1066\u106e-\u1070\u1075-\u1081\u108e\u10a0-\u10c5\u10c7\u10cd\u10d0-\u10fa\u10fc-\u1248\u124a-\u124d\u1250-\u1256\u1258\u125a-\u125d\u1260-\u1288\u128a-\u128d\u1290-\u12b0\u12b2-\u12b5\u12b8-\u12be\u12c0\u12c2-\u12c5\u12c8-\u12d6\u12d8-\u1310\u1312-\u1315\u1318-\u135a\u1380-\u138f\u13a0-\u13f4\u1401-\u166c\u166f-\u167f\u1681-\u169a\u16a0-\u16ea\u16ee-\u16f0\u1700-\u170c\u170e-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176c\u176e-\u1770\u1780-\u17b3\u17d7\u17dc\u1820-\u1877\u1880-\u18a8\u18aa\u18b0-\u18f5\u1900-\u191c\u1950-\u196d\u1970-\u1974\u1980-\u19ab\u19c1-\u19c7\u1a00-\u1a16\u1a20-\u1a54\u1aa7\u1b05-\u1b33\u1b45-\u1b4b\u1b83-\u1ba0\u1bae\u1baf\u1bba-\u1be5\u1c00-\u1c23\u1c4d-\u1c4f\u1c5a-\u1c7d\u1ce9-\u1cec\u1cee-\u1cf1\u1cf5\u1cf6\u1d00-\u1dbf\u1e00-\u1f15\u1f18-\u1f1d\u1f20-\u1f45\u1f48-\u1f4d\u1f50-\u1f57\u1f59\u1f5b\u1f5d\u1f5f-\u1f7d\u1f80-\u1fb4\u1fb6-\u1fbc\u1fbe\u1fc2-\u1fc4\u1fc6-\u1fcc\u1fd0-\u1fd3\u1fd6-\u1fdb\u1fe0-\u1fec\u1ff2-\u1ff4\u1ff6-\u1ffc\u2071\u207f\u2090-\u209c\u2102\u2107\u210a-\u2113\u2115\u2119-\u211d\u2124\u2126\u2128\u212a-\u212d\u212f-\u2139\u213c-\u213f\u2145-\u2149\u214e\u2160-\u2188\u2c00-\u2c2e\u2c30-\u2c5e\u2c60-\u2ce4\u2ceb-\u2cee\u2cf2\u2cf3\u2d00-\u2d25\u2d27\u2d2d\u2d30-\u2d67\u2d6f\u2d80-\u2d96\u2da0-\u2da6\u2da8-\u2dae\u2db0-\u2db6\u2db8-\u2dbe\u2dc0-\u2dc6\u2dc8-\u2dce\u2dd0-\u2dd6\u2dd8-\u2dde\u2e2f\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303c\u3041-\u3096\u309d-\u309f\u30a1-\u30fa\u30fc-\u30ff\u3105-\u312d\u3131-\u318e\u31a0-\u31ba\u31f0-\u31ff\u3400-\u4db5\u4e00-\u9fcc\ua000-\ua48c\ua4d0-\ua4fd\ua500-\ua60c\ua610-\ua61f\ua62a\ua62b\ua640-\ua66e\ua67f-\ua697\ua6a0-\ua6ef\ua717-\ua71f\ua722-\ua788\ua78b-\ua78e\ua790-\ua793\ua7a0-\ua7aa\ua7f8-\ua801\ua803-\ua805\ua807-\ua80a\ua80c-\ua822\ua840-\ua873\ua882-\ua8b3\ua8f2-\ua8f7\ua8fb\ua90a-\ua925\ua930-\ua946\ua960-\ua97c\ua984-\ua9b2\ua9cf\uaa00-\uaa28\uaa40-\uaa42\uaa44-\uaa4b\uaa60-\uaa76\uaa7a\uaa80-\uaaaf\uaab1\uaab5\uaab6\uaab9-\uaabd\uaac0\uaac2\uaadb-\uaadd\uaae0-\uaaea\uaaf2-\uaaf4\uab01-\uab06\uab09-\uab0e\uab11-\uab16\uab20-\uab26\uab28-\uab2e\uabc0-\uabe2\uac00-\ud7a3\ud7b0-\ud7c6\ud7cb-\ud7fb\uf900-\ufa6d\ufa70-\ufad9\ufb00-\ufb06\ufb13-\ufb17\ufb1d\ufb1f-\ufb28\ufb2a-\ufb36\ufb38-\ufb3c\ufb3e\ufb40\ufb41\ufb43\ufb44\ufb46-\ufbb1\ufbd3-\ufd3d\ufd50-\ufd8f\ufd92-\ufdc7\ufdf0-\ufdfb\ufe70-\ufe74\ufe76-\ufefc\uff21-\uff3a\uff41-\uff5a\uff66-\uffbe\uffc2-\uffc7\uffca-\uffcf\uffd2-\uffd7\uffda-\uffdc";
	      var nonASCIIidentifierChars = "\u0300-\u036f\u0483-\u0487\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u0620-\u0649\u0672-\u06d3\u06e7-\u06e8\u06fb-\u06fc\u0730-\u074a\u0800-\u0814\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0840-\u0857\u08e4-\u08fe\u0900-\u0903\u093a-\u093c\u093e-\u094f\u0951-\u0957\u0962-\u0963\u0966-\u096f\u0981-\u0983\u09bc\u09be-\u09c4\u09c7\u09c8\u09d7\u09df-\u09e0\u0a01-\u0a03\u0a3c\u0a3e-\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a66-\u0a71\u0a75\u0a81-\u0a83\u0abc\u0abe-\u0ac5\u0ac7-\u0ac9\u0acb-\u0acd\u0ae2-\u0ae3\u0ae6-\u0aef\u0b01-\u0b03\u0b3c\u0b3e-\u0b44\u0b47\u0b48\u0b4b-\u0b4d\u0b56\u0b57\u0b5f-\u0b60\u0b66-\u0b6f\u0b82\u0bbe-\u0bc2\u0bc6-\u0bc8\u0bca-\u0bcd\u0bd7\u0be6-\u0bef\u0c01-\u0c03\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62-\u0c63\u0c66-\u0c6f\u0c82\u0c83\u0cbc\u0cbe-\u0cc4\u0cc6-\u0cc8\u0cca-\u0ccd\u0cd5\u0cd6\u0ce2-\u0ce3\u0ce6-\u0cef\u0d02\u0d03\u0d46-\u0d48\u0d57\u0d62-\u0d63\u0d66-\u0d6f\u0d82\u0d83\u0dca\u0dcf-\u0dd4\u0dd6\u0dd8-\u0ddf\u0df2\u0df3\u0e34-\u0e3a\u0e40-\u0e45\u0e50-\u0e59\u0eb4-\u0eb9\u0ec8-\u0ecd\u0ed0-\u0ed9\u0f18\u0f19\u0f20-\u0f29\u0f35\u0f37\u0f39\u0f41-\u0f47\u0f71-\u0f84\u0f86-\u0f87\u0f8d-\u0f97\u0f99-\u0fbc\u0fc6\u1000-\u1029\u1040-\u1049\u1067-\u106d\u1071-\u1074\u1082-\u108d\u108f-\u109d\u135d-\u135f\u170e-\u1710\u1720-\u1730\u1740-\u1750\u1772\u1773\u1780-\u17b2\u17dd\u17e0-\u17e9\u180b-\u180d\u1810-\u1819\u1920-\u192b\u1930-\u193b\u1951-\u196d\u19b0-\u19c0\u19c8-\u19c9\u19d0-\u19d9\u1a00-\u1a15\u1a20-\u1a53\u1a60-\u1a7c\u1a7f-\u1a89\u1a90-\u1a99\u1b46-\u1b4b\u1b50-\u1b59\u1b6b-\u1b73\u1bb0-\u1bb9\u1be6-\u1bf3\u1c00-\u1c22\u1c40-\u1c49\u1c5b-\u1c7d\u1cd0-\u1cd2\u1d00-\u1dbe\u1e01-\u1f15\u200c\u200d\u203f\u2040\u2054\u20d0-\u20dc\u20e1\u20e5-\u20f0\u2d81-\u2d96\u2de0-\u2dff\u3021-\u3028\u3099\u309a\ua640-\ua66d\ua674-\ua67d\ua69f\ua6f0-\ua6f1\ua7f8-\ua800\ua806\ua80b\ua823-\ua827\ua880-\ua881\ua8b4-\ua8c4\ua8d0-\ua8d9\ua8f3-\ua8f7\ua900-\ua909\ua926-\ua92d\ua930-\ua945\ua980-\ua983\ua9b3-\ua9c0\uaa00-\uaa27\uaa40-\uaa41\uaa4c-\uaa4d\uaa50-\uaa59\uaa7b\uaae0-\uaae9\uaaf2-\uaaf3\uabc0-\uabe1\uabec\uabed\uabf0-\uabf9\ufb20-\ufb28\ufe00-\ufe0f\ufe20-\ufe26\ufe33\ufe34\ufe4d-\ufe4f\uff10-\uff19\uff3f";
	      var nonASCIIidentifierStart = new RegExp("[" + nonASCIIidentifierStartChars + "]");
	      var nonASCIIidentifier = new RegExp("[" + nonASCIIidentifierStartChars + nonASCIIidentifierChars + "]");

	      // Whether a single character denotes a newline.

	      var newline = exports.newline = /[\n\r\u2028\u2029]/;

	      // Matches a whole line break (where CRLF is considered a single
	      // line break). Used to count lines.

	      var lineBreak = exports.lineBreak = /\r\n|[\n\r\u2028\u2029]/g;

	      // Test whether a given character code starts an identifier.

	      var isIdentifierStart = exports.isIdentifierStart = function(code) {
	        if (code < 65) return code === 36;
	        if (code < 91) return true;
	        if (code < 97) return code === 95;
	        if (code < 123)return true;
	        return code >= 0xaa && nonASCIIidentifierStart.test(String.fromCharCode(code));
	      };

	      // Test whether a given character is part of an identifier.

	      var isIdentifierChar = exports.isIdentifierChar = function(code) {
	        if (code < 48) return code === 36;
	        if (code < 58) return true;
	        if (code < 65) return false;
	        if (code < 91) return true;
	        if (code < 97) return code === 95;
	        if (code < 123)return true;
	        return code >= 0xaa && nonASCIIidentifier.test(String.fromCharCode(code));
	      };
	    })(acorn);

	    function in_array(what, arr) {
	        for (var i = 0; i < arr.length; i += 1) {
	            if (arr[i] === what) {
	                return true;
	            }
	        }
	        return false;
	    }

	    function trim(s) {
	        return s.replace(/^\s+|\s+$/g, '');
	    }

	    function ltrim(s) {
	        return s.replace(/^\s+/g, '');
	    }

	    function rtrim(s) {
	        return s.replace(/\s+$/g, '');
	    }

	    function js_beautify(js_source_text, options) {
	        "use strict";
	        var beautifier = new Beautifier(js_source_text, options);
	        return beautifier.beautify();
	    }

	    var MODE = {
	            BlockStatement: 'BlockStatement', // 'BLOCK'
	            Statement: 'Statement', // 'STATEMENT'
	            ObjectLiteral: 'ObjectLiteral', // 'OBJECT',
	            ArrayLiteral: 'ArrayLiteral', //'[EXPRESSION]',
	            ForInitializer: 'ForInitializer', //'(FOR-EXPRESSION)',
	            Conditional: 'Conditional', //'(COND-EXPRESSION)',
	            Expression: 'Expression' //'(EXPRESSION)'
	        };

	    function Beautifier(js_source_text, options) {
	        "use strict";
	        var output
	        var tokens = [], token_pos;
	        var Tokenizer;
	        var current_token;
	        var last_type, last_last_text, indent_string;
	        var flags, previous_flags, flag_store;
	        var prefix;

	        var handlers, opt;
	        var baseIndentString = '';

	        handlers = {
	            'TK_START_EXPR': handle_start_expr,
	            'TK_END_EXPR': handle_end_expr,
	            'TK_START_BLOCK': handle_start_block,
	            'TK_END_BLOCK': handle_end_block,
	            'TK_WORD': handle_word,
	            'TK_RESERVED': handle_word,
	            'TK_SEMICOLON': handle_semicolon,
	            'TK_STRING': handle_string,
	            'TK_EQUALS': handle_equals,
	            'TK_OPERATOR': handle_operator,
	            'TK_COMMA': handle_comma,
	            'TK_BLOCK_COMMENT': handle_block_comment,
	            'TK_COMMENT': handle_comment,
	            'TK_DOT': handle_dot,
	            'TK_UNKNOWN': handle_unknown,
	            'TK_EOF': handle_eof
	        };

	        function create_flags(flags_base, mode) {
	            var next_indent_level = 0;
	            if (flags_base) {
	                next_indent_level = flags_base.indentation_level;
	                if (!output.just_added_newline() &&
	                    flags_base.line_indent_level > next_indent_level) {
	                    next_indent_level = flags_base.line_indent_level;
	                }
	            }

	            var next_flags = {
	                mode: mode,
	                parent: flags_base,
	                last_text: flags_base ? flags_base.last_text : '', // last token text
	                last_word: flags_base ? flags_base.last_word : '', // last 'TK_WORD' passed
	                declaration_statement: false,
	                declaration_assignment: false,
	                multiline_frame: false,
	                if_block: false,
	                else_block: false,
	                do_block: false,
	                do_while: false,
	                in_case_statement: false, // switch(..){ INSIDE HERE }
	                in_case: false, // we're on the exact line with "case 0:"
	                case_body: false, // the indented case-action block
	                indentation_level: next_indent_level,
	                line_indent_level: flags_base ? flags_base.line_indent_level : next_indent_level,
	                start_line_index: output.get_line_number(),
	                ternary_depth: 0
	            };
	            return next_flags;
	        }

	        // Some interpreters have unexpected results with foo = baz || bar;
	        options = options ? options : {};
	        opt = {};

	        // compatibility
	        if (options.braces_on_own_line !== undefined) { //graceful handling of deprecated option
	            opt.brace_style = options.braces_on_own_line ? "expand" : "collapse";
	        }
	        opt.brace_style = options.brace_style ? options.brace_style : (opt.brace_style ? opt.brace_style : "collapse");

	        // graceful handling of deprecated option
	        if (opt.brace_style === "expand-strict") {
	            opt.brace_style = "expand";
	        }


	        opt.indent_size = options.indent_size ? parseInt(options.indent_size, 10) : 4;
	        opt.indent_char = options.indent_char ? options.indent_char : ' ';
	        opt.eol = options.eol ? options.eol : '\n';
	        opt.preserve_newlines = (options.preserve_newlines === undefined) ? true : options.preserve_newlines;
	        opt.break_chained_methods = (options.break_chained_methods === undefined) ? false : options.break_chained_methods;
	        opt.max_preserve_newlines = (options.max_preserve_newlines === undefined) ? 0 : parseInt(options.max_preserve_newlines, 10);
	        opt.space_in_paren = (options.space_in_paren === undefined) ? false : options.space_in_paren;
	        opt.space_in_empty_paren = (options.space_in_empty_paren === undefined) ? false : options.space_in_empty_paren;
	        opt.jslint_happy = (options.jslint_happy === undefined) ? false : options.jslint_happy;
	        opt.space_after_anon_function = (options.space_after_anon_function === undefined) ? false : options.space_after_anon_function;
	        opt.keep_array_indentation = (options.keep_array_indentation === undefined) ? false : options.keep_array_indentation;
	        opt.space_before_conditional = (options.space_before_conditional === undefined) ? true : options.space_before_conditional;
	        opt.unescape_strings = (options.unescape_strings === undefined) ? false : options.unescape_strings;
	        opt.wrap_line_length = (options.wrap_line_length === undefined) ? 0 : parseInt(options.wrap_line_length, 10);
	        opt.e4x = (options.e4x === undefined) ? false : options.e4x;
	        opt.end_with_newline = (options.end_with_newline === undefined) ? false : options.end_with_newline;
	        opt.comma_first = (options.comma_first === undefined) ? false : options.comma_first;

	        // For testing of beautify ignore:start directive
	        opt.test_output_raw = (options.test_output_raw === undefined) ? false : options.test_output_raw;

	        // force opt.space_after_anon_function to true if opt.jslint_happy
	        if(opt.jslint_happy) {
	            opt.space_after_anon_function = true;
	        }

	        if(options.indent_with_tabs){
	            opt.indent_char = '\t';
	            opt.indent_size = 1;
	        }

	        opt.eol = opt.eol.replace(/\\r/, '\r').replace(/\\n/, '\n')

	        //----------------------------------
	        indent_string = '';
	        while (opt.indent_size > 0) {
	            indent_string += opt.indent_char;
	            opt.indent_size -= 1;
	        }

	        var preindent_index = 0;
	        if(js_source_text && js_source_text.length) {
	            while ( (js_source_text.charAt(preindent_index) === ' ' ||
	                    js_source_text.charAt(preindent_index) === '\t')) {
	                baseIndentString += js_source_text.charAt(preindent_index);
	                preindent_index += 1;
	            }
	            js_source_text = js_source_text.substring(preindent_index);
	        }

	        last_type = 'TK_START_BLOCK'; // last token type
	        last_last_text = ''; // pre-last token text
	        output = new Output(indent_string, baseIndentString);

	        // If testing the ignore directive, start with output disable set to true
	        output.raw = opt.test_output_raw;


	        // Stack of parsing/formatting states, including MODE.
	        // We tokenize, parse, and output in an almost purely a forward-only stream of token input
	        // and formatted output.  This makes the beautifier less accurate than full parsers
	        // but also far more tolerant of syntax errors.
	        //
	        // For example, the default mode is MODE.BlockStatement. If we see a '{' we push a new frame of type
	        // MODE.BlockStatement on the the stack, even though it could be object literal.  If we later
	        // encounter a ":", we'll switch to to MODE.ObjectLiteral.  If we then see a ";",
	        // most full parsers would die, but the beautifier gracefully falls back to
	        // MODE.BlockStatement and continues on.
	        flag_store = [];
	        set_mode(MODE.BlockStatement);

	        this.beautify = function() {

	            /*jshint onevar:true */
	            var local_token, sweet_code;
	            Tokenizer = new tokenizer(js_source_text, opt, indent_string);
	            tokens = Tokenizer.tokenize();
	            token_pos = 0;

	            while (local_token = get_token()) {
	                for(var i = 0; i < local_token.comments_before.length; i++) {
	                    // The cleanest handling of inline comments is to treat them as though they aren't there.
	                    // Just continue formatting and the behavior should be logical.
	                    // Also ignore unknown tokens.  Again, this should result in better behavior.
	                    handle_token(local_token.comments_before[i]);
	                }
	                handle_token(local_token);

	                last_last_text = flags.last_text;
	                last_type = local_token.type;
	                flags.last_text = local_token.text;

	                token_pos += 1;
	            }

	            sweet_code = output.get_code();
	            if (opt.end_with_newline) {
	                sweet_code += '\n';
	            }

	            if (opt.eol != '\n') {
	                sweet_code = sweet_code.replace(/[\n]/g, opt.eol);
	            }

	            return sweet_code;
	        };

	        function handle_token(local_token) {
	            var newlines = local_token.newlines;
	            var keep_whitespace = opt.keep_array_indentation && is_array(flags.mode);

	            if (keep_whitespace) {
	                for (i = 0; i < newlines; i += 1) {
	                    print_newline(i > 0);
	                }
	            } else {
	                if (opt.max_preserve_newlines && newlines > opt.max_preserve_newlines) {
	                    newlines = opt.max_preserve_newlines;
	                }

	                if (opt.preserve_newlines) {
	                    if (local_token.newlines > 1) {
	                        print_newline();
	                        for (var i = 1; i < newlines; i += 1) {
	                            print_newline(true);
	                        }
	                    }
	                }
	            }

	            current_token = local_token;
	            handlers[current_token.type]();
	        }

	        // we could use just string.split, but
	        // IE doesn't like returning empty strings
	        function split_newlines(s) {
	            //return s.split(/\x0d\x0a|\x0a/);

	            s = s.replace(/\x0d/g, '');
	            var out = [],
	                idx = s.indexOf("\n");
	            while (idx !== -1) {
	                out.push(s.substring(0, idx));
	                s = s.substring(idx + 1);
	                idx = s.indexOf("\n");
	            }
	            if (s.length) {
	                out.push(s);
	            }
	            return out;
	        }

	        function allow_wrap_or_preserved_newline(force_linewrap) {
	            force_linewrap = (force_linewrap === undefined) ? false : force_linewrap;

	            // Never wrap the first token on a line
	            if (output.just_added_newline()) {
	                return
	            }

	            if ((opt.preserve_newlines && current_token.wanted_newline) || force_linewrap) {
	                print_newline(false, true);
	            } else if (opt.wrap_line_length) {
	                var proposed_line_length = output.current_line.get_character_count() + current_token.text.length +
	                    (output.space_before_token ? 1 : 0);
	                if (proposed_line_length >= opt.wrap_line_length) {
	                    print_newline(false, true);
	                }
	            }
	        }

	        function print_newline(force_newline, preserve_statement_flags) {
	            if (!preserve_statement_flags) {
	                if (flags.last_text !== ';' && flags.last_text !== ',' && flags.last_text !== '=' && last_type !== 'TK_OPERATOR') {
	                    while (flags.mode === MODE.Statement && !flags.if_block && !flags.do_block) {
	                        restore_mode();
	                    }
	                }
	            }

	            if (output.add_new_line(force_newline)) {
	                flags.multiline_frame = true;
	            }
	        }

	        function print_token_line_indentation() {
	            if (output.just_added_newline()) {
	                if (opt.keep_array_indentation && is_array(flags.mode) && current_token.wanted_newline) {
	                    output.current_line.push(current_token.whitespace_before);
	                    output.space_before_token = false;
	                } else if (output.set_indent(flags.indentation_level)) {
	                    flags.line_indent_level = flags.indentation_level;
	                }
	            }
	        }

	        function print_token(printable_token) {
	            if (output.raw) {
	                output.add_raw_token(current_token)
	                return;
	            }

	            if (opt.comma_first && last_type === 'TK_COMMA'
	                && output.just_added_newline()) {
	                if(output.previous_line.last() === ',') {
	                    output.previous_line.pop();
	                    print_token_line_indentation();
	                    output.add_token(',');
	                    output.space_before_token = true;
	                }
	            }

	            printable_token = printable_token || current_token.text;
	            print_token_line_indentation();
	            output.add_token(printable_token);
	        }

	        function indent() {
	            flags.indentation_level += 1;
	        }

	        function deindent() {
	            if (flags.indentation_level > 0 &&
	                ((!flags.parent) || flags.indentation_level > flags.parent.indentation_level))
	                flags.indentation_level -= 1;
	        }

	        function set_mode(mode) {
	            if (flags) {
	                flag_store.push(flags);
	                previous_flags = flags;
	            } else {
	                previous_flags = create_flags(null, mode);
	            }

	            flags = create_flags(previous_flags, mode);
	        }

	        function is_array(mode) {
	            return mode === MODE.ArrayLiteral;
	        }

	        function is_expression(mode) {
	            return in_array(mode, [MODE.Expression, MODE.ForInitializer, MODE.Conditional]);
	        }

	        function restore_mode() {
	            if (flag_store.length > 0) {
	                previous_flags = flags;
	                flags = flag_store.pop();
	                if (previous_flags.mode === MODE.Statement) {
	                    output.remove_redundant_indentation(previous_flags);
	                }
	            }
	        }

	        function start_of_object_property() {
	            return flags.parent.mode === MODE.ObjectLiteral && flags.mode === MODE.Statement && (
	                (flags.last_text === ':' && flags.ternary_depth === 0) || (last_type === 'TK_RESERVED' && in_array(flags.last_text, ['get', 'set'])));
	        }

	        function start_of_statement() {
	            if (
	                    (last_type === 'TK_RESERVED' && in_array(flags.last_text, ['var', 'let', 'const']) && current_token.type === 'TK_WORD') ||
	                    (last_type === 'TK_RESERVED' && flags.last_text === 'do') ||
	                    (last_type === 'TK_RESERVED' && flags.last_text === 'return' && !current_token.wanted_newline) ||
	                    (last_type === 'TK_RESERVED' && flags.last_text === 'else' && !(current_token.type === 'TK_RESERVED' && current_token.text === 'if')) ||
	                    (last_type === 'TK_END_EXPR' && (previous_flags.mode === MODE.ForInitializer || previous_flags.mode === MODE.Conditional)) ||
	                    (last_type === 'TK_WORD' && flags.mode === MODE.BlockStatement
	                        && !flags.in_case
	                        && !(current_token.text === '--' || current_token.text === '++')
	                        && last_last_text !== 'function'
	                        && current_token.type !== 'TK_WORD' && current_token.type !== 'TK_RESERVED') ||
	                    (flags.mode === MODE.ObjectLiteral && (
	                        (flags.last_text === ':' && flags.ternary_depth === 0) || (last_type === 'TK_RESERVED' && in_array(flags.last_text, ['get', 'set']))))
	                ) {

	                set_mode(MODE.Statement);
	                indent();

	                if (last_type === 'TK_RESERVED' && in_array(flags.last_text, ['var', 'let', 'const']) && current_token.type === 'TK_WORD') {
	                    flags.declaration_statement = true;
	                }

	                // Issue #276:
	                // If starting a new statement with [if, for, while, do], push to a new line.
	                // if (a) if (b) if(c) d(); else e(); else f();
	                if (!start_of_object_property()) {
	                    allow_wrap_or_preserved_newline(
	                        current_token.type === 'TK_RESERVED' && in_array(current_token.text, ['do', 'for', 'if', 'while']));
	                }

	                return true;
	            }
	            return false;
	        }

	        function all_lines_start_with(lines, c) {
	            for (var i = 0; i < lines.length; i++) {
	                var line = trim(lines[i]);
	                if (line.charAt(0) !== c) {
	                    return false;
	                }
	            }
	            return true;
	        }

	        function each_line_matches_indent(lines, indent) {
	            var i = 0,
	                len = lines.length,
	                line;
	            for (; i < len; i++) {
	                line = lines[i];
	                // allow empty lines to pass through
	                if (line && line.indexOf(indent) !== 0) {
	                    return false;
	                }
	            }
	            return true;
	        }

	        function is_special_word(word) {
	            return in_array(word, ['case', 'return', 'do', 'if', 'throw', 'else']);
	        }

	        function get_token(offset) {
	            var index = token_pos + (offset || 0);
	            return (index < 0 || index >= tokens.length) ? null : tokens[index];
	        }

	        function handle_start_expr() {
	            if (start_of_statement()) {
	                // The conditional starts the statement if appropriate.
	            }

	            var next_mode = MODE.Expression;
	            if (current_token.text === '[') {

	                if (last_type === 'TK_WORD' || flags.last_text === ')') {
	                    // this is array index specifier, break immediately
	                    // a[x], fn()[x]
	                    if (last_type === 'TK_RESERVED' && in_array(flags.last_text, Tokenizer.line_starters)) {
	                        output.space_before_token = true;
	                    }
	                    set_mode(next_mode);
	                    print_token();
	                    indent();
	                    if (opt.space_in_paren) {
	                        output.space_before_token = true;
	                    }
	                    return;
	                }

	                next_mode = MODE.ArrayLiteral;
	                if (is_array(flags.mode)) {
	                    if (flags.last_text === '[' ||
	                        (flags.last_text === ',' && (last_last_text === ']' || last_last_text === '}'))) {
	                        // ], [ goes to new line
	                        // }, [ goes to new line
	                        if (!opt.keep_array_indentation) {
	                            print_newline();
	                        }
	                    }
	                }

	            } else {
	                if (last_type === 'TK_RESERVED' && flags.last_text === 'for') {
	                    next_mode = MODE.ForInitializer;
	                } else if (last_type === 'TK_RESERVED' && in_array(flags.last_text, ['if', 'while'])) {
	                    next_mode = MODE.Conditional;
	                } else {
	                    // next_mode = MODE.Expression;
	                }
	            }

	            if (flags.last_text === ';' || last_type === 'TK_START_BLOCK') {
	                print_newline();
	            } else if (last_type === 'TK_END_EXPR' || last_type === 'TK_START_EXPR' || last_type === 'TK_END_BLOCK' || flags.last_text === '.') {
	                // TODO: Consider whether forcing this is required.  Review failing tests when removed.
	                allow_wrap_or_preserved_newline(current_token.wanted_newline);
	                // do nothing on (( and )( and ][ and ]( and .(
	            } else if (!(last_type === 'TK_RESERVED' && current_token.text === '(') && last_type !== 'TK_WORD' && last_type !== 'TK_OPERATOR') {
	                output.space_before_token = true;
	            } else if ((last_type === 'TK_RESERVED' && (flags.last_word === 'function' || flags.last_word === 'typeof')) ||
	                (flags.last_text === '*' && last_last_text === 'function')) {
	                // function() vs function ()
	                if (opt.space_after_anon_function) {
	                    output.space_before_token = true;
	                }
	            } else if (last_type === 'TK_RESERVED' && (in_array(flags.last_text, Tokenizer.line_starters) || flags.last_text === 'catch')) {
	                if (opt.space_before_conditional) {
	                    output.space_before_token = true;
	                }
	            }

	            // Should be a space between await and an IIFE
	            if(current_token.text === '(' && last_type === 'TK_RESERVED' && flags.last_word === 'await'){
	                output.space_before_token = true;
	            }

	            // Support of this kind of newline preservation.
	            // a = (b &&
	            //     (c || d));
	            if (current_token.text === '(') {
	                if (last_type === 'TK_EQUALS' || last_type === 'TK_OPERATOR') {
	                    if (!start_of_object_property()) {
	                        allow_wrap_or_preserved_newline();
	                    }
	                }
	            }

	            set_mode(next_mode);
	            print_token();
	            if (opt.space_in_paren) {
	                output.space_before_token = true;
	            }

	            // In all cases, if we newline while inside an expression it should be indented.
	            indent();
	        }

	        function handle_end_expr() {
	            // statements inside expressions are not valid syntax, but...
	            // statements must all be closed when their container closes
	            while (flags.mode === MODE.Statement) {
	                restore_mode();
	            }

	            if (flags.multiline_frame) {
	                allow_wrap_or_preserved_newline(current_token.text === ']' && is_array(flags.mode) && !opt.keep_array_indentation);
	            }

	            if (opt.space_in_paren) {
	                if (last_type === 'TK_START_EXPR' && ! opt.space_in_empty_paren) {
	                    // () [] no inner space in empty parens like these, ever, ref #320
	                    output.trim();
	                    output.space_before_token = false;
	                } else {
	                    output.space_before_token = true;
	                }
	            }
	            if (current_token.text === ']' && opt.keep_array_indentation) {
	                print_token();
	                restore_mode();
	            } else {
	                restore_mode();
	                print_token();
	            }
	            output.remove_redundant_indentation(previous_flags);

	            // do {} while () // no statement required after
	            if (flags.do_while && previous_flags.mode === MODE.Conditional) {
	                previous_flags.mode = MODE.Expression;
	                flags.do_block = false;
	                flags.do_while = false;

	            }
	        }

	        function handle_start_block() {
	            // Check if this is should be treated as a ObjectLiteral
	            var next_token = get_token(1)
	            var second_token = get_token(2)
	            if (second_token && (
	                    (second_token.text === ':' && in_array(next_token.type, ['TK_STRING', 'TK_WORD', 'TK_RESERVED']))
	                    || (in_array(next_token.text, ['get', 'set']) && in_array(second_token.type, ['TK_WORD', 'TK_RESERVED']))
	                )) {
	                // We don't support TypeScript,but we didn't break it for a very long time.
	                // We'll try to keep not breaking it.
	                if (!in_array(last_last_text, ['class','interface'])) {
	                    set_mode(MODE.ObjectLiteral);
	                } else {
	                    set_mode(MODE.BlockStatement);
	                }
	            } else {
	                set_mode(MODE.BlockStatement);
	            }

	            var empty_braces = !next_token.comments_before.length &&  next_token.text === '}';
	            var empty_anonymous_function = empty_braces && flags.last_word === 'function' &&
	                last_type === 'TK_END_EXPR';

	            if (opt.brace_style === "expand" ||
	                (opt.brace_style === "none" && current_token.wanted_newline)) {
	                if (last_type !== 'TK_OPERATOR' &&
	                    (empty_anonymous_function ||
	                        last_type === 'TK_EQUALS' ||
	                        (last_type === 'TK_RESERVED' && is_special_word(flags.last_text) && flags.last_text !== 'else'))) {
	                    output.space_before_token = true;
	                } else {
	                    print_newline(false, true);
	                }
	            } else { // collapse
	                if (last_type !== 'TK_OPERATOR' && last_type !== 'TK_START_EXPR') {
	                    if (last_type === 'TK_START_BLOCK') {
	                        print_newline();
	                    } else {
	                        output.space_before_token = true;
	                    }
	                } else {
	                    // if TK_OPERATOR or TK_START_EXPR
	                    if (is_array(previous_flags.mode) && flags.last_text === ',') {
	                        if (last_last_text === '}') {
	                            // }, { in array context
	                            output.space_before_token = true;
	                        } else {
	                            print_newline(); // [a, b, c, {
	                        }
	                    }
	                }
	            }
	            print_token();
	            indent();
	        }

	        function handle_end_block() {
	            // statements must all be closed when their container closes
	            while (flags.mode === MODE.Statement) {
	                restore_mode();
	            }
	            var empty_braces = last_type === 'TK_START_BLOCK';

	            if (opt.brace_style === "expand") {
	                if (!empty_braces) {
	                    print_newline();
	                }
	            } else {
	                // skip {}
	                if (!empty_braces) {
	                    if (is_array(flags.mode) && opt.keep_array_indentation) {
	                        // we REALLY need a newline here, but newliner would skip that
	                        opt.keep_array_indentation = false;
	                        print_newline();
	                        opt.keep_array_indentation = true;

	                    } else {
	                        print_newline();
	                    }
	                }
	            }
	            restore_mode();
	            print_token();
	        }

	        function handle_word() {
	            if (current_token.type === 'TK_RESERVED' && flags.mode !== MODE.ObjectLiteral &&
	                in_array(current_token.text, ['set', 'get'])) {
	                current_token.type = 'TK_WORD';
	            }

	            if (current_token.type === 'TK_RESERVED' && flags.mode === MODE.ObjectLiteral) {
	                var next_token = get_token(1);
	                if (next_token.text == ':') {
	                    current_token.type = 'TK_WORD';
	                }
	            }

	            if (start_of_statement()) {
	                // The conditional starts the statement if appropriate.
	            } else if (current_token.wanted_newline && !is_expression(flags.mode) &&
	                (last_type !== 'TK_OPERATOR' || (flags.last_text === '--' || flags.last_text === '++')) &&
	                last_type !== 'TK_EQUALS' &&
	                (opt.preserve_newlines || !(last_type === 'TK_RESERVED' && in_array(flags.last_text, ['var', 'let', 'const', 'set', 'get'])))) {

	                print_newline();
	            }

	            if (flags.do_block && !flags.do_while) {
	                if (current_token.type === 'TK_RESERVED' && current_token.text === 'while') {
	                    // do {} ## while ()
	                    output.space_before_token = true;
	                    print_token();
	                    output.space_before_token = true;
	                    flags.do_while = true;
	                    return;
	                } else {
	                    // do {} should always have while as the next word.
	                    // if we don't see the expected while, recover
	                    print_newline();
	                    flags.do_block = false;
	                }
	            }

	            // if may be followed by else, or not
	            // Bare/inline ifs are tricky
	            // Need to unwind the modes correctly: if (a) if (b) c(); else d(); else e();
	            if (flags.if_block) {
	                if (!flags.else_block && (current_token.type === 'TK_RESERVED' && current_token.text === 'else')) {
	                    flags.else_block = true;
	                } else {
	                    while (flags.mode === MODE.Statement) {
	                        restore_mode();
	                    }
	                    flags.if_block = false;
	                    flags.else_block = false;
	                }
	            }

	            if (current_token.type === 'TK_RESERVED' && (current_token.text === 'case' || (current_token.text === 'default' && flags.in_case_statement))) {
	                print_newline();
	                if (flags.case_body || opt.jslint_happy) {
	                    // switch cases following one another
	                    deindent();
	                    flags.case_body = false;
	                }
	                print_token();
	                flags.in_case = true;
	                flags.in_case_statement = true;
	                return;
	            }

	            if (current_token.type === 'TK_RESERVED' && current_token.text === 'function') {
	                if (in_array(flags.last_text, ['}', ';']) || (output.just_added_newline() && ! in_array(flags.last_text, ['[', '{', ':', '=', ',']))) {
	                    // make sure there is a nice clean space of at least one blank line
	                    // before a new function definition
	                    if ( !output.just_added_blankline() && !current_token.comments_before.length) {
	                        print_newline();
	                        print_newline(true);
	                    }
	                }
	                if (last_type === 'TK_RESERVED' || last_type === 'TK_WORD') {
	                    if (last_type === 'TK_RESERVED' && in_array(flags.last_text, ['get', 'set', 'new', 'return', 'export', 'async'])) {
	                        output.space_before_token = true;
	                    } else if (last_type === 'TK_RESERVED' && flags.last_text === 'default' && last_last_text === 'export') {
	                        output.space_before_token = true;
	                    } else {
	                        print_newline();
	                    }
	                } else if (last_type === 'TK_OPERATOR' || flags.last_text === '=') {
	                    // foo = function
	                    output.space_before_token = true;
	                } else if (!flags.multiline_frame && (is_expression(flags.mode) || is_array(flags.mode))) {
	                    // (function
	                } else {
	                    print_newline();
	                }
	            }

	            if (last_type === 'TK_COMMA' || last_type === 'TK_START_EXPR' || last_type === 'TK_EQUALS' || last_type === 'TK_OPERATOR') {
	                if (!start_of_object_property()) {
	                    allow_wrap_or_preserved_newline();
	                }
	            }

	            if (current_token.type === 'TK_RESERVED' &&  in_array(current_token.text, ['function', 'get', 'set'])) {
	                print_token();
	                flags.last_word = current_token.text;
	                return;
	            }

	            prefix = 'NONE';

	            if (last_type === 'TK_END_BLOCK') {
	                if (!(current_token.type === 'TK_RESERVED' && in_array(current_token.text, ['else', 'catch', 'finally']))) {
	                    prefix = 'NEWLINE';
	                } else {
	                    if (opt.brace_style === "expand" ||
	                        opt.brace_style === "end-expand" ||
	                        (opt.brace_style === "none" && current_token.wanted_newline)) {
	                        prefix = 'NEWLINE';
	                    } else {
	                        prefix = 'SPACE';
	                        output.space_before_token = true;
	                    }
	                }
	            } else if (last_type === 'TK_SEMICOLON' && flags.mode === MODE.BlockStatement) {
	                // TODO: Should this be for STATEMENT as well?
	                prefix = 'NEWLINE';
	            } else if (last_type === 'TK_SEMICOLON' && is_expression(flags.mode)) {
	                prefix = 'SPACE';
	            } else if (last_type === 'TK_STRING') {
	                prefix = 'NEWLINE';
	            } else if (last_type === 'TK_RESERVED' || last_type === 'TK_WORD' ||
	                (flags.last_text === '*' && last_last_text === 'function')) {
	                prefix = 'SPACE';
	            } else if (last_type === 'TK_START_BLOCK') {
	                prefix = 'NEWLINE';
	            } else if (last_type === 'TK_END_EXPR') {
	                output.space_before_token = true;
	                prefix = 'NEWLINE';
	            }

	            if (current_token.type === 'TK_RESERVED' && in_array(current_token.text, Tokenizer.line_starters) && flags.last_text !== ')') {
	                if (flags.last_text === 'else' || flags.last_text === 'export') {
	                    prefix = 'SPACE';
	                } else {
	                    prefix = 'NEWLINE';
	                }

	            }

	            if (current_token.type === 'TK_RESERVED' && in_array(current_token.text, ['else', 'catch', 'finally'])) {
	                if (last_type !== 'TK_END_BLOCK' ||
	                    opt.brace_style === "expand" ||
	                    opt.brace_style === "end-expand" ||
	                    (opt.brace_style === "none" && current_token.wanted_newline)) {
	                    print_newline();
	                } else {
	                    output.trim(true);
	                    var line = output.current_line;
	                    // If we trimmed and there's something other than a close block before us
	                    // put a newline back in.  Handles '} // comment' scenario.
	                    if (line.last() !== '}') {
	                        print_newline();
	                    }
	                    output.space_before_token = true;
	                }
	            } else if (prefix === 'NEWLINE') {
	                if (last_type === 'TK_RESERVED' && is_special_word(flags.last_text)) {
	                    // no newline between 'return nnn'
	                    output.space_before_token = true;
	                } else if (last_type !== 'TK_END_EXPR') {
	                    if ((last_type !== 'TK_START_EXPR' || !(current_token.type === 'TK_RESERVED' && in_array(current_token.text, ['var', 'let', 'const']))) && flags.last_text !== ':') {
	                        // no need to force newline on 'var': for (var x = 0...)
	                        if (current_token.type === 'TK_RESERVED' && current_token.text === 'if' && flags.last_text === 'else') {
	                            // no newline for } else if {
	                            output.space_before_token = true;
	                        } else {
	                            print_newline();
	                        }
	                    }
	                } else if (current_token.type === 'TK_RESERVED' && in_array(current_token.text, Tokenizer.line_starters) && flags.last_text !== ')') {
	                    print_newline();
	                }
	            } else if (flags.multiline_frame && is_array(flags.mode) && flags.last_text === ',' && last_last_text === '}') {
	                print_newline(); // }, in lists get a newline treatment
	            } else if (prefix === 'SPACE') {
	                output.space_before_token = true;
	            }
	            print_token();
	            flags.last_word = current_token.text;

	            if (current_token.type === 'TK_RESERVED' && current_token.text === 'do') {
	                flags.do_block = true;
	            }

	            if (current_token.type === 'TK_RESERVED' && current_token.text === 'if') {
	                flags.if_block = true;
	            }
	        }

	        function handle_semicolon() {
	            if (start_of_statement()) {
	                // The conditional starts the statement if appropriate.
	                // Semicolon can be the start (and end) of a statement
	                output.space_before_token = false;
	            }
	            while (flags.mode === MODE.Statement && !flags.if_block && !flags.do_block) {
	                restore_mode();
	            }
	            print_token();
	        }

	        function handle_string() {
	            if (start_of_statement()) {
	                // The conditional starts the statement if appropriate.
	                // One difference - strings want at least a space before
	                output.space_before_token = true;
	            } else if (last_type === 'TK_RESERVED' || last_type === 'TK_WORD') {
	                output.space_before_token = true;
	            } else if (last_type === 'TK_COMMA' || last_type === 'TK_START_EXPR' || last_type === 'TK_EQUALS' || last_type === 'TK_OPERATOR') {
	                if (!start_of_object_property()) {
	                    allow_wrap_or_preserved_newline();
	                }
	            } else {
	                print_newline();
	            }
	            print_token();
	        }

	        function handle_equals() {
	            if (start_of_statement()) {
	                // The conditional starts the statement if appropriate.
	            }

	            if (flags.declaration_statement) {
	                // just got an '=' in a var-line, different formatting/line-breaking, etc will now be done
	                flags.declaration_assignment = true;
	            }
	            output.space_before_token = true;
	            print_token();
	            output.space_before_token = true;
	        }

	        function handle_comma() {
	            if (flags.declaration_statement) {
	                if (is_expression(flags.parent.mode)) {
	                    // do not break on comma, for(var a = 1, b = 2)
	                    flags.declaration_assignment = false;
	                }

	                print_token();

	                if (flags.declaration_assignment) {
	                    flags.declaration_assignment = false;
	                    print_newline(false, true);
	                } else {
	                    output.space_before_token = true;
	                    // for comma-first, we want to allow a newline before the comma
	                    // to turn into a newline after the comma, which we will fixup later
	                    if (opt.comma_first) {
	                        allow_wrap_or_preserved_newline();
	                    }
	                }
	                return;
	            }

	            print_token();
	            if (flags.mode === MODE.ObjectLiteral ||
	                (flags.mode === MODE.Statement && flags.parent.mode === MODE.ObjectLiteral)) {
	                if (flags.mode === MODE.Statement) {
	                    restore_mode();
	                }
	                print_newline();
	            } else {
	                // EXPR or DO_BLOCK
	                output.space_before_token = true;
	                // for comma-first, we want to allow a newline before the comma
	                // to turn into a newline after the comma, which we will fixup later
	                if (opt.comma_first) {
	                    allow_wrap_or_preserved_newline();
	                }
	            }

	        }

	        function handle_operator() {
	            if (start_of_statement()) {
	                // The conditional starts the statement if appropriate.
	            }

	            if (last_type === 'TK_RESERVED' && is_special_word(flags.last_text)) {
	                // "return" had a special handling in TK_WORD. Now we need to return the favor
	                output.space_before_token = true;
	                print_token();
	                return;
	            }

	            // hack for actionscript's import .*;
	            if (current_token.text === '*' && last_type === 'TK_DOT') {
	                print_token();
	                return;
	            }

	            if (current_token.text === ':' && flags.in_case) {
	                flags.case_body = true;
	                indent();
	                print_token();
	                print_newline();
	                flags.in_case = false;
	                return;
	            }

	            if (current_token.text === '::') {
	                // no spaces around exotic namespacing syntax operator
	                print_token();
	                return;
	            }

	            // Allow line wrapping between operators
	            if (last_type === 'TK_OPERATOR') {
	                allow_wrap_or_preserved_newline();
	            }

	            var space_before = true;
	            var space_after = true;

	            if (in_array(current_token.text, ['--', '++', '!', '~']) || (in_array(current_token.text, ['-', '+']) && (in_array(last_type, ['TK_START_BLOCK', 'TK_START_EXPR', 'TK_EQUALS', 'TK_OPERATOR']) || in_array(flags.last_text, Tokenizer.line_starters) || flags.last_text === ','))) {
	                // unary operators (and binary +/- pretending to be unary) special cases

	                space_before = false;
	                space_after = false;

	                // http://www.ecma-international.org/ecma-262/5.1/#sec-7.9.1
	                // if there is a newline between -- or ++ and anything else we should preserve it.
	                if (current_token.wanted_newline && (current_token.text === '--' || current_token.text === '++')) {
	                    print_newline(false, true);
	                }

	                if (flags.last_text === ';' && is_expression(flags.mode)) {
	                    // for (;; ++i)
	                    //        ^^^
	                    space_before = true;
	                }

	                if (last_type === 'TK_RESERVED') {
	                    space_before = true;
	                } else if (last_type === 'TK_END_EXPR') {
	                    space_before = !(flags.last_text === ']' && (current_token.text === '--' || current_token.text === '++'));
	                } else if (last_type === 'TK_OPERATOR') {
	                    // a++ + ++b;
	                    // a - -b
	                    space_before = in_array(current_token.text, ['--', '-', '++', '+']) && in_array(flags.last_text, ['--', '-', '++', '+']);
	                    // + and - are not unary when preceeded by -- or ++ operator
	                    // a-- + b
	                    // a * +b
	                    // a - -b
	                    if (in_array(current_token.text, ['+', '-']) && in_array(flags.last_text, ['--', '++'])) {
	                        space_after = true;
	                    }
	                }

	                if ((flags.mode === MODE.BlockStatement || flags.mode === MODE.Statement) && (flags.last_text === '{' || flags.last_text === ';')) {
	                    // { foo; --i }
	                    // foo(); --bar;
	                    print_newline();
	                }
	            } else if (current_token.text === ':') {
	                if (flags.ternary_depth === 0) {
	                    // Colon is invalid javascript outside of ternary and object, but do our best to guess what was meant.
	                    space_before = false;
	                } else {
	                    flags.ternary_depth -= 1;
	                }
	            } else if (current_token.text === '?') {
	                flags.ternary_depth += 1;
	            } else if (current_token.text === '*' && last_type === 'TK_RESERVED' && flags.last_text === 'function') {
	                space_before = false;
	                space_after = false;
	            }
	            output.space_before_token = output.space_before_token || space_before;
	            print_token();
	            output.space_before_token = space_after;
	        }

	        function handle_block_comment() {
	            if (output.raw) {
	                output.add_raw_token(current_token)
	                if (current_token.directives && current_token.directives['preserve'] === 'end') {
	                    // If we're testing the raw output behavior, do not allow a directive to turn it off.
	                    if (!opt.test_output_raw) {
	                        output.raw = false;
	                    }
	                }
	                return;
	            }

	            if (current_token.directives) {
	                print_newline(false, true);
	                print_token();
	                if (current_token.directives['preserve'] === 'start') {
	                    output.raw = true;
	                }
	                print_newline(false, true);
	                return;
	            }

	            // inline block
	            if (!acorn.newline.test(current_token.text) && !current_token.wanted_newline) {
	                output.space_before_token = true;
	                print_token();
	                output.space_before_token = true;
	                return;
	            }

	            var lines = split_newlines(current_token.text);
	            var j; // iterator for this case
	            var javadoc = false;
	            var starless = false;
	            var lastIndent = current_token.whitespace_before;
	            var lastIndentLength = lastIndent.length;

	            // block comment starts with a new line
	            print_newline(false, true);
	            if (lines.length > 1) {
	                if (all_lines_start_with(lines.slice(1), '*')) {
	                    javadoc = true;
	                }
	                else if (each_line_matches_indent(lines.slice(1), lastIndent)) {
	                    starless = true;
	                }
	            }

	            // first line always indented
	            print_token(lines[0]);
	            for (j = 1; j < lines.length; j++) {
	                print_newline(false, true);
	                if (javadoc) {
	                    // javadoc: reformat and re-indent
	                    print_token(' ' + ltrim(lines[j]));
	                } else if (starless && lines[j].length > lastIndentLength) {
	                    // starless: re-indent non-empty content, avoiding trim
	                    print_token(lines[j].substring(lastIndentLength));
	                } else {
	                    // normal comments output raw
	                    output.add_token(lines[j]);
	                }
	            }

	            // for comments of more than one line, make sure there's a new line after
	            print_newline(false, true);
	        }

	        function handle_comment() {
	            if (current_token.wanted_newline) {
	                print_newline(false, true);
	            } else {
	                output.trim(true);
	            }

	            output.space_before_token = true;
	            print_token();
	            print_newline(false, true);
	        }

	        function handle_dot() {
	            if (start_of_statement()) {
	                // The conditional starts the statement if appropriate.
	            }

	            if (last_type === 'TK_RESERVED' && is_special_word(flags.last_text)) {
	                output.space_before_token = true;
	            } else {
	                // allow preserved newlines before dots in general
	                // force newlines on dots after close paren when break_chained - for bar().baz()
	                allow_wrap_or_preserved_newline(flags.last_text === ')' && opt.break_chained_methods);
	            }

	            print_token();
	        }

	        function handle_unknown() {
	            print_token();

	            if (current_token.text[current_token.text.length - 1] === '\n') {
	                print_newline();
	            }
	        }

	        function handle_eof() {
	            // Unwind any open statements
	            while (flags.mode === MODE.Statement) {
	                restore_mode();
	            }
	        }
	    }


	    function OutputLine(parent) {
	        var _character_count = 0;
	        // use indent_count as a marker for lines that have preserved indentation
	        var _indent_count = -1;

	        var _items = [];
	        var _empty = true;

	        this.set_indent = function(level) {
	            _character_count = parent.baseIndentLength + level * parent.indent_length
	            _indent_count = level;
	        }

	        this.get_character_count = function() {
	            return _character_count;
	        }

	        this.is_empty = function() {
	            return _empty;
	        }

	        this.last = function() {
	            if (!this._empty) {
	              return _items[_items.length - 1];
	            } else {
	              return null;
	            }
	        }

	        this.push = function(input) {
	            _items.push(input);
	            _character_count += input.length;
	            _empty = false;
	        }

	        this.pop = function() {
	            var item = null;
	            if (!_empty) {
	                item = _items.pop();
	                _character_count -= item.length;
	                _empty = _items.length === 0;
	            }
	            return item;
	        }

	        this.remove_indent = function() {
	            if (_indent_count > 0) {
	                _indent_count -= 1;
	                _character_count -= parent.indent_length
	            }
	        }

	        this.trim = function() {
	            while (this.last() === ' ') {
	                var item = _items.pop();
	                _character_count -= 1;
	            }
	            _empty = _items.length === 0;
	        }

	        this.toString = function() {
	            var result = '';
	            if (!this._empty) {
	                if (_indent_count >= 0) {
	                    result = parent.indent_cache[_indent_count];
	                }
	                result += _items.join('')
	            }
	            return result;
	        }
	    }

	    function Output(indent_string, baseIndentString) {
	        baseIndentString = baseIndentString || '';
	        this.indent_cache = [ baseIndentString ];
	        this.baseIndentLength = baseIndentString.length;
	        this.indent_length = indent_string.length;
	        this.raw = false;

	        var lines =[];
	        this.baseIndentString = baseIndentString;
	        this.indent_string = indent_string;
	        this.previous_line = null;
	        this.current_line = null;
	        this.space_before_token = false;

	        this.add_outputline = function() {
	            this.previous_line = this.current_line;
	            this.current_line = new OutputLine(this);
	            lines.push(this.current_line);
	        }

	        // initialize
	        this.add_outputline();


	        this.get_line_number = function() {
	            return lines.length;
	        }

	        // Using object instead of string to allow for later expansion of info about each line
	        this.add_new_line = function(force_newline) {
	            if (this.get_line_number() === 1 && this.just_added_newline()) {
	                return false; // no newline on start of file
	            }

	            if (force_newline || !this.just_added_newline()) {
	                if (!this.raw) {
	                    this.add_outputline();
	                }
	                return true;
	            }

	            return false;
	        }

	        this.get_code = function() {
	            var sweet_code = lines.join('\n').replace(/[\r\n\t ]+$/, '');
	            return sweet_code;
	        }

	        this.set_indent = function(level) {
	            // Never indent your first output indent at the start of the file
	            if (lines.length > 1) {
	                while(level >= this.indent_cache.length) {
	                    this.indent_cache.push(this.indent_cache[this.indent_cache.length - 1] + this.indent_string);
	                }

	                this.current_line.set_indent(level);
	                return true;
	            }
	            this.current_line.set_indent(0);
	            return false;
	        }

	        this.add_raw_token = function(token) {
	            for (var x = 0; x < token.newlines; x++) {
	                this.add_outputline();
	            }
	            this.current_line.push(token.whitespace_before);
	            this.current_line.push(token.text);
	            this.space_before_token = false;
	        }

	        this.add_token = function(printable_token) {
	            this.add_space_before_token();
	            this.current_line.push(printable_token);
	        }

	        this.add_space_before_token = function() {
	            if (this.space_before_token && !this.just_added_newline()) {
	                this.current_line.push(' ');
	            }
	            this.space_before_token = false;
	        }

	        this.remove_redundant_indentation = function (frame) {
	            // This implementation is effective but has some issues:
	            //     - can cause line wrap to happen too soon due to indent removal
	            //           after wrap points are calculated
	            // These issues are minor compared to ugly indentation.

	            if (frame.multiline_frame ||
	                frame.mode === MODE.ForInitializer ||
	                frame.mode === MODE.Conditional) {
	                return;
	            }

	            // remove one indent from each line inside this section
	            var index = frame.start_line_index;
	            var line;

	            var output_length = lines.length;
	            while (index < output_length) {
	                lines[index].remove_indent();
	                index++;
	            }
	        }

	        this.trim = function(eat_newlines) {
	            eat_newlines = (eat_newlines === undefined) ? false : eat_newlines;

	            this.current_line.trim(indent_string, baseIndentString);

	            while (eat_newlines && lines.length > 1 &&
	                this.current_line.is_empty()) {
	                lines.pop();
	                this.current_line = lines[lines.length - 1]
	                this.current_line.trim();
	            }

	            this.previous_line = lines.length > 1 ? lines[lines.length - 2] : null;
	        }

	        this.just_added_newline = function() {
	            return this.current_line.is_empty();
	        }

	        this.just_added_blankline = function() {
	            if (this.just_added_newline()) {
	                if (lines.length === 1) {
	                    return true; // start of the file and newline = blank
	                }

	                var line = lines[lines.length - 2];
	                return line.is_empty();
	            }
	            return false;
	        }
	    }


	    var Token = function(type, text, newlines, whitespace_before, mode, parent) {
	        this.type = type;
	        this.text = text;
	        this.comments_before = [];
	        this.newlines = newlines || 0;
	        this.wanted_newline = newlines > 0;
	        this.whitespace_before = whitespace_before || '';
	        this.parent = null;
	        this.directives = null;
	    }

	    function tokenizer(input, opts, indent_string) {

	        var whitespace = "\n\r\t ".split('');
	        var digit = /[0-9]/;
	        var digit_hex = /[0123456789abcdefABCDEF]/;

	        var punct = ('+ - * / % & ++ -- = += -= *= /= %= == === != !== > < >= <= >> << >>> >>>= >>= <<= && &= | || ! ~ , : ? ^ ^= |= :: =>'
	                +' <%= <% %> <?= <? ?>').split(' '); // try to be a good boy and try not to break the markup language identifiers

	        // words which should always start on new line.
	        this.line_starters = 'continue,try,throw,return,var,let,const,if,switch,case,default,for,while,break,function,import,export'.split(',');
	        var reserved_words = this.line_starters.concat(['do', 'in', 'else', 'get', 'set', 'new', 'catch', 'finally', 'typeof', 'yield', 'async', 'await']);

	        //  /* ... */ comment ends with nearest */ or end of file
	        var block_comment_pattern = /([\s\S]*?)((?:\*\/)|$)/g;

	        // comment ends just before nearest linefeed or end of file
	        var comment_pattern = /([^\n\r\u2028\u2029]*)/g;

	        var directives_block_pattern = /\/\* beautify( \w+[:]\w+)+ \*\//g;
	        var directive_pattern = / (\w+)[:](\w+)/g;
	        var directives_end_ignore_pattern = /([\s\S]*?)((?:\/\*\sbeautify\signore:end\s\*\/)|$)/g;

	        var template_pattern = /((<\?php|<\?=)[\s\S]*?\?>)|(<%[\s\S]*?%>)/g

	        var n_newlines, whitespace_before_token, in_html_comment, tokens, parser_pos;
	        var input_length;

	        this.tokenize = function() {
	            // cache the source's length.
	            input_length = input.length
	            parser_pos = 0;
	            in_html_comment = false
	            tokens = [];

	            var next, last;
	            var token_values;
	            var open = null;
	            var open_stack = [];
	            var comments = [];

	            while (!(last && last.type === 'TK_EOF')) {
	                token_values = tokenize_next();
	                next = new Token(token_values[1], token_values[0], n_newlines, whitespace_before_token);
	                while(next.type === 'TK_COMMENT' || next.type === 'TK_BLOCK_COMMENT' || next.type === 'TK_UNKNOWN') {
	                    if (next.type === 'TK_BLOCK_COMMENT') {
	                        next.directives = token_values[2];
	                    }
	                    comments.push(next);
	                    token_values = tokenize_next();
	                    next = new Token(token_values[1], token_values[0], n_newlines, whitespace_before_token);
	                }

	                if (comments.length) {
	                    next.comments_before = comments;
	                    comments = [];
	                }

	                if (next.type === 'TK_START_BLOCK' || next.type === 'TK_START_EXPR') {
	                    next.parent = last;
	                    open_stack.push(open);
	                    open = next;
	                }  else if ((next.type === 'TK_END_BLOCK' || next.type === 'TK_END_EXPR') &&
	                    (open && (
	                        (next.text === ']' && open.text === '[') ||
	                        (next.text === ')' && open.text === '(') ||
	                        (next.text === '}' && open.text === '{')))) {
	                    next.parent = open.parent;
	                    open = open_stack.pop();
	                }

	                tokens.push(next);
	                last = next;
	            }

	            return tokens;
	        }

	        function get_directives (text) {
	            if (!text.match(directives_block_pattern)) {
	                return null;
	            }

	            var directives = {};
	            directive_pattern.lastIndex = 0;
	            var directive_match = directive_pattern.exec(text);

	            while (directive_match) {
	                directives[directive_match[1]] = directive_match[2];
	                directive_match = directive_pattern.exec(text);
	            }

	            return directives;
	        }

	        function tokenize_next() {
	            var i, resulting_string;
	            var whitespace_on_this_line = [];

	            n_newlines = 0;
	            whitespace_before_token = '';

	            if (parser_pos >= input_length) {
	                return ['', 'TK_EOF'];
	            }

	            var last_token;
	            if (tokens.length) {
	                last_token = tokens[tokens.length-1];
	            } else {
	                // For the sake of tokenizing we can pretend that there was on open brace to start
	                last_token = new Token('TK_START_BLOCK', '{');
	            }


	            var c = input.charAt(parser_pos);
	            parser_pos += 1;

	            while (in_array(c, whitespace)) {

	                if (acorn.newline.test(c)) {
	                    if (!(c === '\n' && input.charAt(parser_pos-2) === '\r')) {
	                        n_newlines += 1;
	                        whitespace_on_this_line = [];
	                    }
	                } else {
	                    whitespace_on_this_line.push(c);
	                }

	                if (parser_pos >= input_length) {
	                    return ['', 'TK_EOF'];
	                }

	                c = input.charAt(parser_pos);
	                parser_pos += 1;
	            }

	            if(whitespace_on_this_line.length) {
	                whitespace_before_token = whitespace_on_this_line.join('');
	            }

	            if (digit.test(c)) {
	                var allow_decimal = true;
	                var allow_e = true;
	                var local_digit = digit;

	                if (c === '0' && parser_pos < input_length && /[Xx]/.test(input.charAt(parser_pos))) {
	                    // switch to hex number, no decimal or e, just hex digits
	                    allow_decimal = false;
	                    allow_e = false;
	                    c += input.charAt(parser_pos);
	                    parser_pos += 1;
	                    local_digit = digit_hex
	                } else {
	                    // we know this first loop will run.  It keeps the logic simpler.
	                    c = '';
	                    parser_pos -= 1
	                }

	                // Add the digits
	                while (parser_pos < input_length && local_digit.test(input.charAt(parser_pos))) {
	                    c += input.charAt(parser_pos);
	                    parser_pos += 1;

	                    if (allow_decimal && parser_pos < input_length && input.charAt(parser_pos) === '.') {
	                        c += input.charAt(parser_pos);
	                        parser_pos += 1;
	                        allow_decimal = false;
	                    }

	                    if (allow_e && parser_pos < input_length && /[Ee]/.test(input.charAt(parser_pos))) {
	                        c += input.charAt(parser_pos);
	                        parser_pos += 1;

	                        if (parser_pos < input_length && /[+-]/.test(input.charAt(parser_pos))) {
	                            c += input.charAt(parser_pos);
	                            parser_pos += 1;
	                        }

	                        allow_e = false;
	                        allow_decimal = false;
	                    }
	                }

	                return [c, 'TK_WORD'];
	            }

	            if (acorn.isIdentifierStart(input.charCodeAt(parser_pos-1))) {
	                if (parser_pos < input_length) {
	                    while (acorn.isIdentifierChar(input.charCodeAt(parser_pos))) {
	                        c += input.charAt(parser_pos);
	                        parser_pos += 1;
	                        if (parser_pos === input_length) {
	                            break;
	                        }
	                    }
	                }

	                if (!(last_token.type === 'TK_DOT' ||
	                        (last_token.type === 'TK_RESERVED' && in_array(last_token.text, ['set', 'get'])))
	                    && in_array(c, reserved_words)) {
	                    if (c === 'in') { // hack for 'in' operator
	                        return [c, 'TK_OPERATOR'];
	                    }
	                    return [c, 'TK_RESERVED'];
	                }

	                return [c, 'TK_WORD'];
	            }

	            if (c === '(' || c === '[') {
	                return [c, 'TK_START_EXPR'];
	            }

	            if (c === ')' || c === ']') {
	                return [c, 'TK_END_EXPR'];
	            }

	            if (c === '{') {
	                return [c, 'TK_START_BLOCK'];
	            }

	            if (c === '}') {
	                return [c, 'TK_END_BLOCK'];
	            }

	            if (c === ';') {
	                return [c, 'TK_SEMICOLON'];
	            }

	            if (c === '/') {
	                var comment = '';
	                // peek for comment /* ... */
	                if (input.charAt(parser_pos) === '*') {
	                    parser_pos += 1;
	                    block_comment_pattern.lastIndex = parser_pos;
	                    var comment_match = block_comment_pattern.exec(input);
	                    comment = '/*' + comment_match[0];
	                    parser_pos += comment_match[0].length;
	                    var directives = get_directives(comment);
	                    if (directives && directives['ignore'] === 'start') {
	                        directives_end_ignore_pattern.lastIndex = parser_pos;
	                        comment_match = directives_end_ignore_pattern.exec(input)
	                        comment += comment_match[0];
	                        parser_pos += comment_match[0].length;
	                    }
	                    comment = comment.replace(acorn.lineBreak, '\n');
	                    return [comment, 'TK_BLOCK_COMMENT', directives];
	                }
	                // peek for comment // ...
	                if (input.charAt(parser_pos) === '/') {
	                    parser_pos += 1;
	                    comment_pattern.lastIndex = parser_pos;
	                    var comment_match = comment_pattern.exec(input);
	                    comment = '//' + comment_match[0];
	                    parser_pos += comment_match[0].length;
	                    return [comment, 'TK_COMMENT'];
	                }

	            }

	            if (c === '`' || c === "'" || c === '"' || // string
	                (
	                    (c === '/') || // regexp
	                    (opts.e4x && c === "<" && input.slice(parser_pos - 1).match(/^<([-a-zA-Z:0-9_.]+|{[^{}]*}|!\[CDATA\[[\s\S]*?\]\])(\s+[-a-zA-Z:0-9_.]+\s*=\s*('[^']*'|"[^"]*"|{.*?}))*\s*(\/?)\s*>/)) // xml
	                ) && ( // regex and xml can only appear in specific locations during parsing
	                    (last_token.type === 'TK_RESERVED' && in_array(last_token.text , ['return', 'case', 'throw', 'else', 'do', 'typeof', 'yield'])) ||
	                    (last_token.type === 'TK_END_EXPR' && last_token.text === ')' &&
	                        last_token.parent && last_token.parent.type === 'TK_RESERVED' && in_array(last_token.parent.text, ['if', 'while', 'for'])) ||
	                    (in_array(last_token.type, ['TK_COMMENT', 'TK_START_EXPR', 'TK_START_BLOCK',
	                        'TK_END_BLOCK', 'TK_OPERATOR', 'TK_EQUALS', 'TK_EOF', 'TK_SEMICOLON', 'TK_COMMA'
	                    ]))
	                )) {

	                var sep = c,
	                    esc = false,
	                    has_char_escapes = false;

	                resulting_string = c;

	                if (sep === '/') {
	                    //
	                    // handle regexp
	                    //
	                    var in_char_class = false;
	                    while (parser_pos < input_length &&
	                            ((esc || in_char_class || input.charAt(parser_pos) !== sep) &&
	                            !acorn.newline.test(input.charAt(parser_pos)))) {
	                        resulting_string += input.charAt(parser_pos);
	                        if (!esc) {
	                            esc = input.charAt(parser_pos) === '\\';
	                            if (input.charAt(parser_pos) === '[') {
	                                in_char_class = true;
	                            } else if (input.charAt(parser_pos) === ']') {
	                                in_char_class = false;
	                            }
	                        } else {
	                            esc = false;
	                        }
	                        parser_pos += 1;
	                    }
	                } else if (opts.e4x && sep === '<') {
	                    //
	                    // handle e4x xml literals
	                    //
	                    var xmlRegExp = /<(\/?)([-a-zA-Z:0-9_.]+|{[^{}]*}|!\[CDATA\[[\s\S]*?\]\])(\s+[-a-zA-Z:0-9_.]+\s*=\s*('[^']*'|"[^"]*"|{.*?}))*\s*(\/?)\s*>/g;
	                    var xmlStr = input.slice(parser_pos - 1);
	                    var match = xmlRegExp.exec(xmlStr);
	                    if (match && match.index === 0) {
	                        var rootTag = match[2];
	                        var depth = 0;
	                        while (match) {
	                            var isEndTag = !! match[1];
	                            var tagName = match[2];
	                            var isSingletonTag = ( !! match[match.length - 1]) || (tagName.slice(0, 8) === "![CDATA[");
	                            if (tagName === rootTag && !isSingletonTag) {
	                                if (isEndTag) {
	                                    --depth;
	                                } else {
	                                    ++depth;
	                                }
	                            }
	                            if (depth <= 0) {
	                                break;
	                            }
	                            match = xmlRegExp.exec(xmlStr);
	                        }
	                        var xmlLength = match ? match.index + match[0].length : xmlStr.length;
	                        xmlStr = xmlStr.slice(0, xmlLength);
	                        parser_pos += xmlLength - 1;
	                        xmlStr = xmlStr.replace(acorn.lineBreak, '\n');
	                        return [xmlStr, "TK_STRING"];
	                    }
	                } else {
	                    //
	                    // handle string
	                    //
	                    // Template strings can travers lines without escape characters.
	                    // Other strings cannot
	                    while (parser_pos < input_length &&
	                            (esc || (input.charAt(parser_pos) !== sep &&
	                            (sep === '`' || !acorn.newline.test(input.charAt(parser_pos)))))) {
	                        // Handle \r\n linebreaks after escapes or in template strings
	                        if ((esc || sep === '`') && acorn.newline.test(input.charAt(parser_pos))) {
	                            if (input.charAt(parser_pos) === '\r' && input.charAt(parser_pos + 1) === '\n') {
	                                parser_pos += 1;
	                            }
	                            resulting_string += '\n';
	                        } else {
	                            resulting_string += input.charAt(parser_pos);
	                        }
	                        if (esc) {
	                            if (input.charAt(parser_pos) === 'x' || input.charAt(parser_pos) === 'u') {
	                                has_char_escapes = true;
	                            }
	                            esc = false;
	                        } else {
	                            esc = input.charAt(parser_pos) === '\\';
	                        }
	                        parser_pos += 1;
	                    }

	                }

	                if (has_char_escapes && opts.unescape_strings) {
	                    resulting_string = unescape_string(resulting_string);
	                }

	                if (parser_pos < input_length && input.charAt(parser_pos) === sep) {
	                    resulting_string += sep;
	                    parser_pos += 1;

	                    if (sep === '/') {
	                        // regexps may have modifiers /regexp/MOD , so fetch those, too
	                        // Only [gim] are valid, but if the user puts in garbage, do what we can to take it.
	                        while (parser_pos < input_length && acorn.isIdentifierStart(input.charCodeAt(parser_pos))) {
	                            resulting_string += input.charAt(parser_pos);
	                            parser_pos += 1;
	                        }
	                    }
	                }
	                return [resulting_string, 'TK_STRING'];
	            }

	            if (c === '#') {

	                if (tokens.length === 0 && input.charAt(parser_pos) === '!') {
	                    // shebang
	                    resulting_string = c;
	                    while (parser_pos < input_length && c !== '\n') {
	                        c = input.charAt(parser_pos);
	                        resulting_string += c;
	                        parser_pos += 1;
	                    }
	                    return [trim(resulting_string) + '\n', 'TK_UNKNOWN'];
	                }



	                // Spidermonkey-specific sharp variables for circular references
	                // https://developer.mozilla.org/En/Sharp_variables_in_JavaScript
	                // http://mxr.mozilla.org/mozilla-central/source/js/src/jsscan.cpp around line 1935
	                var sharp = '#';
	                if (parser_pos < input_length && digit.test(input.charAt(parser_pos))) {
	                    do {
	                        c = input.charAt(parser_pos);
	                        sharp += c;
	                        parser_pos += 1;
	                    } while (parser_pos < input_length && c !== '#' && c !== '=');
	                    if (c === '#') {
	                        //
	                    } else if (input.charAt(parser_pos) === '[' && input.charAt(parser_pos + 1) === ']') {
	                        sharp += '[]';
	                        parser_pos += 2;
	                    } else if (input.charAt(parser_pos) === '{' && input.charAt(parser_pos + 1) === '}') {
	                        sharp += '{}';
	                        parser_pos += 2;
	                    }
	                    return [sharp, 'TK_WORD'];
	                }
	            }

	            if (c === '<' && (input.charAt(parser_pos) === '?' || input.charAt(parser_pos) === '%')) {
	                template_pattern.lastIndex = parser_pos - 1;
	                var template_match = template_pattern.exec(input);
	                if(template_match) {
	                    c = template_match[0];
	                    parser_pos += c.length - 1;
	                    c = c.replace(acorn.lineBreak, '\n');
	                    return [c, 'TK_STRING'];
	                }
	            }

	            if (c === '<' && input.substring(parser_pos - 1, parser_pos + 3) === '<!--') {
	                parser_pos += 3;
	                c = '<!--';
	                while (!acorn.newline.test(input.charAt(parser_pos)) && parser_pos < input_length) {
	                    c += input.charAt(parser_pos);
	                    parser_pos++;
	                }
	                in_html_comment = true;
	                return [c, 'TK_COMMENT'];
	            }

	            if (c === '-' && in_html_comment && input.substring(parser_pos - 1, parser_pos + 2) === '-->') {
	                in_html_comment = false;
	                parser_pos += 2;
	                return ['-->', 'TK_COMMENT'];
	            }

	            if (c === '.') {
	                return [c, 'TK_DOT'];
	            }

	            if (in_array(c, punct)) {
	                while (parser_pos < input_length && in_array(c + input.charAt(parser_pos), punct)) {
	                    c += input.charAt(parser_pos);
	                    parser_pos += 1;
	                    if (parser_pos >= input_length) {
	                        break;
	                    }
	                }

	                if (c === ',') {
	                    return [c, 'TK_COMMA'];
	                } else if (c === '=') {
	                    return [c, 'TK_EQUALS'];
	                } else {
	                    return [c, 'TK_OPERATOR'];
	                }
	            }

	            return [c, 'TK_UNKNOWN'];
	        }


	        function unescape_string(s) {
	            var esc = false,
	                out = '',
	                pos = 0,
	                s_hex = '',
	                escaped = 0,
	                c;

	            while (esc || pos < s.length) {

	                c = s.charAt(pos);
	                pos++;

	                if (esc) {
	                    esc = false;
	                    if (c === 'x') {
	                        // simple hex-escape \x24
	                        s_hex = s.substr(pos, 2);
	                        pos += 2;
	                    } else if (c === 'u') {
	                        // unicode-escape, \u2134
	                        s_hex = s.substr(pos, 4);
	                        pos += 4;
	                    } else {
	                        // some common escape, e.g \n
	                        out += '\\' + c;
	                        continue;
	                    }
	                    if (!s_hex.match(/^[0123456789abcdefABCDEF]+$/)) {
	                        // some weird escaping, bail out,
	                        // leaving whole string intact
	                        return s;
	                    }

	                    escaped = parseInt(s_hex, 16);

	                    if (escaped >= 0x00 && escaped < 0x20) {
	                        // leave 0x00...0x1f escaped
	                        if (c === 'x') {
	                            out += '\\x' + s_hex;
	                        } else {
	                            out += '\\u' + s_hex;
	                        }
	                        continue;
	                    } else if (escaped === 0x22 || escaped === 0x27 || escaped === 0x5c) {
	                        // single-quote, apostrophe, backslash - escape these
	                        out += '\\' + String.fromCharCode(escaped);
	                    } else if (c === 'x' && escaped > 0x7e && escaped <= 0xff) {
	                        // we bail out on \x7f..\xff,
	                        // leaving whole string escaped,
	                        // as it's probably completely binary
	                        return s;
	                    } else {
	                        out += String.fromCharCode(escaped);
	                    }
	                } else if (c === '\\') {
	                    esc = true;
	                } else {
	                    out += c;
	                }
	            }
	            return out;
	        }

	    }


	    if (true) {
	        // Add support for AMD ( https://github.com/amdjs/amdjs-api/wiki/AMD#defineamd-property- )
	        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = function() {
	            return { js_beautify: js_beautify };
	        }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	    } else if (typeof exports !== "undefined") {
	        // Add support for CommonJS. Just put this file somewhere on your require.paths
	        // and you will be able to `var js_beautify = require("beautify").js_beautify`.
	        exports.js_beautify = js_beautify;
	    } else if (typeof window !== "undefined") {
	        // If we're running a web page and don't have either of the above, add our one global
	        window.js_beautify = js_beautify;
	    } else if (typeof global !== "undefined") {
	        // If we don't even have window, try global.
	        global.js_beautify = js_beautify;
	    }

	}());


/***/ },
/* 47 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*jshint curly:true, eqeqeq:true, laxbreak:true, noempty:false */
	/*

	  The MIT License (MIT)

	  Copyright (c) 2007-2013 Einar Lielmanis and contributors.

	  Permission is hereby granted, free of charge, to any person
	  obtaining a copy of this software and associated documentation files
	  (the "Software"), to deal in the Software without restriction,
	  including without limitation the rights to use, copy, modify, merge,
	  publish, distribute, sublicense, and/or sell copies of the Software,
	  and to permit persons to whom the Software is furnished to do so,
	  subject to the following conditions:

	  The above copyright notice and this permission notice shall be
	  included in all copies or substantial portions of the Software.

	  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
	  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
	  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
	  BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
	  ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
	  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
	  SOFTWARE.


	 CSS Beautifier
	---------------

	    Written by Harutyun Amirjanyan, (amirjanyan@gmail.com)

	    Based on code initially developed by: Einar Lielmanis, <einar@jsbeautifier.org>
	        http://jsbeautifier.org/

	    Usage:
	        css_beautify(source_text);
	        css_beautify(source_text, options);

	    The options are (default in brackets):
	        indent_size (4)                    indentation size,
	        indent_char (space)                character to indent with,
	        selector_separator_newline (true) - separate selectors with newline or
	                                            not (e.g. "a,\nbr" or "a, br")
	        end_with_newline (false)          - end with a newline
	        newline_between_rules (true)      - add a new line after every css rule

	    e.g

	    css_beautify(css_source_text, {
	      'indent_size': 1,
	      'indent_char': '\t',
	      'selector_separator': ' ',
	      'end_with_newline': false,
	      'newline_between_rules': true
	    });
	*/

	// http://www.w3.org/TR/CSS21/syndata.html#tokenization
	// http://www.w3.org/TR/css3-syntax/

	(function() {
	    function css_beautify(source_text, options) {
	        options = options || {};
	        source_text = source_text || '';
	        // HACK: newline parsing inconsistent. This brute force normalizes the input.
	        source_text = source_text.replace(/\r\n|[\r\u2028\u2029]/g, '\n')

	        var indentSize = options.indent_size || 4;
	        var indentCharacter = options.indent_char || ' ';
	        var selectorSeparatorNewline = (options.selector_separator_newline === undefined) ? true : options.selector_separator_newline;
	        var end_with_newline = (options.end_with_newline === undefined) ? false : options.end_with_newline;
	        var newline_between_rules = (options.newline_between_rules === undefined) ? true : options.newline_between_rules;
	        var eol = options.eol ? options.eol : '\n';

	        // compatibility
	        if (typeof indentSize === "string") {
	            indentSize = parseInt(indentSize, 10);
	        }

	        if(options.indent_with_tabs){
	            indentCharacter = '\t';
	            indentSize = 1;
	        }

	        eol = eol.replace(/\\r/, '\r').replace(/\\n/, '\n')


	        // tokenizer
	        var whiteRe = /^\s+$/;
	        var wordRe = /[\w$\-_]/;

	        var pos = -1,
	            ch;
	        var parenLevel = 0;

	        function next() {
	            ch = source_text.charAt(++pos);
	            return ch || '';
	        }

	        function peek(skipWhitespace) {
	            var result = '';
	            var prev_pos = pos;
	            if (skipWhitespace) {
	                eatWhitespace();
	            }
	            result = source_text.charAt(pos + 1) || '';
	            pos = prev_pos - 1;
	            next();
	            return result;
	        }

	        function eatString(endChars) {
	            var start = pos;
	            while (next()) {
	                if (ch === "\\") {
	                    next();
	                } else if (endChars.indexOf(ch) !== -1) {
	                    break;
	                } else if (ch === "\n") {
	                    break;
	                }
	            }
	            return source_text.substring(start, pos + 1);
	        }

	        function peekString(endChar) {
	            var prev_pos = pos;
	            var str = eatString(endChar);
	            pos = prev_pos - 1;
	            next();
	            return str;
	        }

	        function eatWhitespace() {
	            var result = '';
	            while (whiteRe.test(peek())) {
	                next();
	                result += ch;
	            }
	            return result;
	        }

	        function skipWhitespace() {
	            var result = '';
	            if (ch && whiteRe.test(ch)) {
	                result = ch;
	            }
	            while (whiteRe.test(next())) {
	                result += ch;
	            }
	            return result;
	        }

	        function eatComment(singleLine) {
	            var start = pos;
	            singleLine = peek() === "/";
	            next();
	            while (next()) {
	                if (!singleLine && ch === "*" && peek() === "/") {
	                    next();
	                    break;
	                } else if (singleLine && ch === "\n") {
	                    return source_text.substring(start, pos);
	                }
	            }

	            return source_text.substring(start, pos) + ch;
	        }


	        function lookBack(str) {
	            return source_text.substring(pos - str.length, pos).toLowerCase() ===
	                str;
	        }

	        // Nested pseudo-class if we are insideRule
	        // and the next special character found opens
	        // a new block
	        function foundNestedPseudoClass() {
	            var openParen = 0;
	            for (var i = pos + 1; i < source_text.length; i++) {
	                var ch = source_text.charAt(i);
	                if (ch === "{") {
	                    return true;
	                } else if (ch === '(') {
	                    // pseudoclasses can contain ()
	                    openParen += 1;
	                } else if (ch === ')') {
	                    if (openParen == 0) {
	                        return false;
	                    }
	                    openParen -= 1;
	                } else if (ch === ";" || ch === "}") {
	                    return false;
	                }
	            }
	            return false;
	        }

	        // printer
	        var basebaseIndentString = source_text.match(/^[\t ]*/)[0];
	        var singleIndent = new Array(indentSize + 1).join(indentCharacter);
	        var indentLevel = 0;
	        var nestedLevel = 0;

	        function indent() {
	            indentLevel++;
	            basebaseIndentString += singleIndent;
	        }

	        function outdent() {
	            indentLevel--;
	            basebaseIndentString = basebaseIndentString.slice(0, -indentSize);
	        }

	        var print = {};
	        print["{"] = function(ch) {
	            print.singleSpace();
	            output.push(ch);
	            print.newLine();
	        };
	        print["}"] = function(ch) {
	            print.newLine();
	            output.push(ch);
	            print.newLine();
	        };

	        print._lastCharWhitespace = function() {
	            return whiteRe.test(output[output.length - 1]);
	        };

	        print.newLine = function(keepWhitespace) {
	            if (output.length) {
	                if (!keepWhitespace && output[output.length - 1] !== '\n') {
	                    print.trim();
	                }

	                output.push('\n');

	                if (basebaseIndentString) {
	                    output.push(basebaseIndentString);
	                }
	            }
	        };
	        print.singleSpace = function() {
	            if (output.length && !print._lastCharWhitespace()) {
	                output.push(' ');
	            }
	        };

	        print.preserveSingleSpace = function() {
	            if (isAfterSpace) {
	                print.singleSpace();
	            }
	        };

	        print.trim = function() {
	            while (print._lastCharWhitespace()) {
	                output.pop();
	            }
	        };


	        var output = [];
	        /*_____________________--------------------_____________________*/

	        var insideRule = false;
	        var insidePropertyValue = false;
	        var enteringConditionalGroup = false;
	        var top_ch = '';
	        var last_top_ch = '';

	        while (true) {
	            var whitespace = skipWhitespace();
	            var isAfterSpace = whitespace !== '';
	            var isAfterNewline = whitespace.indexOf('\n') !== -1;
	            last_top_ch = top_ch;
	            top_ch = ch;

	            if (!ch) {
	                break;
	            } else if (ch === '/' && peek() === '*') { /* css comment */
	                var header = indentLevel === 0;

	                if (isAfterNewline || header) {
	                    print.newLine();
	                }

	                output.push(eatComment());
	                print.newLine();
	                if (header) {
	                    print.newLine(true);
	                }
	            } else if (ch === '/' && peek() === '/') { // single line comment
	                if (!isAfterNewline && last_top_ch !== '{' ) {
	                    print.trim();
	                }
	                print.singleSpace();
	                output.push(eatComment());
	                print.newLine();
	            } else if (ch === '@') {
	                print.preserveSingleSpace();
	                output.push(ch);

	                // strip trailing space, if present, for hash property checks
	                var variableOrRule = peekString(": ,;{}()[]/='\"");

	                if (variableOrRule.match(/[ :]$/)) {
	                    // we have a variable or pseudo-class, add it and insert one space before continuing
	                    next();
	                    variableOrRule = eatString(": ").replace(/\s$/, '');
	                    output.push(variableOrRule);
	                    print.singleSpace();
	                }

	                variableOrRule = variableOrRule.replace(/\s$/, '')

	                // might be a nesting at-rule
	                if (variableOrRule in css_beautify.NESTED_AT_RULE) {
	                    nestedLevel += 1;
	                    if (variableOrRule in css_beautify.CONDITIONAL_GROUP_RULE) {
	                        enteringConditionalGroup = true;
	                    }
	                }
	            } else if (ch === '#' && peek() === '{') {
	              print.preserveSingleSpace();
	              output.push(eatString('}'));
	            } else if (ch === '{') {
	                if (peek(true) === '}') {
	                    eatWhitespace();
	                    next();
	                    print.singleSpace();
	                    output.push("{}");
	                    print.newLine();
	                    if (newline_between_rules && indentLevel === 0) {
	                        print.newLine(true);
	                    }
	                } else {
	                    indent();
	                    print["{"](ch);
	                    // when entering conditional groups, only rulesets are allowed
	                    if (enteringConditionalGroup) {
	                        enteringConditionalGroup = false;
	                        insideRule = (indentLevel > nestedLevel);
	                    } else {
	                        // otherwise, declarations are also allowed
	                        insideRule = (indentLevel >= nestedLevel);
	                    }
	                }
	            } else if (ch === '}') {
	                outdent();
	                print["}"](ch);
	                insideRule = false;
	                insidePropertyValue = false;
	                if (nestedLevel) {
	                    nestedLevel--;
	                }
	                if (newline_between_rules && indentLevel === 0) {
	                    print.newLine(true);
	                }
	            } else if (ch === ":") {
	                eatWhitespace();
	                if ((insideRule || enteringConditionalGroup) &&
	                    !(lookBack("&") || foundNestedPseudoClass())) {
	                    // 'property: value' delimiter
	                    // which could be in a conditional group query
	                    insidePropertyValue = true;
	                    output.push(':');
	                    print.singleSpace();
	                } else {
	                    // sass/less parent reference don't use a space
	                    // sass nested pseudo-class don't use a space
	                    if (peek() === ":") {
	                        // pseudo-element
	                        next();
	                        output.push("::");
	                    } else {
	                        // pseudo-class
	                        output.push(':');
	                    }
	                }
	            } else if (ch === '"' || ch === '\'') {
	                print.preserveSingleSpace();
	                output.push(eatString(ch));
	            } else if (ch === ';') {
	                insidePropertyValue = false;
	                output.push(ch);
	                print.newLine();
	            } else if (ch === '(') { // may be a url
	                if (lookBack("url")) {
	                    output.push(ch);
	                    eatWhitespace();
	                    if (next()) {
	                        if (ch !== ')' && ch !== '"' && ch !== '\'') {
	                            output.push(eatString(')'));
	                        } else {
	                            pos--;
	                        }
	                    }
	                } else {
	                    parenLevel++;
	                    print.preserveSingleSpace();
	                    output.push(ch);
	                    eatWhitespace();
	                }
	            } else if (ch === ')') {
	                output.push(ch);
	                parenLevel--;
	            } else if (ch === ',') {
	                output.push(ch);
	                eatWhitespace();
	                if (selectorSeparatorNewline && !insidePropertyValue && parenLevel < 1) {
	                    print.newLine();
	                } else {
	                    print.singleSpace();
	                }
	            } else if (ch === ']') {
	                output.push(ch);
	            } else if (ch === '[') {
	                print.preserveSingleSpace();
	                output.push(ch);
	            } else if (ch === '=') { // no whitespace before or after
	                eatWhitespace()
	                ch = '=';
	                output.push(ch);
	            } else {
	                print.preserveSingleSpace();
	                output.push(ch);
	            }
	        }


	        var sweetCode = '';
	        if (basebaseIndentString) {
	            sweetCode += basebaseIndentString;
	        }

	        sweetCode += output.join('').replace(/[\r\n\t ]+$/, '');

	        // establish end_with_newline
	        if (end_with_newline) {
	            sweetCode += '\n';
	        }

	        if (eol != '\n') {
	            sweetCode = sweetCode.replace(/[\n]/g, eol);
	        }

	        return sweetCode;
	    }

	    // https://developer.mozilla.org/en-US/docs/Web/CSS/At-rule
	    css_beautify.NESTED_AT_RULE = {
	        "@page": true,
	        "@font-face": true,
	        "@keyframes": true,
	        // also in CONDITIONAL_GROUP_RULE below
	        "@media": true,
	        "@supports": true,
	        "@document": true
	    };
	    css_beautify.CONDITIONAL_GROUP_RULE = {
	        "@media": true,
	        "@supports": true,
	        "@document": true
	    };

	    /*global define */
	    if (true) {
	        // Add support for AMD ( https://github.com/amdjs/amdjs-api/wiki/AMD#defineamd-property- )
	        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = function() {
	            return {
	                css_beautify: css_beautify
	            };
	        }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	    } else if (typeof exports !== "undefined") {
	        // Add support for CommonJS. Just put this file somewhere on your require.paths
	        // and you will be able to `var html_beautify = require("beautify").html_beautify`.
	        exports.css_beautify = css_beautify;
	    } else if (typeof window !== "undefined") {
	        // If we're running a web page and don't have either of the above, add our one global
	        window.css_beautify = css_beautify;
	    } else if (typeof global !== "undefined") {
	        // If we don't even have window, try global.
	        global.css_beautify = css_beautify;
	    }

	}());


/***/ },
/* 48 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*jshint curly:true, eqeqeq:true, laxbreak:true, noempty:false */
	/*

	  The MIT License (MIT)

	  Copyright (c) 2007-2013 Einar Lielmanis and contributors.

	  Permission is hereby granted, free of charge, to any person
	  obtaining a copy of this software and associated documentation files
	  (the "Software"), to deal in the Software without restriction,
	  including without limitation the rights to use, copy, modify, merge,
	  publish, distribute, sublicense, and/or sell copies of the Software,
	  and to permit persons to whom the Software is furnished to do so,
	  subject to the following conditions:

	  The above copyright notice and this permission notice shall be
	  included in all copies or substantial portions of the Software.

	  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
	  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
	  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
	  BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
	  ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
	  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
	  SOFTWARE.


	 Style HTML
	---------------

	  Written by Nochum Sossonko, (nsossonko@hotmail.com)

	  Based on code initially developed by: Einar Lielmanis, <einar@jsbeautifier.org>
	    http://jsbeautifier.org/

	  Usage:
	    style_html(html_source);

	    style_html(html_source, options);

	  The options are:
	    indent_inner_html (default false)   indent <head> and <body> sections,
	    indent_size (default 4)           indentation size,
	    indent_char (default space)       character to indent with,
	    wrap_line_length (default 250)            -  maximum amount of characters per line (0 = disable)
	    brace_style (default "collapse") - "collapse" | "expand" | "end-expand" | "none"
	            put braces on the same line as control statements (default), or put braces on own line (Allman / ANSI style), or just put end braces on own line, or attempt to keep them where they are.
	    unformatted (defaults to inline tags) - list of tags, that shouldn't be reformatted
	    indent_scripts (default normal)  - "keep"|"separate"|"normal"
	    preserve_newlines (default true) - whether existing line breaks before elements should be preserved
	                                        Only works before elements, not inside tags or for text.
	    max_preserve_newlines (default unlimited) - maximum number of line breaks to be preserved in one chunk
	    indent_handlebars (default false) - format and indent {{#foo}} and {{/foo}}
	    end_with_newline (false)          - end with a newline
	    extra_liners (default [head,body,/html]) -List of tags that should have an extra newline before them.

	    e.g.

	    style_html(html_source, {
	      'indent_inner_html': false,
	      'indent_size': 2,
	      'indent_char': ' ',
	      'wrap_line_length': 78,
	      'brace_style': 'expand',
	      'unformatted': ['a', 'sub', 'sup', 'b', 'i', 'u'],
	      'preserve_newlines': true,
	      'max_preserve_newlines': 5,
	      'indent_handlebars': false,
	      'extra_liners': ['/html']
	    });
	*/

	(function() {

	    function trim(s) {
	        return s.replace(/^\s+|\s+$/g, '');
	    }

	    function ltrim(s) {
	        return s.replace(/^\s+/g, '');
	    }

	    function rtrim(s) {
	        return s.replace(/\s+$/g,'');
	    }

	    function style_html(html_source, options, js_beautify, css_beautify) {
	        //Wrapper function to invoke all the necessary constructors and deal with the output.

	        var multi_parser,
	            indent_inner_html,
	            indent_size,
	            indent_character,
	            wrap_line_length,
	            brace_style,
	            unformatted,
	            preserve_newlines,
	            max_preserve_newlines,
	            indent_handlebars,
	            wrap_attributes,
	            wrap_attributes_indent_size,
	            end_with_newline,
	            extra_liners,
	            eol;

	        options = options || {};

	        // backwards compatibility to 1.3.4
	        if ((options.wrap_line_length === undefined || parseInt(options.wrap_line_length, 10) === 0) &&
	                (options.max_char !== undefined && parseInt(options.max_char, 10) !== 0)) {
	            options.wrap_line_length = options.max_char;
	        }

	        indent_inner_html = (options.indent_inner_html === undefined) ? false : options.indent_inner_html;
	        indent_size = (options.indent_size === undefined) ? 4 : parseInt(options.indent_size, 10);
	        indent_character = (options.indent_char === undefined) ? ' ' : options.indent_char;
	        brace_style = (options.brace_style === undefined) ? 'collapse' : options.brace_style;
	        wrap_line_length =  parseInt(options.wrap_line_length, 10) === 0 ? 32786 : parseInt(options.wrap_line_length || 250, 10);
	        unformatted = options.unformatted || ['a', 'span', 'img', 'bdo', 'em', 'strong', 'dfn', 'code', 'samp', 'kbd',
	            'var', 'cite', 'abbr', 'acronym', 'q', 'sub', 'sup', 'tt', 'i', 'b', 'big', 'small', 'u', 's', 'strike',
	            'font', 'ins', 'del', 'pre', 'address', 'dt', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6'];
	        preserve_newlines = (options.preserve_newlines === undefined) ? true : options.preserve_newlines;
	        max_preserve_newlines = preserve_newlines ?
	            (isNaN(parseInt(options.max_preserve_newlines, 10)) ? 32786 : parseInt(options.max_preserve_newlines, 10))
	            : 0;
	        indent_handlebars = (options.indent_handlebars === undefined) ? false : options.indent_handlebars;
	        wrap_attributes = (options.wrap_attributes === undefined) ? 'auto' : options.wrap_attributes;
	        wrap_attributes_indent_size = (options.wrap_attributes_indent_size === undefined) ? indent_size : parseInt(options.wrap_attributes_indent_size, 10) || indent_size;
	        end_with_newline = (options.end_with_newline === undefined) ? false : options.end_with_newline;
	        extra_liners = (typeof options.extra_liners == 'object') && options.extra_liners ?
	            options.extra_liners.concat() : (typeof options.extra_liners === 'string') ?
	            options.extra_liners.split(',') : 'head,body,/html'.split(',');
	        eol = options.eol ? options.eol : '\n';

	        if(options.indent_with_tabs){
	            indent_character = '\t';
	            indent_size = 1;
	        }

	        eol = eol.replace(/\\r/, '\r').replace(/\\n/, '\n')

	        function Parser() {

	            this.pos = 0; //Parser position
	            this.token = '';
	            this.current_mode = 'CONTENT'; //reflects the current Parser mode: TAG/CONTENT
	            this.tags = { //An object to hold tags, their position, and their parent-tags, initiated with default values
	                parent: 'parent1',
	                parentcount: 1,
	                parent1: ''
	            };
	            this.tag_type = '';
	            this.token_text = this.last_token = this.last_text = this.token_type = '';
	            this.newlines = 0;
	            this.indent_content = indent_inner_html;

	            this.Utils = { //Uilities made available to the various functions
	                whitespace: "\n\r\t ".split(''),
	                single_token: 'br,input,link,meta,source,!doctype,basefont,base,area,hr,wbr,param,img,isindex,embed'.split(','), //all the single tags for HTML
	                extra_liners: extra_liners, //for tags that need a line of whitespace before them
	                in_array: function(what, arr) {
	                    for (var i = 0; i < arr.length; i++) {
	                        if (what === arr[i]) {
	                            return true;
	                        }
	                    }
	                    return false;
	                }
	            };

	            // Return true if the given text is composed entirely of whitespace.
	            this.is_whitespace = function(text) {
	                for (var n = 0; n < text.length; text++) {
	                    if (!this.Utils.in_array(text.charAt(n), this.Utils.whitespace)) {
	                        return false;
	                    }
	                }
	                return true;
	            };

	            this.traverse_whitespace = function() {
	                var input_char = '';

	                input_char = this.input.charAt(this.pos);
	                if (this.Utils.in_array(input_char, this.Utils.whitespace)) {
	                    this.newlines = 0;
	                    while (this.Utils.in_array(input_char, this.Utils.whitespace)) {
	                        if (preserve_newlines && input_char === '\n' && this.newlines <= max_preserve_newlines) {
	                            this.newlines += 1;
	                        }

	                        this.pos++;
	                        input_char = this.input.charAt(this.pos);
	                    }
	                    return true;
	                }
	                return false;
	            };

	            // Append a space to the given content (string array) or, if we are
	            // at the wrap_line_length, append a newline/indentation.
	            this.space_or_wrap = function(content) {
	                if (this.line_char_count >= this.wrap_line_length) { //insert a line when the wrap_line_length is reached
	                    this.print_newline(false, content);
	                    this.print_indentation(content);
	                } else {
	                    this.line_char_count++;
	                    content.push(' ');
	                }
	            };

	            this.get_content = function() { //function to capture regular content between tags
	                var input_char = '',
	                    content = [],
	                    space = false; //if a space is needed

	                while (this.input.charAt(this.pos) !== '<') {
	                    if (this.pos >= this.input.length) {
	                        return content.length ? content.join('') : ['', 'TK_EOF'];
	                    }

	                    if (this.traverse_whitespace()) {
	                        this.space_or_wrap(content);
	                        continue;
	                    }

	                    if (indent_handlebars) {
	                        // Handlebars parsing is complicated.
	                        // {{#foo}} and {{/foo}} are formatted tags.
	                        // {{something}} should get treated as content, except:
	                        // {{else}} specifically behaves like {{#if}} and {{/if}}
	                        var peek3 = this.input.substr(this.pos, 3);
	                        if (peek3 === '{{#' || peek3 === '{{/') {
	                            // These are tags and not content.
	                            break;
	                        } else if (peek3 === '{{!') {
	                            return [this.get_tag(), 'TK_TAG_HANDLEBARS_COMMENT'];
	                        } else if (this.input.substr(this.pos, 2) === '{{') {
	                            if (this.get_tag(true) === '{{else}}') {
	                                break;
	                            }
	                        }
	                    }

	                    input_char = this.input.charAt(this.pos);
	                    this.pos++;
	                    this.line_char_count++;
	                    content.push(input_char); //letter at-a-time (or string) inserted to an array
	                }
	                return content.length ? content.join('') : '';
	            };

	            this.get_contents_to = function(name) { //get the full content of a script or style to pass to js_beautify
	                if (this.pos === this.input.length) {
	                    return ['', 'TK_EOF'];
	                }
	                var input_char = '';
	                var content = '';
	                var reg_match = new RegExp('</' + name + '\\s*>', 'igm');
	                reg_match.lastIndex = this.pos;
	                var reg_array = reg_match.exec(this.input);
	                var end_script = reg_array ? reg_array.index : this.input.length; //absolute end of script
	                if (this.pos < end_script) { //get everything in between the script tags
	                    content = this.input.substring(this.pos, end_script);
	                    this.pos = end_script;
	                }
	                return content;
	            };

	            this.record_tag = function(tag) { //function to record a tag and its parent in this.tags Object
	                if (this.tags[tag + 'count']) { //check for the existence of this tag type
	                    this.tags[tag + 'count']++;
	                    this.tags[tag + this.tags[tag + 'count']] = this.indent_level; //and record the present indent level
	                } else { //otherwise initialize this tag type
	                    this.tags[tag + 'count'] = 1;
	                    this.tags[tag + this.tags[tag + 'count']] = this.indent_level; //and record the present indent level
	                }
	                this.tags[tag + this.tags[tag + 'count'] + 'parent'] = this.tags.parent; //set the parent (i.e. in the case of a div this.tags.div1parent)
	                this.tags.parent = tag + this.tags[tag + 'count']; //and make this the current parent (i.e. in the case of a div 'div1')
	            };

	            this.retrieve_tag = function(tag) { //function to retrieve the opening tag to the corresponding closer
	                if (this.tags[tag + 'count']) { //if the openener is not in the Object we ignore it
	                    var temp_parent = this.tags.parent; //check to see if it's a closable tag.
	                    while (temp_parent) { //till we reach '' (the initial value);
	                        if (tag + this.tags[tag + 'count'] === temp_parent) { //if this is it use it
	                            break;
	                        }
	                        temp_parent = this.tags[temp_parent + 'parent']; //otherwise keep on climbing up the DOM Tree
	                    }
	                    if (temp_parent) { //if we caught something
	                        this.indent_level = this.tags[tag + this.tags[tag + 'count']]; //set the indent_level accordingly
	                        this.tags.parent = this.tags[temp_parent + 'parent']; //and set the current parent
	                    }
	                    delete this.tags[tag + this.tags[tag + 'count'] + 'parent']; //delete the closed tags parent reference...
	                    delete this.tags[tag + this.tags[tag + 'count']]; //...and the tag itself
	                    if (this.tags[tag + 'count'] === 1) {
	                        delete this.tags[tag + 'count'];
	                    } else {
	                        this.tags[tag + 'count']--;
	                    }
	                }
	            };

	            this.indent_to_tag = function(tag) {
	                // Match the indentation level to the last use of this tag, but don't remove it.
	                if (!this.tags[tag + 'count']) {
	                    return;
	                }
	                var temp_parent = this.tags.parent;
	                while (temp_parent) {
	                    if (tag + this.tags[tag + 'count'] === temp_parent) {
	                        break;
	                    }
	                    temp_parent = this.tags[temp_parent + 'parent'];
	                }
	                if (temp_parent) {
	                    this.indent_level = this.tags[tag + this.tags[tag + 'count']];
	                }
	            };

	            this.get_tag = function(peek) { //function to get a full tag and parse its type
	                var input_char = '',
	                    content = [],
	                    comment = '',
	                    space = false,
	                    first_attr = true,
	                    tag_start, tag_end,
	                    tag_start_char,
	                    orig_pos = this.pos,
	                    orig_line_char_count = this.line_char_count;

	                peek = peek !== undefined ? peek : false;

	                do {
	                    if (this.pos >= this.input.length) {
	                        if (peek) {
	                            this.pos = orig_pos;
	                            this.line_char_count = orig_line_char_count;
	                        }
	                        return content.length ? content.join('') : ['', 'TK_EOF'];
	                    }

	                    input_char = this.input.charAt(this.pos);
	                    this.pos++;

	                    if (this.Utils.in_array(input_char, this.Utils.whitespace)) { //don't want to insert unnecessary space
	                        space = true;
	                        continue;
	                    }

	                    if (input_char === "'" || input_char === '"') {
	                        input_char += this.get_unformatted(input_char);
	                        space = true;

	                    }

	                    if (input_char === '=') { //no space before =
	                        space = false;
	                    }

	                    if (content.length && content[content.length - 1] !== '=' && input_char !== '>' && space) {
	                        //no space after = or before >
	                        this.space_or_wrap(content);
	                        space = false;
	                        if (!first_attr && wrap_attributes === 'force' &&  input_char !== '/') {
	                            this.print_newline(true, content);
	                            this.print_indentation(content);
	                            for (var count = 0; count < wrap_attributes_indent_size; count++) {
	                                content.push(indent_character);
	                            }
	                        }
	                        for (var i = 0; i < content.length; i++) {
	                          if (content[i] === ' ') {
	                            first_attr = false;
	                            break;
	                          }
	                        }
	                    }

	                    if (indent_handlebars && tag_start_char === '<') {
	                        // When inside an angle-bracket tag, put spaces around
	                        // handlebars not inside of strings.
	                        if ((input_char + this.input.charAt(this.pos)) === '{{') {
	                            input_char += this.get_unformatted('}}');
	                            if (content.length && content[content.length - 1] !== ' ' && content[content.length - 1] !== '<') {
	                                input_char = ' ' + input_char;
	                            }
	                            space = true;
	                        }
	                    }

	                    if (input_char === '<' && !tag_start_char) {
	                        tag_start = this.pos - 1;
	                        tag_start_char = '<';
	                    }

	                    if (indent_handlebars && !tag_start_char) {
	                        if (content.length >= 2 && content[content.length - 1] === '{' && content[content.length - 2] === '{') {
	                            if (input_char === '#' || input_char === '/' || input_char === '!') {
	                                tag_start = this.pos - 3;
	                            } else {
	                                tag_start = this.pos - 2;
	                            }
	                            tag_start_char = '{';
	                        }
	                    }

	                    this.line_char_count++;
	                    content.push(input_char); //inserts character at-a-time (or string)

	                    if (content[1] && (content[1] === '!' || content[1] === '?' || content[1] === '%')) { //if we're in a comment, do something special
	                        // We treat all comments as literals, even more than preformatted tags
	                        // we just look for the appropriate close tag
	                        content = [this.get_comment(tag_start)];
	                        break;
	                    }

	                    if (indent_handlebars && content[1] && content[1] === '{' && content[2] && content[2] === '!') { //if we're in a comment, do something special
	                        // We treat all comments as literals, even more than preformatted tags
	                        // we just look for the appropriate close tag
	                        content = [this.get_comment(tag_start)];
	                        break;
	                    }

	                    if (indent_handlebars && tag_start_char === '{' && content.length > 2 && content[content.length - 2] === '}' && content[content.length - 1] === '}') {
	                        break;
	                    }
	                } while (input_char !== '>');

	                var tag_complete = content.join('');
	                var tag_index;
	                var tag_offset;

	                if (tag_complete.indexOf(' ') !== -1) { //if there's whitespace, thats where the tag name ends
	                    tag_index = tag_complete.indexOf(' ');
	                } else if (tag_complete.charAt(0) === '{') {
	                    tag_index = tag_complete.indexOf('}');
	                } else { //otherwise go with the tag ending
	                    tag_index = tag_complete.indexOf('>');
	                }
	                if (tag_complete.charAt(0) === '<' || !indent_handlebars) {
	                    tag_offset = 1;
	                } else {
	                    tag_offset = tag_complete.charAt(2) === '#' ? 3 : 2;
	                }
	                var tag_check = tag_complete.substring(tag_offset, tag_index).toLowerCase();
	                if (tag_complete.charAt(tag_complete.length - 2) === '/' ||
	                    this.Utils.in_array(tag_check, this.Utils.single_token)) { //if this tag name is a single tag type (either in the list or has a closing /)
	                    if (!peek) {
	                        this.tag_type = 'SINGLE';
	                    }
	                } else if (indent_handlebars && tag_complete.charAt(0) === '{' && tag_check === 'else') {
	                    if (!peek) {
	                        this.indent_to_tag('if');
	                        this.tag_type = 'HANDLEBARS_ELSE';
	                        this.indent_content = true;
	                        this.traverse_whitespace();
	                    }
	                } else if (this.is_unformatted(tag_check, unformatted)) { // do not reformat the "unformatted" tags
	                    comment = this.get_unformatted('</' + tag_check + '>', tag_complete); //...delegate to get_unformatted function
	                    content.push(comment);
	                    tag_end = this.pos - 1;
	                    this.tag_type = 'SINGLE';
	                } else if (tag_check === 'script' &&
	                    (tag_complete.search('type') === -1 ||
	                    (tag_complete.search('type') > -1 &&
	                    tag_complete.search(/\b(text|application)\/(x-)?(javascript|ecmascript|jscript|livescript)/) > -1))) {
	                    if (!peek) {
	                        this.record_tag(tag_check);
	                        this.tag_type = 'SCRIPT';
	                    }
	                } else if (tag_check === 'style' &&
	                    (tag_complete.search('type') === -1 ||
	                    (tag_complete.search('type') > -1 && tag_complete.search('text/css') > -1))) {
	                    if (!peek) {
	                        this.record_tag(tag_check);
	                        this.tag_type = 'STYLE';
	                    }
	                } else if (tag_check.charAt(0) === '!') { //peek for <! comment
	                    // for comments content is already correct.
	                    if (!peek) {
	                        this.tag_type = 'SINGLE';
	                        this.traverse_whitespace();
	                    }
	                } else if (!peek) {
	                    if (tag_check.charAt(0) === '/') { //this tag is a double tag so check for tag-ending
	                        this.retrieve_tag(tag_check.substring(1)); //remove it and all ancestors
	                        this.tag_type = 'END';
	                    } else { //otherwise it's a start-tag
	                        this.record_tag(tag_check); //push it on the tag stack
	                        if (tag_check.toLowerCase() !== 'html') {
	                            this.indent_content = true;
	                        }
	                        this.tag_type = 'START';
	                    }

	                    // Allow preserving of newlines after a start or end tag
	                    if (this.traverse_whitespace()) {
	                        this.space_or_wrap(content);
	                    }

	                    if (this.Utils.in_array(tag_check, this.Utils.extra_liners)) { //check if this double needs an extra line
	                        this.print_newline(false, this.output);
	                        if (this.output.length && this.output[this.output.length - 2] !== '\n') {
	                            this.print_newline(true, this.output);
	                        }
	                    }
	                }

	                if (peek) {
	                    this.pos = orig_pos;
	                    this.line_char_count = orig_line_char_count;
	                }

	                return content.join(''); //returns fully formatted tag
	            };

	            this.get_comment = function(start_pos) { //function to return comment content in its entirety
	                // this is will have very poor perf, but will work for now.
	                var comment = '',
	                    delimiter = '>',
	                    matched = false;

	                this.pos = start_pos;
	                input_char = this.input.charAt(this.pos);
	                this.pos++;

	                while (this.pos <= this.input.length) {
	                    comment += input_char;

	                    // only need to check for the delimiter if the last chars match
	                    if (comment.charAt(comment.length - 1) === delimiter.charAt(delimiter.length - 1) &&
	                        comment.indexOf(delimiter) !== -1) {
	                        break;
	                    }

	                    // only need to search for custom delimiter for the first few characters
	                    if (!matched && comment.length < 10) {
	                        if (comment.indexOf('<![if') === 0) { //peek for <![if conditional comment
	                            delimiter = '<![endif]>';
	                            matched = true;
	                        } else if (comment.indexOf('<![cdata[') === 0) { //if it's a <[cdata[ comment...
	                            delimiter = ']]>';
	                            matched = true;
	                        } else if (comment.indexOf('<![') === 0) { // some other ![ comment? ...
	                            delimiter = ']>';
	                            matched = true;
	                        } else if (comment.indexOf('<!--') === 0) { // <!-- comment ...
	                            delimiter = '-->';
	                            matched = true;
	                        } else if (comment.indexOf('{{!') === 0) { // {{! handlebars comment
	                            delimiter = '}}';
	                            matched = true;
	                        } else if (comment.indexOf('<?') === 0) { // {{! handlebars comment
	                            delimiter = '?>';
	                            matched = true;
	                        } else if (comment.indexOf('<%') === 0) { // {{! handlebars comment
	                            delimiter = '%>';
	                            matched = true;
	                        }
	                    }

	                    input_char = this.input.charAt(this.pos);
	                    this.pos++;
	                }

	                return comment;
	            };

	            this.get_unformatted = function(delimiter, orig_tag) { //function to return unformatted content in its entirety

	                if (orig_tag && orig_tag.toLowerCase().indexOf(delimiter) !== -1) {
	                    return '';
	                }
	                var input_char = '';
	                var content = '';
	                var min_index = 0;
	                var space = true;
	                do {

	                    if (this.pos >= this.input.length) {
	                        return content;
	                    }

	                    input_char = this.input.charAt(this.pos);
	                    this.pos++;

	                    if (this.Utils.in_array(input_char, this.Utils.whitespace)) {
	                        if (!space) {
	                            this.line_char_count--;
	                            continue;
	                        }
	                        if (input_char === '\n' || input_char === '\r') {
	                            content += '\n';
	                            /*  Don't change tab indention for unformatted blocks.  If using code for html editing, this will greatly affect <pre> tags if they are specified in the 'unformatted array'
	                for (var i=0; i<this.indent_level; i++) {
	                  content += this.indent_string;
	                }
	                space = false; //...and make sure other indentation is erased
	                */
	                            this.line_char_count = 0;
	                            continue;
	                        }
	                    }
	                    content += input_char;
	                    this.line_char_count++;
	                    space = true;

	                    if (indent_handlebars && input_char === '{' && content.length && content.charAt(content.length - 2) === '{') {
	                        // Handlebars expressions in strings should also be unformatted.
	                        content += this.get_unformatted('}}');
	                        // These expressions are opaque.  Ignore delimiters found in them.
	                        min_index = content.length;
	                    }
	                } while (content.toLowerCase().indexOf(delimiter, min_index) === -1);
	                return content;
	            };

	            this.get_token = function() { //initial handler for token-retrieval
	                var token;

	                if (this.last_token === 'TK_TAG_SCRIPT' || this.last_token === 'TK_TAG_STYLE') { //check if we need to format javascript
	                    var type = this.last_token.substr(7);
	                    token = this.get_contents_to(type);
	                    if (typeof token !== 'string') {
	                        return token;
	                    }
	                    return [token, 'TK_' + type];
	                }
	                if (this.current_mode === 'CONTENT') {
	                    token = this.get_content();
	                    if (typeof token !== 'string') {
	                        return token;
	                    } else {
	                        return [token, 'TK_CONTENT'];
	                    }
	                }

	                if (this.current_mode === 'TAG') {
	                    token = this.get_tag();
	                    if (typeof token !== 'string') {
	                        return token;
	                    } else {
	                        var tag_name_type = 'TK_TAG_' + this.tag_type;
	                        return [token, tag_name_type];
	                    }
	                }
	            };

	            this.get_full_indent = function(level) {
	                level = this.indent_level + level || 0;
	                if (level < 1) {
	                    return '';
	                }

	                return Array(level + 1).join(this.indent_string);
	            };

	            this.is_unformatted = function(tag_check, unformatted) {
	                //is this an HTML5 block-level link?
	                if (!this.Utils.in_array(tag_check, unformatted)) {
	                    return false;
	                }

	                if (tag_check.toLowerCase() !== 'a' || !this.Utils.in_array('a', unformatted)) {
	                    return true;
	                }

	                //at this point we have an  tag; is its first child something we want to remain
	                //unformatted?
	                var next_tag = this.get_tag(true /* peek. */ );

	                // test next_tag to see if it is just html tag (no external content)
	                var tag = (next_tag || "").match(/^\s*<\s*\/?([a-z]*)\s*[^>]*>\s*$/);

	                // if next_tag comes back but is not an isolated tag, then
	                // let's treat the 'a' tag as having content
	                // and respect the unformatted option
	                if (!tag || this.Utils.in_array(tag, unformatted)) {
	                    return true;
	                } else {
	                    return false;
	                }
	            };

	            this.printer = function(js_source, indent_character, indent_size, wrap_line_length, brace_style) { //handles input/output and some other printing functions

	                this.input = js_source || ''; //gets the input for the Parser

	                // HACK: newline parsing inconsistent. This brute force normalizes the input.
	                this.input = this.input.replace(/\r\n|[\r\u2028\u2029]/g, '\n')

	                this.output = [];
	                this.indent_character = indent_character;
	                this.indent_string = '';
	                this.indent_size = indent_size;
	                this.brace_style = brace_style;
	                this.indent_level = 0;
	                this.wrap_line_length = wrap_line_length;
	                this.line_char_count = 0; //count to see if wrap_line_length was exceeded

	                for (var i = 0; i < this.indent_size; i++) {
	                    this.indent_string += this.indent_character;
	                }

	                this.print_newline = function(force, arr) {
	                    this.line_char_count = 0;
	                    if (!arr || !arr.length) {
	                        return;
	                    }
	                    if (force || (arr[arr.length - 1] !== '\n')) { //we might want the extra line
	                        if ((arr[arr.length - 1] !== '\n')) {
	                            arr[arr.length - 1] = rtrim(arr[arr.length - 1]);
	                        }
	                        arr.push('\n');
	                    }
	                };

	                this.print_indentation = function(arr) {
	                    for (var i = 0; i < this.indent_level; i++) {
	                        arr.push(this.indent_string);
	                        this.line_char_count += this.indent_string.length;
	                    }
	                };

	                this.print_token = function(text) {
	                    // Avoid printing initial whitespace.
	                    if (this.is_whitespace(text) && !this.output.length) {
	                        return;
	                    }
	                    if (text || text !== '') {
	                        if (this.output.length && this.output[this.output.length - 1] === '\n') {
	                            this.print_indentation(this.output);
	                            text = ltrim(text);
	                        }
	                    }
	                    this.print_token_raw(text);
	                };

	                this.print_token_raw = function(text) {
	                    // If we are going to print newlines, truncate trailing
	                    // whitespace, as the newlines will represent the space.
	                    if (this.newlines > 0) {
	                        text = rtrim(text);
	                    }

	                    if (text && text !== '') {
	                        if (text.length > 1 && text.charAt(text.length - 1) === '\n') {
	                            // unformatted tags can grab newlines as their last character
	                            this.output.push(text.slice(0, -1));
	                            this.print_newline(false, this.output);
	                        } else {
	                            this.output.push(text);
	                        }
	                    }

	                    for (var n = 0; n < this.newlines; n++) {
	                        this.print_newline(n > 0, this.output);
	                    }
	                    this.newlines = 0;
	                };

	                this.indent = function() {
	                    this.indent_level++;
	                };

	                this.unindent = function() {
	                    if (this.indent_level > 0) {
	                        this.indent_level--;
	                    }
	                };
	            };
	            return this;
	        }

	        /*_____________________--------------------_____________________*/

	        multi_parser = new Parser(); //wrapping functions Parser
	        multi_parser.printer(html_source, indent_character, indent_size, wrap_line_length, brace_style); //initialize starting values

	        while (true) {
	            var t = multi_parser.get_token();
	            multi_parser.token_text = t[0];
	            multi_parser.token_type = t[1];

	            if (multi_parser.token_type === 'TK_EOF') {
	                break;
	            }

	            switch (multi_parser.token_type) {
	                case 'TK_TAG_START':
	                    multi_parser.print_newline(false, multi_parser.output);
	                    multi_parser.print_token(multi_parser.token_text);
	                    if (multi_parser.indent_content) {
	                        multi_parser.indent();
	                        multi_parser.indent_content = false;
	                    }
	                    multi_parser.current_mode = 'CONTENT';
	                    break;
	                case 'TK_TAG_STYLE':
	                case 'TK_TAG_SCRIPT':
	                    multi_parser.print_newline(false, multi_parser.output);
	                    multi_parser.print_token(multi_parser.token_text);
	                    multi_parser.current_mode = 'CONTENT';
	                    break;
	                case 'TK_TAG_END':
	                    //Print new line only if the tag has no content and has child
	                    if (multi_parser.last_token === 'TK_CONTENT' && multi_parser.last_text === '') {
	                        var tag_name = multi_parser.token_text.match(/\w+/)[0];
	                        var tag_extracted_from_last_output = null;
	                        if (multi_parser.output.length) {
	                            tag_extracted_from_last_output = multi_parser.output[multi_parser.output.length - 1].match(/(?:<|{{#)\s*(\w+)/);
	                        }
	                        if (tag_extracted_from_last_output === null ||
	                            (tag_extracted_from_last_output[1] !== tag_name && !multi_parser.Utils.in_array(tag_extracted_from_last_output[1], unformatted))) {
	                            multi_parser.print_newline(false, multi_parser.output);
	                        }
	                    }
	                    multi_parser.print_token(multi_parser.token_text);
	                    multi_parser.current_mode = 'CONTENT';
	                    break;
	                case 'TK_TAG_SINGLE':
	                    // Don't add a newline before elements that should remain unformatted.
	                    var tag_check = multi_parser.token_text.match(/^\s*<([a-z-]+)/i);
	                    if (!tag_check || !multi_parser.Utils.in_array(tag_check[1], unformatted)) {
	                        multi_parser.print_newline(false, multi_parser.output);
	                    }
	                    multi_parser.print_token(multi_parser.token_text);
	                    multi_parser.current_mode = 'CONTENT';
	                    break;
	                case 'TK_TAG_HANDLEBARS_ELSE':
	                    multi_parser.print_token(multi_parser.token_text);
	                    if (multi_parser.indent_content) {
	                        multi_parser.indent();
	                        multi_parser.indent_content = false;
	                    }
	                    multi_parser.current_mode = 'CONTENT';
	                    break;
	                case 'TK_TAG_HANDLEBARS_COMMENT':
	                    multi_parser.print_token(multi_parser.token_text);
	                    multi_parser.current_mode = 'TAG';
	                    break;
	                case 'TK_CONTENT':
	                    multi_parser.print_token(multi_parser.token_text);
	                    multi_parser.current_mode = 'TAG';
	                    break;
	                case 'TK_STYLE':
	                case 'TK_SCRIPT':
	                    if (multi_parser.token_text !== '') {
	                        multi_parser.print_newline(false, multi_parser.output);
	                        var text = multi_parser.token_text,
	                            _beautifier,
	                            script_indent_level = 1;
	                        if (multi_parser.token_type === 'TK_SCRIPT') {
	                            _beautifier = typeof js_beautify === 'function' && js_beautify;
	                        } else if (multi_parser.token_type === 'TK_STYLE') {
	                            _beautifier = typeof css_beautify === 'function' && css_beautify;
	                        }

	                        if (options.indent_scripts === "keep") {
	                            script_indent_level = 0;
	                        } else if (options.indent_scripts === "separate") {
	                            script_indent_level = -multi_parser.indent_level;
	                        }

	                        var indentation = multi_parser.get_full_indent(script_indent_level);
	                        if (_beautifier) {

	                            // call the Beautifier if avaliable
	                            var Child_options = function() {
	                                this.eol = '\n';
	                            };
	                            Child_options.prototype = options;
	                            var child_options = new Child_options();
	                            text = _beautifier(text.replace(/^\s*/, indentation), child_options);
	                        } else {
	                            // simply indent the string otherwise
	                            var white = text.match(/^\s*/)[0];
	                            var _level = white.match(/[^\n\r]*$/)[0].split(multi_parser.indent_string).length - 1;
	                            var reindent = multi_parser.get_full_indent(script_indent_level - _level);
	                            text = text.replace(/^\s*/, indentation)
	                                .replace(/\r\n|\r|\n/g, '\n' + reindent)
	                                .replace(/\s+$/, '');
	                        }
	                        if (text) {
	                            multi_parser.print_token_raw(text);
	                            multi_parser.print_newline(true, multi_parser.output);
	                        }
	                    }
	                    multi_parser.current_mode = 'TAG';
	                    break;
	                default:
	                    // We should not be getting here but we don't want to drop input on the floor
	                    // Just output the text and move on
	                    if (multi_parser.token_text !== '') {
	                        multi_parser.print_token(multi_parser.token_text);
	                    }
	                    break;
	            }
	            multi_parser.last_token = multi_parser.token_type;
	            multi_parser.last_text = multi_parser.token_text;
	        }
	        var sweet_code = multi_parser.output.join('').replace(/[\r\n\t ]+$/, '');

	        // establish end_with_newline
	        if (end_with_newline) {
	            sweet_code += '\n';
	        }

	        if (eol != '\n') {
	            sweet_code = sweet_code.replace(/[\n]/g, eol);
	        }

	        return sweet_code;
	    }

	    if (true) {
	        // Add support for AMD ( https://github.com/amdjs/amdjs-api/wiki/AMD#defineamd-property- )
	        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__, __webpack_require__(46), __webpack_require__(47)], __WEBPACK_AMD_DEFINE_RESULT__ = function(requireamd) {
	            var js_beautify =  __webpack_require__(46);
	            var css_beautify =  __webpack_require__(47);

	            return {
	              html_beautify: function(html_source, options) {
	                return style_html(html_source, options, js_beautify.js_beautify, css_beautify.css_beautify);
	              }
	            };
	        }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	    } else if (typeof exports !== "undefined") {
	        // Add support for CommonJS. Just put this file somewhere on your require.paths
	        // and you will be able to `var html_beautify = require("beautify").html_beautify`.
	        var js_beautify = require('./beautify.js');
	        var css_beautify = require('./beautify-css.js');

	        exports.html_beautify = function(html_source, options) {
	            return style_html(html_source, options, js_beautify.js_beautify, css_beautify.css_beautify);
	        };
	    } else if (typeof window !== "undefined") {
	        // If we're running a web page and don't have either of the above, add our one global
	        window.html_beautify = function(html_source, options) {
	            return style_html(html_source, options, window.js_beautify, window.css_beautify);
	        };
	    } else if (typeof global !== "undefined") {
	        // If we don't even have window, try global.
	        global.html_beautify = function(html_source, options) {
	            return style_html(html_source, options, global.js_beautify, global.css_beautify);
	        };
	    }

	}());


/***/ },
/* 49 */
/***/ function(module, exports) {



/***/ },
/* 50 */
/***/ function(module, exports, __webpack_require__) {

	var map = {
		"./Person": 51,
		"./Person.js": 51
	};
	function webpackContext(req) {
		return __webpack_require__(webpackContextResolve(req));
	};
	function webpackContextResolve(req) {
		return map[req] || (function() { throw new Error("Cannot find module '" + req + "'.") }());
	};
	webpackContext.keys = function webpackContextKeys() {
		return Object.keys(map);
	};
	webpackContext.resolve = webpackContextResolve;
	module.exports = webpackContext;
	webpackContext.id = 50;


/***/ },
/* 51 */
/***/ function(module, exports) {

	module.exports = {
		dataModel: {
			name: 'John Doe',
			email: 'a@b.hu',
			terms: true,
			emails: [ 'test@be.org' ],
			addresses: [
				{
					city: 'Debrecen',
					street: 'Vrndavana',
					active: true
				}
			],
			template: function(){
				return '<text> AbrakaDabra </text>';
			}
		},
		validation: {
			name: { minlength: 6, element: ["John Doe"] },
			email: { type: 'email' }
		}
	};


/***/ },
/* 52 */
/***/ function(module, exports, __webpack_require__) {

	var map = {
		"./Content.js": 53
	};
	function webpackContext(req) {
		return __webpack_require__(webpackContextResolve(req));
	};
	function webpackContextResolve(req) {
		return map[req] || (function() { throw new Error("Cannot find module '" + req + "'.") }());
	};
	webpackContext.keys = function webpackContextKeys() {
		return Object.keys(map);
	};
	webpackContext.resolve = webpackContextResolve;
	module.exports = webpackContext;
	webpackContext.id = 52;


/***/ },
/* 53 */
/***/ function(module, exports, __webpack_require__) {

	var m = __webpack_require__(3);

	var mapper = __webpack_require__(54);
	var mapObject = mapper.mapObject.bind(mapper);

	var _ = __webpack_require__(7);

	var v = __webpack_require__(143);

	var Hammer = __webpack_require__(145);
	delete Hammer.defaults.cssProps.userSelect;

	function addClass(el, className) {
		if (el.classList)
			el.classList.add(className);
		else
			el.className += ' ' + className;
		return this;
	}

	function removeClass(el, className) {
		if (el.classList)
			el.classList.remove(className);
		else
			el.className = el.className.replace(new RegExp('(^|\\b)' + className.split(' ').join('|') + '(\\b|$)', 'gi'), ' ');
		return this;
	}

	function capitalizeFirstLetter(string) {
		return string.charAt(0).toUpperCase() + string.slice(1);
	}

	function valuateEventBinders(ctrl, viewName, context, element, model, path, milieu) {
		var compute = context.stopComputationForEvents || !!milieu['data-compute'];
		for (var key in milieu) {
			if (key && key.indexOf('data-event-') === 0) {
				var eventName = key.substring('data-event-'.length);
				var fnName = milieu[key];
				if (!element.id) {
					console.error('ID is required for event binding', element);
					throw new Error('ID is required for event binding');
				}
				var refName = eventName + 'For' + element.id; // viewName + (element.id||'') + 'At' + path;
				if (!context[refName]) {
					if (!context[fnName] || !_.isFunction(context[fnName]))
						throw new Error('Missing event handler for: ' + eventName + ' by name of: ' + milieu[key]);
					context[refName] = function() {
						var args = arguments;
						setTimeout(function() {
							if (compute)
								m.startComputation();
							context[fnName].apply(context, args);
							if (compute)
								m.endComputation();
						}, 0);
					};
				}
				element.removeEventListener(eventName, context[refName]);
				element.addEventListener(eventName, context[refName]);
			}
		}
	}

	function checkContent(milieu, key) {
		return milieu[key];
	}

	function valuateContent(ctrl, controlOptions, context, element, model, path, milieu, value) {
		if (!value) return null;
		var f = new Function('$ctrl', '$opts', '$context', '$root', '$array', '$item', '$index', 'return ' + value + ';');
		try {
			return {
				value: f(ctrl, controlOptions, context, model, milieu.array, milieu.item || model, milieu.index)
			};
		} catch (err) {
			err.message = 'While evaluating: ' + value + ' ' + err.message;
			console.error(err);
		}
		return null;
	}

	function valuateVisibility(ctrl, controlOptions, context, element, model, path, milieu) {
		var res = valuateContent(ctrl, controlOptions, context, element, model, path, milieu, milieu['data-visible']);
		if (res) {
			element.style.visibility = res.value ? 'visible' : 'hidden';
		}
	}

	function valuateDisplay(ctrl, controlOptions, context, element, model, path, milieu) {
		var res = valuateContent(ctrl, controlOptions, context, element, model, path, milieu, milieu['data-display']);
		if (res) {
			element.style.display = res.value ? 'inline' : 'none';
		}
	}

	function valuateHTML(ctrl, controlOptions, context, element, model, path, milieu) {
		var res = valuateContent(ctrl, controlOptions, context, element, model, path, milieu, milieu['data-html']);
		if (res) {
			while (element.firstChild)
				element.removeChild(element.firstChild);
			try {
				element.insertAdjacentHTML('afterbegin', res.value);
			} catch (err) {
				err.message = 'While parsing html text: ' + res.value + ' ' + err.message;
				console.error(err);
			}
		}
	}

	function valuateStyle(ctrl, controlOptions, context, element, model, path, milieu) {
		var res = valuateContent(ctrl, controlOptions, context, element, model, path, milieu, milieu['data-style']);
		if (res) {
			var styles = res.value;
			for (var key in styles) {
				if (key) {
					if (styles[key])
						element.style[key] = styles[key];
					else
						delete element.style[key];
				}
			}
		}
	}

	function valuateSelect(ctrl, controlOptions, context, element, model, path, milieu) {
		var res = valuateContent(ctrl, controlOptions, context, element, model, path, milieu, milieu['data-select']);
		if (res) {
			var selection = res.value;
			if (selection)
				addClass(element, 'selected');
			else
				removeClass(element, 'selected');
		}
	}

	function valuateAttribute(ctrl, controlOptions, context, element, model, path, milieu) {
		var res = valuateContent(ctrl, controlOptions, context, element, model, path, milieu, milieu['data-attr']);
		if (res) {
			var attributes = res.value;
			for (var key in attributes) {
				if (key) {
					if (key === 'class')
						addClass(element, attributes[key]);
					else
						element[key] = attributes[key];
				}
			}
		}
	}

	function valuateMember(ctrl, element, milieu) {
		if (checkContent(milieu, 'data-member')) {
			var capName = capitalizeFirstLetter(milieu['data-member']);
			element.checked = ctrl['hasIn' + capName](element.value || element.name);
		}
	}

	function valuateTap(ctrl, viewName, modelName, controlOptions, context, element, model, path, milieu) {
		if (checkContent(milieu, 'data-tap')) {
			if (!milieu['data-tap'] || (milieu['data-tap'] === 'false')) return;

			new Hammer(element, {}).on("tap", function(ev) {
				var eventName = (milieu['data-tap'] === 'true') ? ('tapedOn' + viewName) : milieu['data-tap'];
				if (eventName.charAt(0) === '$') eventName = valuateContent(ctrl, controlOptions, context, element, model, path, milieu, eventName).value;
				console.log('>>>>>>>>', eventName);
				if (context && context.emit) {
					context.emit(eventName, viewName, modelName, element, ctrl, model, path, milieu);
				}
			});
		}
	}

	function readValidationRule(model, path, V) {
		var qualifiers = path.split('.');
		var value = model,
			contraint = V;
		for (var i = 0; i < qualifiers.length && value[qualifiers[i]] && contraint[qualifiers[i]]; ++i) {
			value = value[qualifiers[i]];
			contraint = contraint[qualifiers[i]];
		}
		return {
			value: value,
			contraint: contraint
		};
	}

	function createConfig(ctrl, controlOptions, viewName, modelName, appContext, model, path, milieu) {
		return function(element, isInitialized, context) {
			valuateMember(ctrl, element, milieu);
			valuateVisibility(ctrl, controlOptions, appContext, element, model, path, milieu);
			valuateDisplay(ctrl, controlOptions, appContext, element, model, path, milieu);
			valuateHTML(ctrl, controlOptions, appContext, element, model, path, milieu);
			valuateStyle(ctrl, controlOptions, appContext, element, model, path, milieu);
			valuateSelect(ctrl, controlOptions, appContext, element, model, path, milieu);
			valuateAttribute(ctrl, controlOptions, appContext, element, model, path, milieu);
			if (!isInitialized) {
				valuateEventBinders(ctrl, viewName, appContext, element, model, path, milieu);
				valuateTap(ctrl, viewName, modelName, controlOptions, appContext, element, model, path, milieu);
			} else if (milieu.clearElement && milieu.invalidElement && milieu.validElement) {
				var vRule = readValidationRule(model, path, milieu.V);
				if (vRule.value && _.isFunction(vRule.value) && vRule.contraint) {
					var inValid = v.validate(vRule.value(), vRule.contraint, model);
					milieu.clearElement(element);
					if (inValid)
						milieu.invalidElement(element, inValid);
					else
						milieu.validElement(element);
				}
			}
		};
	}

	module.exports = {
		mount: function(model, context, viewName, modelName, element, envOptions, controlOptions) {
			var Controller = mapObject(modelName, model.validation);
			var firstRun = true;

			if (controlOptions)
				Array.prototype.forEach.call(Object.keys(controlOptions), function(key, i) {
					if (!Controller[key])
						Controller[key] = controlOptions[key];
				});

			var Component = {
				controller: Controller,
				view: function(ctrl, mdl) {
					ctrl.dateFormat = envOptions ? envOptions.dateFormat : 'DD.MM.YYYY';
					if (firstRun) {
						context[modelName].vcs.push({
							model: ctrl[modelName],
							controller: ctrl
						});
						if (context && context.emit) context.emit('init' + viewName + 'Controller', ctrl, mdl);
						firstRun = false;
					}
					return m("div", {
						"className": "section"
					}, [m("text", {
						"className": "h6"
					}, ["Sign up"]), m("br", {
						"className": ""
					}, []), m("input", {
						value: ctrl[modelName].name(),
						oninput: m.withAttr('value', ctrl[modelName].name),
						config: createConfig(ctrl, controlOptions, viewName, modelName, context, ctrl[modelName], 'name', {
							V: ctrl._validation,
							clearElement: context.clearElement,
							invalidElement: context.invalidElement,
							validElement: context.validElement
						}),
						"type": "text",
						"id": "join_name",
						"placeholder": "Your name",
						"data-bind": "name",
						"className": "c_ds_blue hN text-center"
					}, []), m("br", {
						"className": ""
					}, []), m("input", {
						value: ctrl[modelName].email(),
						oninput: m.withAttr('value', ctrl[modelName].email),
						config: createConfig(ctrl, controlOptions, viewName, modelName, context, ctrl[modelName], 'email', {
							V: ctrl._validation,
							clearElement: context.clearElement,
							invalidElement: context.invalidElement,
							validElement: context.validElement
						}),
						"type": "text",
						"id": "join_email",
						"placeholder": "Your email address",
						"data-bind": "email",
						"className": "c_ds_blue hN text-center"
					}, []), m("br", {
						"className": ""
					}, []), m("text", {
						"className": ""
					}, ["Accept?"]), m("input", {
						value: ctrl[modelName].terms(),
						onclick: m.withAttr('checked', ctrl[modelName].terms),
						checked: ctrl[modelName].terms(),
						config: createConfig(ctrl, controlOptions, viewName, modelName, context, ctrl[modelName], 'terms', {
							V: ctrl._validation,
							clearElement: context.clearElement,
							invalidElement: context.invalidElement,
							validElement: context.validElement
						}),
						"type": "checkbox",
						"data-bind": "terms",
						"className": "checkbox"
					}, []), m("br", {
						"className": ""
					}, []), m("text", {
						config: createConfig(ctrl, controlOptions, viewName, modelName, context, ctrl[modelName], '', {
							'data-visible': "$item.terms()",
							V: ctrl._validation,
							clearElement: context.clearElement,
							invalidElement: context.invalidElement,
							validElement: context.validElement
						}),
						"data-visible": "$item.terms()",
						"className": ""
					}, ["Accept check"]), m("br", {
						"className": ""
					}, []), m("br", {
						"className": ""
					}, []), m("text", {
						textContent: ctrl[modelName].name(),
						config: createConfig(ctrl, controlOptions, viewName, modelName, context, ctrl[modelName], 'name', {
							V: ctrl._validation,
							clearElement: context.clearElement,
							invalidElement: context.invalidElement,
							validElement: context.validElement
						}),
						"data-value": "name",
						"className": ""
					}, ["Addresses:"]), m("br", {
						"className": ""
					}, []), m("select", {
						config: createConfig(ctrl, controlOptions, viewName, modelName, context, ctrl[modelName], 'emails', {
							'data-event-change': "emailSelected",
							V: ctrl._validation,
							clearElement: context.clearElement,
							invalidElement: context.invalidElement,
							validElement: context.validElement
						}),
						"id": "emails",
						"data-each": "emails",
						"data-event-change": "emailSelected",
						"className": ""
					}, ctrl[modelName].emails.map(function(item, index, array) {
						return [m("option", {
							textContent: item(),
							config: createConfig(ctrl, controlOptions, viewName, modelName, context, ctrl[modelName], 'emails.$item', {
								array: array,
								item: item,
								index: index,
								'data-attr': "{ value: $item() }",
								V: ctrl._validation,
								clearElement: context.clearElement,
								invalidElement: context.invalidElement,
								validElement: context.validElement
							}),
							"data-value": "$item",
							"data-attr": "{ value: $item() }",
							"className": ""
						}, [])];
					})), m("div", {
						config: createConfig(ctrl, controlOptions, viewName, modelName, context, ctrl[modelName], 'addresses', {
							V: ctrl._validation,
							clearElement: context.clearElement,
							invalidElement: context.invalidElement,
							validElement: context.validElement
						}),
						"data-each": "addresses",
						"className": "row-section"
					}, ctrl[modelName].addresses.map(function(item, index, array) {
						return [m("div", {
							"className": "row"
						}, [m("input", {
							value: item.city(),
							oninput: m.withAttr('value', item.city),
							config: createConfig(ctrl, controlOptions, viewName, modelName, context, ctrl[modelName], 'addresses.city', {
								array: array,
								item: item,
								index: index,
								V: ctrl._validation,
								clearElement: context.clearElement,
								invalidElement: context.invalidElement,
								validElement: context.validElement
							}),
							"type": "text",
							"placeholder": "Your city",
							"data-bind": "city",
							"className": "c_ds_blue hN text-center"
						}, []), m("br", {
							"className": ""
						}, []), m("input", {
							value: item.street(),
							oninput: m.withAttr('value', item.street),
							config: createConfig(ctrl, controlOptions, viewName, modelName, context, ctrl[modelName], 'addresses.street', {
								array: array,
								item: item,
								index: index,
								V: ctrl._validation,
								clearElement: context.clearElement,
								invalidElement: context.invalidElement,
								validElement: context.validElement
							}),
							"type": "text",
							"placeholder": "Your street",
							"data-bind": "street",
							"className": "c_ds_blue hN text-center"
						}, []), m("br", {
							"className": ""
						}, []), m("input", {
							value: item.active(),
							onclick: m.withAttr('checked', item.active),
							checked: item.active(),
							config: createConfig(ctrl, controlOptions, viewName, modelName, context, ctrl[modelName], 'addresses.active', {
								array: array,
								item: item,
								index: index,
								V: ctrl._validation,
								clearElement: context.clearElement,
								invalidElement: context.invalidElement,
								validElement: context.validElement
							}),
							"type": "checkbox",
							"data-bind": "active",
							"className": "checkbox"
						}, []), m("br", {
							"className": ""
						}, []), m("text", {
							config: createConfig(ctrl, controlOptions, viewName, modelName, context, ctrl[modelName], 'addresses', {
								array: array,
								item: item,
								index: index,
								'data-visible': "$item.active()",
								V: ctrl._validation,
								clearElement: context.clearElement,
								invalidElement: context.invalidElement,
								validElement: context.validElement
							}),
							"data-visible": "$item.active()",
							"className": ""
						}, ["Visibility check"]), m("br", {
							"className": ""
						}, []), m("text", {
							config: createConfig(ctrl, controlOptions, viewName, modelName, context, ctrl[modelName], 'addresses', {
								array: array,
								item: item,
								index: index,
								'data-attr': "{ id: ($item.active() ? 'kortefa' : 'almafa') }",
								V: ctrl._validation,
								clearElement: context.clearElement,
								invalidElement: context.invalidElement,
								validElement: context.validElement
							}),
							"data-attr": "{ id: ($item.active() ? 'kortefa' : 'almafa') }",
							"className": ""
						}, ["Gymlcss"]), m("br", {
							"className": ""
						}, []), m("text", {
							config: createConfig(ctrl, controlOptions, viewName, modelName, context, ctrl[modelName], 'addresses', {
								array: array,
								item: item,
								index: index,
								'data-style': "{ color: ($item.active() ? 'green' : 'red') }",
								V: ctrl._validation,
								clearElement: context.clearElement,
								invalidElement: context.invalidElement,
								validElement: context.validElement
							}),
							"data-style": "{ color: ($item.active() ? 'green' : 'red') }",
							"className": ""
						}, ["Colored"]), m("br", {
							"className": ""
						}, []), m("div", {
							config: createConfig(ctrl, controlOptions, viewName, modelName, context, ctrl[modelName], 'addresses', {
								array: array,
								item: item,
								index: index,
								'data-html': "$root.template()",
								V: ctrl._validation,
								clearElement: context.clearElement,
								invalidElement: context.invalidElement,
								validElement: context.validElement
							}),
							"data-html": "$root.template()",
							"className": ""
						}, []), m("br", {
							"className": ""
						}, []), m("div", {
							config: createConfig(ctrl, controlOptions, viewName, modelName, context, ctrl[modelName], 'addresses', {
								array: array,
								item: item,
								index: index,
								'data-tap': "$item.city()",
								V: ctrl._validation,
								clearElement: context.clearElement,
								invalidElement: context.invalidElement,
								validElement: context.validElement
							}),
							"id": "city-clicker",
							"data-tap": "$item.city()",
							"className": ""
						}, [m("text", {
							"className": ""
						}, ["Event by city"])])])];
					})), m("br", {
						"className": ""
					}, []), m("div", {
						config: createConfig(ctrl, controlOptions, viewName, modelName, context, ctrl[modelName], '', {
							'data-tap': "clicked",
							V: ctrl._validation,
							clearElement: context.clearElement,
							invalidElement: context.invalidElement,
							validElement: context.validElement
						}),
						"id": "clicker",
						"data-tap": "clicked",
						"className": ""
					}, [m("text", {
						"className": ""
					}, ["Click me!"])])]);
				}

			};

			if (context && context.emit)
				context.emit('init' + viewName + 'ViewModel', model.dataModel);

			//m.mount( element, { controller: controller, view: Component.view} );
			m.mount(element, m.component(Component, model.dataModel));
		}
	};


/***/ },
/* 54 */
/***/ function(module, exports, __webpack_require__) {

	var _ = __webpack_require__(55);
	var m = __webpack_require__(3);

	var moment = __webpack_require__(56);
	var defaultFormat = "YYYY-MM-DD HH:mm";

	function walk( model ){
		var res;
		if( _.isFunction( model ) )
			res = model.purify ? model.purify() : model();
		else if( _.isArray( model ) ){
			res = [];
			model.forEach(function(item){
				res.push( walk( item ) );
			});
		}
		else if( _.isObject( model ) ){
			res = {};
			for(var key in model){
				if( !key ) continue;
				res[key] = walk( model[ key ] );
			}
		}
		return res;
	}

	function createDate( ctrl, model, value, parseFn, formatFn ){
		var embeddedProp = m.prop( model );
		var prop = function(){
			if (arguments.length){
				if( parseFn ) embeddedProp( parseFn( arguments[0] ) );
				else if( _.isNumber( arguments[0] ) ){
					embeddedProp( arguments[0] );
				}
				else{
					var mDate = moment( arguments[0], ctrl.dateFormat || defaultFormat );
					if( mDate.isValid() )
						embeddedProp( mDate.valueOf() );
				}
			}
			var value = embeddedProp();
			return formatFn ? formatFn( value ) : (value > 0 ? moment( embeddedProp() ).format( ctrl.dateFormat || defaultFormat ) : '');
		};
		prop.purify = function() {
			return embeddedProp();
		};
		prop.toJSON = function() {
			return embeddedProp();
		};
		if( value )
			prop( value );
		return prop;
	}

	function createProp( model, value ){
		var prop = m.prop( model );
		if( value )
			prop( value );
		return prop;
	}

	function capitalizeFirstLetter(string) {
		return string.charAt(0).toUpperCase() + string.slice(1);
	}
	function mapToController( controller, root, object, model, value, arrayCreation ){
		if( !_.isObject( model ) )
			return createProp( model, value );

		for(var key in model){
			if( !key ) continue;

			var n = model[key];
			if( _.isString( n ) ){
				object[ key ] = createProp( n, value ? value[key] : null );
			}
			else if( _.isBoolean( n ) ){
				object[ key ] = createProp( n, value ? value[key] : null );
			}
			else if( _.isNumber( n ) ){
				object[ key ] = createProp( n, value ? value[key] : null );
			}
			else if( _.isFunction( n ) ){
				object[ key ] = n.bind( root );
			}
			else if( _.isArray( n ) ){
				object[ key ] = n.map(function( item ) {
					return mapToController( controller, root, {}, item, value, arrayCreation );
				});

				(function createHelpers( CTRL, CAPNAME, OBJ, ROOT, KEY, M, AC ){
					CTRL['fill' + CAPNAME ] = function( _as, keepContent ) {
						m.startComputation();
						if( !keepContent )
							OBJ[ KEY ].splice( 0, OBJ[ KEY ].length );
						_as.forEach( function( _v ){
							if( _v )
								OBJ[ KEY ].push( mapToController( CTRL, ROOT, {}, M[0], _v, AC ) );
						} );
						m.endComputation();
					};
					CTRL['addTo' + CAPNAME ] = function( _v, unique ) {
						m.startComputation();
						if( _v ){
							if( unique )
								CTRL['removeFrom' + CAPNAME ]( _v );
							OBJ[ KEY ].push( mapToController( CTRL, ROOT, {}, M[0], _v, AC ) );
						}
						m.endComputation();
					};
					CTRL['removeFrom' + CAPNAME ] = function( obj ) {
						m.startComputation();
						if( _.isNumber( obj ) )
							OBJ[ KEY ].splice( obj, 1);
						else{
							var index = -1;
							OBJ[ KEY ].forEach( function( elmnt, idx ){
								if( elmnt() === obj )
									index = idx;
							} );
							if( index > -1 )
								OBJ[ KEY ].splice( index, 1);
						}
						m.endComputation();
					};
					CTRL['hasIn' + CAPNAME ] = function( obj ) {
						var index = -1;
						OBJ[ KEY ].forEach( function( elmnt, idx ){
							if( elmnt() === obj )
								index = idx;
						} );
						return index > -1;
					};
					CTRL['clean' + CAPNAME ] = function( index ) {
						m.startComputation();
						OBJ[ KEY ].splice( 0, OBJ[ KEY ].length );
						m.endComputation();
					};
				})( controller, capitalizeFirstLetter( key ), object, root, key, n, arrayCreation );
			}
			else if( _.isObject( n ) && n._date ){
				object[ key ] = createDate( controller, n.value || new Date().getTime(), value ? value[key] : null, n._parse, n._format );
			}
			else if( _.isObject( n ) ){
				object[ key ] = mapToController( controller, root, {}, n, value ? value[key] : null, arrayCreation );
			}
		}
		return object;
	}

	module.exports = {
		_models: {},
		_viewModels: {},
		toJS: function( M ){
			var self = this;
			return walk( M );
		},
		resetModel: function(name, C, M){
			var self = this;
			function resetFn( origin, model ){
				if( (origin === undefined) || (model === undefined) ) return;
				if( _.isFunction( model ) ){
					model( origin._date ? (origin.value || Date.now()) : origin );
				}
				else if( _.isArray( model ) ){
					model.splice( 0, model.length );
				}
				else if( _.isObject( model ) ){
					for(var key in model){
						if( !key ) continue;
						var n = model[key];
						resetFn( origin[key], n );
					}
				}
			}
			resetFn( self._models[name], M );
		},
		updateModel: function(name, C, M, O){
			var self = this;
			function updateFn( origin, model, object ){
				if( (origin === undefined) || (object === undefined) || (model === undefined) ) return;
				if( _.isFunction( model ) ){
					model( object );
				}
				else if( _.isArray( model ) ){
					var originalItem = origin[0];
					model.splice( 0, model.length );
					object.forEach( function( item ){
						var viewObject = mapToController( C, M, {}, originalItem || item, null, false );
						model.push( viewObject );
						updateFn( originalItem, viewObject, item );
					} );
				}
				else if( _.isObject( model ) ){
					for(var key in model){
						if( !key ) continue;
						var n = model[key];
						updateFn( origin[key], n, object[key] );
					}
				}
			}
			updateFn( self._models[name], M, O );
		},
		mapObject: function(name, V){
			var self = this;
			return function( model ) {
				var ctrl = this;
				ctrl.toJS = function( subStructure ){
					return walk( subStructure || ctrl[ name ] );
				};
				Object.defineProperty(ctrl, '_validation', {
					enumerable: false,
					configurable: false,
					writable: true,
					value: V || { }
				} );
				var object = {};
				if( !self._models[ name ] ){
					self._models[ name ] = model;
					self._viewModels[ name ] = mapToController( ctrl, object, object, model, null, true );
				}
				ctrl[ name ] = self._viewModels[ name ];
			};
		}
	};


/***/ },
/* 55 */
/***/ function(module, exports) {

	var arrayTag = '[object Array]',
		boolTag = '[object Boolean]',
		dateTag = '[object Date]',
		errorTag = '[object Error]',
		funcTag = '[object Function]',
		numberTag = '[object Number]',
		objectTag = '[object Object]',
		regexpTag = '[object RegExp]',
		stringTag = '[object String]';

	var arrayProto = Array.prototype,
		objectProto = Object.prototype,
		stringProto = String.prototype;

	var objToString = objectProto.toString;
	var fnToString = Function.prototype.toString;
	var objCtorString = fnToString.call(Object);

	module.exports = {
		getPrototypeOf: Object.getPrototypeOf,
		isHostObject: function(value) {
			var result = false;
			if (value !== null && typeof value.toString != 'function') {
				try {
					result = !!(value + '');
				} catch (e) {}
			}
			return result;
		},
		isPlainObject: function(value) {
			if (!this.isObjectLike(value) || objToString.call(value) != objectTag || this.isHostObject(value)) {
				return false;
			}
			var proto = typeof value.constructor == 'function' ? this.getPrototypeOf(value) : objectProto;

			if (proto === null) {
				return true;
			}
			var Ctor = proto.constructor;
			return (typeof Ctor == 'function' && Ctor instanceof Ctor && fnToString.call(Ctor) == objCtorString);
		},
		isObjectLike: function(value) {
			return !!value && typeof value == 'object';
		},
		isArray: Array.isArray,
		isObject: function(value) {
			var type = typeof value;
			return !!value && (type == 'object' || type == 'function');
		},
		isError: function(value) {
			return this.isObjectLike(value) && typeof value.message == 'string' && objToString.call(value) == errorTag;
		},
		isNumber: function(value) {
			return typeof value == 'number' || (this.isObjectLike(value) && objToString.call(value) == numberTag);
		},
		isDate: function(value) {
			return this.isObjectLike(value) && objToString.call(value) == dateTag;
		},
		isFunction: function(value) {
			return this.isObject(value) && objToString.call(value) == funcTag;
		},
		isBoolean: function(value) {
			return value === true || value === false || (this.isObjectLike(value) && objToString.call(value) == boolTag);
		},
		isString: function(value) {
			return typeof value == 'string' || ( this.isObjectLike(value) && objToString.call(value) == stringTag);
		},
		isRegExp: function(value) {
			return this.isObject(value) && objToString.call(value) == regexpTag;
		}
	};


/***/ },
/* 56 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(module) {//! moment.js
	//! version : 2.10.6
	//! authors : Tim Wood, Iskren Chernev, Moment.js contributors
	//! license : MIT
	//! momentjs.com

	(function (global, factory) {
	     true ? module.exports = factory() :
	    typeof define === 'function' && define.amd ? define(factory) :
	    global.moment = factory()
	}(this, function () { 'use strict';

	    var hookCallback;

	    function utils_hooks__hooks () {
	        return hookCallback.apply(null, arguments);
	    }

	    // This is done to register the method called with moment()
	    // without creating circular dependencies.
	    function setHookCallback (callback) {
	        hookCallback = callback;
	    }

	    function isArray(input) {
	        return Object.prototype.toString.call(input) === '[object Array]';
	    }

	    function isDate(input) {
	        return input instanceof Date || Object.prototype.toString.call(input) === '[object Date]';
	    }

	    function map(arr, fn) {
	        var res = [], i;
	        for (i = 0; i < arr.length; ++i) {
	            res.push(fn(arr[i], i));
	        }
	        return res;
	    }

	    function hasOwnProp(a, b) {
	        return Object.prototype.hasOwnProperty.call(a, b);
	    }

	    function extend(a, b) {
	        for (var i in b) {
	            if (hasOwnProp(b, i)) {
	                a[i] = b[i];
	            }
	        }

	        if (hasOwnProp(b, 'toString')) {
	            a.toString = b.toString;
	        }

	        if (hasOwnProp(b, 'valueOf')) {
	            a.valueOf = b.valueOf;
	        }

	        return a;
	    }

	    function create_utc__createUTC (input, format, locale, strict) {
	        return createLocalOrUTC(input, format, locale, strict, true).utc();
	    }

	    function defaultParsingFlags() {
	        // We need to deep clone this object.
	        return {
	            empty           : false,
	            unusedTokens    : [],
	            unusedInput     : [],
	            overflow        : -2,
	            charsLeftOver   : 0,
	            nullInput       : false,
	            invalidMonth    : null,
	            invalidFormat   : false,
	            userInvalidated : false,
	            iso             : false
	        };
	    }

	    function getParsingFlags(m) {
	        if (m._pf == null) {
	            m._pf = defaultParsingFlags();
	        }
	        return m._pf;
	    }

	    function valid__isValid(m) {
	        if (m._isValid == null) {
	            var flags = getParsingFlags(m);
	            m._isValid = !isNaN(m._d.getTime()) &&
	                flags.overflow < 0 &&
	                !flags.empty &&
	                !flags.invalidMonth &&
	                !flags.invalidWeekday &&
	                !flags.nullInput &&
	                !flags.invalidFormat &&
	                !flags.userInvalidated;

	            if (m._strict) {
	                m._isValid = m._isValid &&
	                    flags.charsLeftOver === 0 &&
	                    flags.unusedTokens.length === 0 &&
	                    flags.bigHour === undefined;
	            }
	        }
	        return m._isValid;
	    }

	    function valid__createInvalid (flags) {
	        var m = create_utc__createUTC(NaN);
	        if (flags != null) {
	            extend(getParsingFlags(m), flags);
	        }
	        else {
	            getParsingFlags(m).userInvalidated = true;
	        }

	        return m;
	    }

	    var momentProperties = utils_hooks__hooks.momentProperties = [];

	    function copyConfig(to, from) {
	        var i, prop, val;

	        if (typeof from._isAMomentObject !== 'undefined') {
	            to._isAMomentObject = from._isAMomentObject;
	        }
	        if (typeof from._i !== 'undefined') {
	            to._i = from._i;
	        }
	        if (typeof from._f !== 'undefined') {
	            to._f = from._f;
	        }
	        if (typeof from._l !== 'undefined') {
	            to._l = from._l;
	        }
	        if (typeof from._strict !== 'undefined') {
	            to._strict = from._strict;
	        }
	        if (typeof from._tzm !== 'undefined') {
	            to._tzm = from._tzm;
	        }
	        if (typeof from._isUTC !== 'undefined') {
	            to._isUTC = from._isUTC;
	        }
	        if (typeof from._offset !== 'undefined') {
	            to._offset = from._offset;
	        }
	        if (typeof from._pf !== 'undefined') {
	            to._pf = getParsingFlags(from);
	        }
	        if (typeof from._locale !== 'undefined') {
	            to._locale = from._locale;
	        }

	        if (momentProperties.length > 0) {
	            for (i in momentProperties) {
	                prop = momentProperties[i];
	                val = from[prop];
	                if (typeof val !== 'undefined') {
	                    to[prop] = val;
	                }
	            }
	        }

	        return to;
	    }

	    var updateInProgress = false;

	    // Moment prototype object
	    function Moment(config) {
	        copyConfig(this, config);
	        this._d = new Date(config._d != null ? config._d.getTime() : NaN);
	        // Prevent infinite loop in case updateOffset creates new moment
	        // objects.
	        if (updateInProgress === false) {
	            updateInProgress = true;
	            utils_hooks__hooks.updateOffset(this);
	            updateInProgress = false;
	        }
	    }

	    function isMoment (obj) {
	        return obj instanceof Moment || (obj != null && obj._isAMomentObject != null);
	    }

	    function absFloor (number) {
	        if (number < 0) {
	            return Math.ceil(number);
	        } else {
	            return Math.floor(number);
	        }
	    }

	    function toInt(argumentForCoercion) {
	        var coercedNumber = +argumentForCoercion,
	            value = 0;

	        if (coercedNumber !== 0 && isFinite(coercedNumber)) {
	            value = absFloor(coercedNumber);
	        }

	        return value;
	    }

	    function compareArrays(array1, array2, dontConvert) {
	        var len = Math.min(array1.length, array2.length),
	            lengthDiff = Math.abs(array1.length - array2.length),
	            diffs = 0,
	            i;
	        for (i = 0; i < len; i++) {
	            if ((dontConvert && array1[i] !== array2[i]) ||
	                (!dontConvert && toInt(array1[i]) !== toInt(array2[i]))) {
	                diffs++;
	            }
	        }
	        return diffs + lengthDiff;
	    }

	    function Locale() {
	    }

	    var locales = {};
	    var globalLocale;

	    function normalizeLocale(key) {
	        return key ? key.toLowerCase().replace('_', '-') : key;
	    }

	    // pick the locale from the array
	    // try ['en-au', 'en-gb'] as 'en-au', 'en-gb', 'en', as in move through the list trying each
	    // substring from most specific to least, but move to the next array item if it's a more specific variant than the current root
	    function chooseLocale(names) {
	        var i = 0, j, next, locale, split;

	        while (i < names.length) {
	            split = normalizeLocale(names[i]).split('-');
	            j = split.length;
	            next = normalizeLocale(names[i + 1]);
	            next = next ? next.split('-') : null;
	            while (j > 0) {
	                locale = loadLocale(split.slice(0, j).join('-'));
	                if (locale) {
	                    return locale;
	                }
	                if (next && next.length >= j && compareArrays(split, next, true) >= j - 1) {
	                    //the next array item is better than a shallower substring of this one
	                    break;
	                }
	                j--;
	            }
	            i++;
	        }
	        return null;
	    }

	    function loadLocale(name) {
	        var oldLocale = null;
	        // TODO: Find a better way to register and load all the locales in Node
	        if (!locales[name] && typeof module !== 'undefined' &&
	                module && module.exports) {
	            try {
	                oldLocale = globalLocale._abbr;
	                __webpack_require__(57)("./" + name);
	                // because defineLocale currently also sets the global locale, we
	                // want to undo that for lazy loaded locales
	                locale_locales__getSetGlobalLocale(oldLocale);
	            } catch (e) { }
	        }
	        return locales[name];
	    }

	    // This function will load locale and then set the global locale.  If
	    // no arguments are passed in, it will simply return the current global
	    // locale key.
	    function locale_locales__getSetGlobalLocale (key, values) {
	        var data;
	        if (key) {
	            if (typeof values === 'undefined') {
	                data = locale_locales__getLocale(key);
	            }
	            else {
	                data = defineLocale(key, values);
	            }

	            if (data) {
	                // moment.duration._locale = moment._locale = data;
	                globalLocale = data;
	            }
	        }

	        return globalLocale._abbr;
	    }

	    function defineLocale (name, values) {
	        if (values !== null) {
	            values.abbr = name;
	            locales[name] = locales[name] || new Locale();
	            locales[name].set(values);

	            // backwards compat for now: also set the locale
	            locale_locales__getSetGlobalLocale(name);

	            return locales[name];
	        } else {
	            // useful for testing
	            delete locales[name];
	            return null;
	        }
	    }

	    // returns locale data
	    function locale_locales__getLocale (key) {
	        var locale;

	        if (key && key._locale && key._locale._abbr) {
	            key = key._locale._abbr;
	        }

	        if (!key) {
	            return globalLocale;
	        }

	        if (!isArray(key)) {
	            //short-circuit everything else
	            locale = loadLocale(key);
	            if (locale) {
	                return locale;
	            }
	            key = [key];
	        }

	        return chooseLocale(key);
	    }

	    var aliases = {};

	    function addUnitAlias (unit, shorthand) {
	        var lowerCase = unit.toLowerCase();
	        aliases[lowerCase] = aliases[lowerCase + 's'] = aliases[shorthand] = unit;
	    }

	    function normalizeUnits(units) {
	        return typeof units === 'string' ? aliases[units] || aliases[units.toLowerCase()] : undefined;
	    }

	    function normalizeObjectUnits(inputObject) {
	        var normalizedInput = {},
	            normalizedProp,
	            prop;

	        for (prop in inputObject) {
	            if (hasOwnProp(inputObject, prop)) {
	                normalizedProp = normalizeUnits(prop);
	                if (normalizedProp) {
	                    normalizedInput[normalizedProp] = inputObject[prop];
	                }
	            }
	        }

	        return normalizedInput;
	    }

	    function makeGetSet (unit, keepTime) {
	        return function (value) {
	            if (value != null) {
	                get_set__set(this, unit, value);
	                utils_hooks__hooks.updateOffset(this, keepTime);
	                return this;
	            } else {
	                return get_set__get(this, unit);
	            }
	        };
	    }

	    function get_set__get (mom, unit) {
	        return mom._d['get' + (mom._isUTC ? 'UTC' : '') + unit]();
	    }

	    function get_set__set (mom, unit, value) {
	        return mom._d['set' + (mom._isUTC ? 'UTC' : '') + unit](value);
	    }

	    // MOMENTS

	    function getSet (units, value) {
	        var unit;
	        if (typeof units === 'object') {
	            for (unit in units) {
	                this.set(unit, units[unit]);
	            }
	        } else {
	            units = normalizeUnits(units);
	            if (typeof this[units] === 'function') {
	                return this[units](value);
	            }
	        }
	        return this;
	    }

	    function zeroFill(number, targetLength, forceSign) {
	        var absNumber = '' + Math.abs(number),
	            zerosToFill = targetLength - absNumber.length,
	            sign = number >= 0;
	        return (sign ? (forceSign ? '+' : '') : '-') +
	            Math.pow(10, Math.max(0, zerosToFill)).toString().substr(1) + absNumber;
	    }

	    var formattingTokens = /(\[[^\[]*\])|(\\)?(Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|Q|YYYYYY|YYYYY|YYYY|YY|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|mm?|ss?|S{1,9}|x|X|zz?|ZZ?|.)/g;

	    var localFormattingTokens = /(\[[^\[]*\])|(\\)?(LTS|LT|LL?L?L?|l{1,4})/g;

	    var formatFunctions = {};

	    var formatTokenFunctions = {};

	    // token:    'M'
	    // padded:   ['MM', 2]
	    // ordinal:  'Mo'
	    // callback: function () { this.month() + 1 }
	    function addFormatToken (token, padded, ordinal, callback) {
	        var func = callback;
	        if (typeof callback === 'string') {
	            func = function () {
	                return this[callback]();
	            };
	        }
	        if (token) {
	            formatTokenFunctions[token] = func;
	        }
	        if (padded) {
	            formatTokenFunctions[padded[0]] = function () {
	                return zeroFill(func.apply(this, arguments), padded[1], padded[2]);
	            };
	        }
	        if (ordinal) {
	            formatTokenFunctions[ordinal] = function () {
	                return this.localeData().ordinal(func.apply(this, arguments), token);
	            };
	        }
	    }

	    function removeFormattingTokens(input) {
	        if (input.match(/\[[\s\S]/)) {
	            return input.replace(/^\[|\]$/g, '');
	        }
	        return input.replace(/\\/g, '');
	    }

	    function makeFormatFunction(format) {
	        var array = format.match(formattingTokens), i, length;

	        for (i = 0, length = array.length; i < length; i++) {
	            if (formatTokenFunctions[array[i]]) {
	                array[i] = formatTokenFunctions[array[i]];
	            } else {
	                array[i] = removeFormattingTokens(array[i]);
	            }
	        }

	        return function (mom) {
	            var output = '';
	            for (i = 0; i < length; i++) {
	                output += array[i] instanceof Function ? array[i].call(mom, format) : array[i];
	            }
	            return output;
	        };
	    }

	    // format date using native date object
	    function formatMoment(m, format) {
	        if (!m.isValid()) {
	            return m.localeData().invalidDate();
	        }

	        format = expandFormat(format, m.localeData());
	        formatFunctions[format] = formatFunctions[format] || makeFormatFunction(format);

	        return formatFunctions[format](m);
	    }

	    function expandFormat(format, locale) {
	        var i = 5;

	        function replaceLongDateFormatTokens(input) {
	            return locale.longDateFormat(input) || input;
	        }

	        localFormattingTokens.lastIndex = 0;
	        while (i >= 0 && localFormattingTokens.test(format)) {
	            format = format.replace(localFormattingTokens, replaceLongDateFormatTokens);
	            localFormattingTokens.lastIndex = 0;
	            i -= 1;
	        }

	        return format;
	    }

	    var match1         = /\d/;            //       0 - 9
	    var match2         = /\d\d/;          //      00 - 99
	    var match3         = /\d{3}/;         //     000 - 999
	    var match4         = /\d{4}/;         //    0000 - 9999
	    var match6         = /[+-]?\d{6}/;    // -999999 - 999999
	    var match1to2      = /\d\d?/;         //       0 - 99
	    var match1to3      = /\d{1,3}/;       //       0 - 999
	    var match1to4      = /\d{1,4}/;       //       0 - 9999
	    var match1to6      = /[+-]?\d{1,6}/;  // -999999 - 999999

	    var matchUnsigned  = /\d+/;           //       0 - inf
	    var matchSigned    = /[+-]?\d+/;      //    -inf - inf

	    var matchOffset    = /Z|[+-]\d\d:?\d\d/gi; // +00:00 -00:00 +0000 -0000 or Z

	    var matchTimestamp = /[+-]?\d+(\.\d{1,3})?/; // 123456789 123456789.123

	    // any word (or two) characters or numbers including two/three word month in arabic.
	    var matchWord = /[0-9]*['a-z\u00A0-\u05FF\u0700-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]+|[\u0600-\u06FF\/]+(\s*?[\u0600-\u06FF]+){1,2}/i;

	    var regexes = {};

	    function isFunction (sth) {
	        // https://github.com/moment/moment/issues/2325
	        return typeof sth === 'function' &&
	            Object.prototype.toString.call(sth) === '[object Function]';
	    }


	    function addRegexToken (token, regex, strictRegex) {
	        regexes[token] = isFunction(regex) ? regex : function (isStrict) {
	            return (isStrict && strictRegex) ? strictRegex : regex;
	        };
	    }

	    function getParseRegexForToken (token, config) {
	        if (!hasOwnProp(regexes, token)) {
	            return new RegExp(unescapeFormat(token));
	        }

	        return regexes[token](config._strict, config._locale);
	    }

	    // Code from http://stackoverflow.com/questions/3561493/is-there-a-regexp-escape-function-in-javascript
	    function unescapeFormat(s) {
	        return s.replace('\\', '').replace(/\\(\[)|\\(\])|\[([^\]\[]*)\]|\\(.)/g, function (matched, p1, p2, p3, p4) {
	            return p1 || p2 || p3 || p4;
	        }).replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&');
	    }

	    var tokens = {};

	    function addParseToken (token, callback) {
	        var i, func = callback;
	        if (typeof token === 'string') {
	            token = [token];
	        }
	        if (typeof callback === 'number') {
	            func = function (input, array) {
	                array[callback] = toInt(input);
	            };
	        }
	        for (i = 0; i < token.length; i++) {
	            tokens[token[i]] = func;
	        }
	    }

	    function addWeekParseToken (token, callback) {
	        addParseToken(token, function (input, array, config, token) {
	            config._w = config._w || {};
	            callback(input, config._w, config, token);
	        });
	    }

	    function addTimeToArrayFromToken(token, input, config) {
	        if (input != null && hasOwnProp(tokens, token)) {
	            tokens[token](input, config._a, config, token);
	        }
	    }

	    var YEAR = 0;
	    var MONTH = 1;
	    var DATE = 2;
	    var HOUR = 3;
	    var MINUTE = 4;
	    var SECOND = 5;
	    var MILLISECOND = 6;

	    function daysInMonth(year, month) {
	        return new Date(Date.UTC(year, month + 1, 0)).getUTCDate();
	    }

	    // FORMATTING

	    addFormatToken('M', ['MM', 2], 'Mo', function () {
	        return this.month() + 1;
	    });

	    addFormatToken('MMM', 0, 0, function (format) {
	        return this.localeData().monthsShort(this, format);
	    });

	    addFormatToken('MMMM', 0, 0, function (format) {
	        return this.localeData().months(this, format);
	    });

	    // ALIASES

	    addUnitAlias('month', 'M');

	    // PARSING

	    addRegexToken('M',    match1to2);
	    addRegexToken('MM',   match1to2, match2);
	    addRegexToken('MMM',  matchWord);
	    addRegexToken('MMMM', matchWord);

	    addParseToken(['M', 'MM'], function (input, array) {
	        array[MONTH] = toInt(input) - 1;
	    });

	    addParseToken(['MMM', 'MMMM'], function (input, array, config, token) {
	        var month = config._locale.monthsParse(input, token, config._strict);
	        // if we didn't find a month name, mark the date as invalid.
	        if (month != null) {
	            array[MONTH] = month;
	        } else {
	            getParsingFlags(config).invalidMonth = input;
	        }
	    });

	    // LOCALES

	    var defaultLocaleMonths = 'January_February_March_April_May_June_July_August_September_October_November_December'.split('_');
	    function localeMonths (m) {
	        return this._months[m.month()];
	    }

	    var defaultLocaleMonthsShort = 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_');
	    function localeMonthsShort (m) {
	        return this._monthsShort[m.month()];
	    }

	    function localeMonthsParse (monthName, format, strict) {
	        var i, mom, regex;

	        if (!this._monthsParse) {
	            this._monthsParse = [];
	            this._longMonthsParse = [];
	            this._shortMonthsParse = [];
	        }

	        for (i = 0; i < 12; i++) {
	            // make the regex if we don't have it already
	            mom = create_utc__createUTC([2000, i]);
	            if (strict && !this._longMonthsParse[i]) {
	                this._longMonthsParse[i] = new RegExp('^' + this.months(mom, '').replace('.', '') + '$', 'i');
	                this._shortMonthsParse[i] = new RegExp('^' + this.monthsShort(mom, '').replace('.', '') + '$', 'i');
	            }
	            if (!strict && !this._monthsParse[i]) {
	                regex = '^' + this.months(mom, '') + '|^' + this.monthsShort(mom, '');
	                this._monthsParse[i] = new RegExp(regex.replace('.', ''), 'i');
	            }
	            // test the regex
	            if (strict && format === 'MMMM' && this._longMonthsParse[i].test(monthName)) {
	                return i;
	            } else if (strict && format === 'MMM' && this._shortMonthsParse[i].test(monthName)) {
	                return i;
	            } else if (!strict && this._monthsParse[i].test(monthName)) {
	                return i;
	            }
	        }
	    }

	    // MOMENTS

	    function setMonth (mom, value) {
	        var dayOfMonth;

	        // TODO: Move this out of here!
	        if (typeof value === 'string') {
	            value = mom.localeData().monthsParse(value);
	            // TODO: Another silent failure?
	            if (typeof value !== 'number') {
	                return mom;
	            }
	        }

	        dayOfMonth = Math.min(mom.date(), daysInMonth(mom.year(), value));
	        mom._d['set' + (mom._isUTC ? 'UTC' : '') + 'Month'](value, dayOfMonth);
	        return mom;
	    }

	    function getSetMonth (value) {
	        if (value != null) {
	            setMonth(this, value);
	            utils_hooks__hooks.updateOffset(this, true);
	            return this;
	        } else {
	            return get_set__get(this, 'Month');
	        }
	    }

	    function getDaysInMonth () {
	        return daysInMonth(this.year(), this.month());
	    }

	    function checkOverflow (m) {
	        var overflow;
	        var a = m._a;

	        if (a && getParsingFlags(m).overflow === -2) {
	            overflow =
	                a[MONTH]       < 0 || a[MONTH]       > 11  ? MONTH :
	                a[DATE]        < 1 || a[DATE]        > daysInMonth(a[YEAR], a[MONTH]) ? DATE :
	                a[HOUR]        < 0 || a[HOUR]        > 24 || (a[HOUR] === 24 && (a[MINUTE] !== 0 || a[SECOND] !== 0 || a[MILLISECOND] !== 0)) ? HOUR :
	                a[MINUTE]      < 0 || a[MINUTE]      > 59  ? MINUTE :
	                a[SECOND]      < 0 || a[SECOND]      > 59  ? SECOND :
	                a[MILLISECOND] < 0 || a[MILLISECOND] > 999 ? MILLISECOND :
	                -1;

	            if (getParsingFlags(m)._overflowDayOfYear && (overflow < YEAR || overflow > DATE)) {
	                overflow = DATE;
	            }

	            getParsingFlags(m).overflow = overflow;
	        }

	        return m;
	    }

	    function warn(msg) {
	        if (utils_hooks__hooks.suppressDeprecationWarnings === false && typeof console !== 'undefined' && console.warn) {
	            console.warn('Deprecation warning: ' + msg);
	        }
	    }

	    function deprecate(msg, fn) {
	        var firstTime = true;

	        return extend(function () {
	            if (firstTime) {
	                warn(msg + '\n' + (new Error()).stack);
	                firstTime = false;
	            }
	            return fn.apply(this, arguments);
	        }, fn);
	    }

	    var deprecations = {};

	    function deprecateSimple(name, msg) {
	        if (!deprecations[name]) {
	            warn(msg);
	            deprecations[name] = true;
	        }
	    }

	    utils_hooks__hooks.suppressDeprecationWarnings = false;

	    var from_string__isoRegex = /^\s*(?:[+-]\d{6}|\d{4})-(?:(\d\d-\d\d)|(W\d\d$)|(W\d\d-\d)|(\d\d\d))((T| )(\d\d(:\d\d(:\d\d(\.\d+)?)?)?)?([\+\-]\d\d(?::?\d\d)?|\s*Z)?)?$/;

	    var isoDates = [
	        ['YYYYYY-MM-DD', /[+-]\d{6}-\d{2}-\d{2}/],
	        ['YYYY-MM-DD', /\d{4}-\d{2}-\d{2}/],
	        ['GGGG-[W]WW-E', /\d{4}-W\d{2}-\d/],
	        ['GGGG-[W]WW', /\d{4}-W\d{2}/],
	        ['YYYY-DDD', /\d{4}-\d{3}/]
	    ];

	    // iso time formats and regexes
	    var isoTimes = [
	        ['HH:mm:ss.SSSS', /(T| )\d\d:\d\d:\d\d\.\d+/],
	        ['HH:mm:ss', /(T| )\d\d:\d\d:\d\d/],
	        ['HH:mm', /(T| )\d\d:\d\d/],
	        ['HH', /(T| )\d\d/]
	    ];

	    var aspNetJsonRegex = /^\/?Date\((\-?\d+)/i;

	    // date from iso format
	    function configFromISO(config) {
	        var i, l,
	            string = config._i,
	            match = from_string__isoRegex.exec(string);

	        if (match) {
	            getParsingFlags(config).iso = true;
	            for (i = 0, l = isoDates.length; i < l; i++) {
	                if (isoDates[i][1].exec(string)) {
	                    config._f = isoDates[i][0];
	                    break;
	                }
	            }
	            for (i = 0, l = isoTimes.length; i < l; i++) {
	                if (isoTimes[i][1].exec(string)) {
	                    // match[6] should be 'T' or space
	                    config._f += (match[6] || ' ') + isoTimes[i][0];
	                    break;
	                }
	            }
	            if (string.match(matchOffset)) {
	                config._f += 'Z';
	            }
	            configFromStringAndFormat(config);
	        } else {
	            config._isValid = false;
	        }
	    }

	    // date from iso format or fallback
	    function configFromString(config) {
	        var matched = aspNetJsonRegex.exec(config._i);

	        if (matched !== null) {
	            config._d = new Date(+matched[1]);
	            return;
	        }

	        configFromISO(config);
	        if (config._isValid === false) {
	            delete config._isValid;
	            utils_hooks__hooks.createFromInputFallback(config);
	        }
	    }

	    utils_hooks__hooks.createFromInputFallback = deprecate(
	        'moment construction falls back to js Date. This is ' +
	        'discouraged and will be removed in upcoming major ' +
	        'release. Please refer to ' +
	        'https://github.com/moment/moment/issues/1407 for more info.',
	        function (config) {
	            config._d = new Date(config._i + (config._useUTC ? ' UTC' : ''));
	        }
	    );

	    function createDate (y, m, d, h, M, s, ms) {
	        //can't just apply() to create a date:
	        //http://stackoverflow.com/questions/181348/instantiating-a-javascript-object-by-calling-prototype-constructor-apply
	        var date = new Date(y, m, d, h, M, s, ms);

	        //the date constructor doesn't accept years < 1970
	        if (y < 1970) {
	            date.setFullYear(y);
	        }
	        return date;
	    }

	    function createUTCDate (y) {
	        var date = new Date(Date.UTC.apply(null, arguments));
	        if (y < 1970) {
	            date.setUTCFullYear(y);
	        }
	        return date;
	    }

	    addFormatToken(0, ['YY', 2], 0, function () {
	        return this.year() % 100;
	    });

	    addFormatToken(0, ['YYYY',   4],       0, 'year');
	    addFormatToken(0, ['YYYYY',  5],       0, 'year');
	    addFormatToken(0, ['YYYYYY', 6, true], 0, 'year');

	    // ALIASES

	    addUnitAlias('year', 'y');

	    // PARSING

	    addRegexToken('Y',      matchSigned);
	    addRegexToken('YY',     match1to2, match2);
	    addRegexToken('YYYY',   match1to4, match4);
	    addRegexToken('YYYYY',  match1to6, match6);
	    addRegexToken('YYYYYY', match1to6, match6);

	    addParseToken(['YYYYY', 'YYYYYY'], YEAR);
	    addParseToken('YYYY', function (input, array) {
	        array[YEAR] = input.length === 2 ? utils_hooks__hooks.parseTwoDigitYear(input) : toInt(input);
	    });
	    addParseToken('YY', function (input, array) {
	        array[YEAR] = utils_hooks__hooks.parseTwoDigitYear(input);
	    });

	    // HELPERS

	    function daysInYear(year) {
	        return isLeapYear(year) ? 366 : 365;
	    }

	    function isLeapYear(year) {
	        return (year % 4 === 0 && year % 100 !== 0) || year % 400 === 0;
	    }

	    // HOOKS

	    utils_hooks__hooks.parseTwoDigitYear = function (input) {
	        return toInt(input) + (toInt(input) > 68 ? 1900 : 2000);
	    };

	    // MOMENTS

	    var getSetYear = makeGetSet('FullYear', false);

	    function getIsLeapYear () {
	        return isLeapYear(this.year());
	    }

	    addFormatToken('w', ['ww', 2], 'wo', 'week');
	    addFormatToken('W', ['WW', 2], 'Wo', 'isoWeek');

	    // ALIASES

	    addUnitAlias('week', 'w');
	    addUnitAlias('isoWeek', 'W');

	    // PARSING

	    addRegexToken('w',  match1to2);
	    addRegexToken('ww', match1to2, match2);
	    addRegexToken('W',  match1to2);
	    addRegexToken('WW', match1to2, match2);

	    addWeekParseToken(['w', 'ww', 'W', 'WW'], function (input, week, config, token) {
	        week[token.substr(0, 1)] = toInt(input);
	    });

	    // HELPERS

	    // firstDayOfWeek       0 = sun, 6 = sat
	    //                      the day of the week that starts the week
	    //                      (usually sunday or monday)
	    // firstDayOfWeekOfYear 0 = sun, 6 = sat
	    //                      the first week is the week that contains the first
	    //                      of this day of the week
	    //                      (eg. ISO weeks use thursday (4))
	    function weekOfYear(mom, firstDayOfWeek, firstDayOfWeekOfYear) {
	        var end = firstDayOfWeekOfYear - firstDayOfWeek,
	            daysToDayOfWeek = firstDayOfWeekOfYear - mom.day(),
	            adjustedMoment;


	        if (daysToDayOfWeek > end) {
	            daysToDayOfWeek -= 7;
	        }

	        if (daysToDayOfWeek < end - 7) {
	            daysToDayOfWeek += 7;
	        }

	        adjustedMoment = local__createLocal(mom).add(daysToDayOfWeek, 'd');
	        return {
	            week: Math.ceil(adjustedMoment.dayOfYear() / 7),
	            year: adjustedMoment.year()
	        };
	    }

	    // LOCALES

	    function localeWeek (mom) {
	        return weekOfYear(mom, this._week.dow, this._week.doy).week;
	    }

	    var defaultLocaleWeek = {
	        dow : 0, // Sunday is the first day of the week.
	        doy : 6  // The week that contains Jan 1st is the first week of the year.
	    };

	    function localeFirstDayOfWeek () {
	        return this._week.dow;
	    }

	    function localeFirstDayOfYear () {
	        return this._week.doy;
	    }

	    // MOMENTS

	    function getSetWeek (input) {
	        var week = this.localeData().week(this);
	        return input == null ? week : this.add((input - week) * 7, 'd');
	    }

	    function getSetISOWeek (input) {
	        var week = weekOfYear(this, 1, 4).week;
	        return input == null ? week : this.add((input - week) * 7, 'd');
	    }

	    addFormatToken('DDD', ['DDDD', 3], 'DDDo', 'dayOfYear');

	    // ALIASES

	    addUnitAlias('dayOfYear', 'DDD');

	    // PARSING

	    addRegexToken('DDD',  match1to3);
	    addRegexToken('DDDD', match3);
	    addParseToken(['DDD', 'DDDD'], function (input, array, config) {
	        config._dayOfYear = toInt(input);
	    });

	    // HELPERS

	    //http://en.wikipedia.org/wiki/ISO_week_date#Calculating_a_date_given_the_year.2C_week_number_and_weekday
	    function dayOfYearFromWeeks(year, week, weekday, firstDayOfWeekOfYear, firstDayOfWeek) {
	        var week1Jan = 6 + firstDayOfWeek - firstDayOfWeekOfYear, janX = createUTCDate(year, 0, 1 + week1Jan), d = janX.getUTCDay(), dayOfYear;
	        if (d < firstDayOfWeek) {
	            d += 7;
	        }

	        weekday = weekday != null ? 1 * weekday : firstDayOfWeek;

	        dayOfYear = 1 + week1Jan + 7 * (week - 1) - d + weekday;

	        return {
	            year: dayOfYear > 0 ? year : year - 1,
	            dayOfYear: dayOfYear > 0 ?  dayOfYear : daysInYear(year - 1) + dayOfYear
	        };
	    }

	    // MOMENTS

	    function getSetDayOfYear (input) {
	        var dayOfYear = Math.round((this.clone().startOf('day') - this.clone().startOf('year')) / 864e5) + 1;
	        return input == null ? dayOfYear : this.add((input - dayOfYear), 'd');
	    }

	    // Pick the first defined of two or three arguments.
	    function defaults(a, b, c) {
	        if (a != null) {
	            return a;
	        }
	        if (b != null) {
	            return b;
	        }
	        return c;
	    }

	    function currentDateArray(config) {
	        var now = new Date();
	        if (config._useUTC) {
	            return [now.getUTCFullYear(), now.getUTCMonth(), now.getUTCDate()];
	        }
	        return [now.getFullYear(), now.getMonth(), now.getDate()];
	    }

	    // convert an array to a date.
	    // the array should mirror the parameters below
	    // note: all values past the year are optional and will default to the lowest possible value.
	    // [year, month, day , hour, minute, second, millisecond]
	    function configFromArray (config) {
	        var i, date, input = [], currentDate, yearToUse;

	        if (config._d) {
	            return;
	        }

	        currentDate = currentDateArray(config);

	        //compute day of the year from weeks and weekdays
	        if (config._w && config._a[DATE] == null && config._a[MONTH] == null) {
	            dayOfYearFromWeekInfo(config);
	        }

	        //if the day of the year is set, figure out what it is
	        if (config._dayOfYear) {
	            yearToUse = defaults(config._a[YEAR], currentDate[YEAR]);

	            if (config._dayOfYear > daysInYear(yearToUse)) {
	                getParsingFlags(config)._overflowDayOfYear = true;
	            }

	            date = createUTCDate(yearToUse, 0, config._dayOfYear);
	            config._a[MONTH] = date.getUTCMonth();
	            config._a[DATE] = date.getUTCDate();
	        }

	        // Default to current date.
	        // * if no year, month, day of month are given, default to today
	        // * if day of month is given, default month and year
	        // * if month is given, default only year
	        // * if year is given, don't default anything
	        for (i = 0; i < 3 && config._a[i] == null; ++i) {
	            config._a[i] = input[i] = currentDate[i];
	        }

	        // Zero out whatever was not defaulted, including time
	        for (; i < 7; i++) {
	            config._a[i] = input[i] = (config._a[i] == null) ? (i === 2 ? 1 : 0) : config._a[i];
	        }

	        // Check for 24:00:00.000
	        if (config._a[HOUR] === 24 &&
	                config._a[MINUTE] === 0 &&
	                config._a[SECOND] === 0 &&
	                config._a[MILLISECOND] === 0) {
	            config._nextDay = true;
	            config._a[HOUR] = 0;
	        }

	        config._d = (config._useUTC ? createUTCDate : createDate).apply(null, input);
	        // Apply timezone offset from input. The actual utcOffset can be changed
	        // with parseZone.
	        if (config._tzm != null) {
	            config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);
	        }

	        if (config._nextDay) {
	            config._a[HOUR] = 24;
	        }
	    }

	    function dayOfYearFromWeekInfo(config) {
	        var w, weekYear, week, weekday, dow, doy, temp;

	        w = config._w;
	        if (w.GG != null || w.W != null || w.E != null) {
	            dow = 1;
	            doy = 4;

	            // TODO: We need to take the current isoWeekYear, but that depends on
	            // how we interpret now (local, utc, fixed offset). So create
	            // a now version of current config (take local/utc/offset flags, and
	            // create now).
	            weekYear = defaults(w.GG, config._a[YEAR], weekOfYear(local__createLocal(), 1, 4).year);
	            week = defaults(w.W, 1);
	            weekday = defaults(w.E, 1);
	        } else {
	            dow = config._locale._week.dow;
	            doy = config._locale._week.doy;

	            weekYear = defaults(w.gg, config._a[YEAR], weekOfYear(local__createLocal(), dow, doy).year);
	            week = defaults(w.w, 1);

	            if (w.d != null) {
	                // weekday -- low day numbers are considered next week
	                weekday = w.d;
	                if (weekday < dow) {
	                    ++week;
	                }
	            } else if (w.e != null) {
	                // local weekday -- counting starts from begining of week
	                weekday = w.e + dow;
	            } else {
	                // default to begining of week
	                weekday = dow;
	            }
	        }
	        temp = dayOfYearFromWeeks(weekYear, week, weekday, doy, dow);

	        config._a[YEAR] = temp.year;
	        config._dayOfYear = temp.dayOfYear;
	    }

	    utils_hooks__hooks.ISO_8601 = function () {};

	    // date from string and format string
	    function configFromStringAndFormat(config) {
	        // TODO: Move this to another part of the creation flow to prevent circular deps
	        if (config._f === utils_hooks__hooks.ISO_8601) {
	            configFromISO(config);
	            return;
	        }

	        config._a = [];
	        getParsingFlags(config).empty = true;

	        // This array is used to make a Date, either with `new Date` or `Date.UTC`
	        var string = '' + config._i,
	            i, parsedInput, tokens, token, skipped,
	            stringLength = string.length,
	            totalParsedInputLength = 0;

	        tokens = expandFormat(config._f, config._locale).match(formattingTokens) || [];

	        for (i = 0; i < tokens.length; i++) {
	            token = tokens[i];
	            parsedInput = (string.match(getParseRegexForToken(token, config)) || [])[0];
	            if (parsedInput) {
	                skipped = string.substr(0, string.indexOf(parsedInput));
	                if (skipped.length > 0) {
	                    getParsingFlags(config).unusedInput.push(skipped);
	                }
	                string = string.slice(string.indexOf(parsedInput) + parsedInput.length);
	                totalParsedInputLength += parsedInput.length;
	            }
	            // don't parse if it's not a known token
	            if (formatTokenFunctions[token]) {
	                if (parsedInput) {
	                    getParsingFlags(config).empty = false;
	                }
	                else {
	                    getParsingFlags(config).unusedTokens.push(token);
	                }
	                addTimeToArrayFromToken(token, parsedInput, config);
	            }
	            else if (config._strict && !parsedInput) {
	                getParsingFlags(config).unusedTokens.push(token);
	            }
	        }

	        // add remaining unparsed input length to the string
	        getParsingFlags(config).charsLeftOver = stringLength - totalParsedInputLength;
	        if (string.length > 0) {
	            getParsingFlags(config).unusedInput.push(string);
	        }

	        // clear _12h flag if hour is <= 12
	        if (getParsingFlags(config).bigHour === true &&
	                config._a[HOUR] <= 12 &&
	                config._a[HOUR] > 0) {
	            getParsingFlags(config).bigHour = undefined;
	        }
	        // handle meridiem
	        config._a[HOUR] = meridiemFixWrap(config._locale, config._a[HOUR], config._meridiem);

	        configFromArray(config);
	        checkOverflow(config);
	    }


	    function meridiemFixWrap (locale, hour, meridiem) {
	        var isPm;

	        if (meridiem == null) {
	            // nothing to do
	            return hour;
	        }
	        if (locale.meridiemHour != null) {
	            return locale.meridiemHour(hour, meridiem);
	        } else if (locale.isPM != null) {
	            // Fallback
	            isPm = locale.isPM(meridiem);
	            if (isPm && hour < 12) {
	                hour += 12;
	            }
	            if (!isPm && hour === 12) {
	                hour = 0;
	            }
	            return hour;
	        } else {
	            // this is not supposed to happen
	            return hour;
	        }
	    }

	    function configFromStringAndArray(config) {
	        var tempConfig,
	            bestMoment,

	            scoreToBeat,
	            i,
	            currentScore;

	        if (config._f.length === 0) {
	            getParsingFlags(config).invalidFormat = true;
	            config._d = new Date(NaN);
	            return;
	        }

	        for (i = 0; i < config._f.length; i++) {
	            currentScore = 0;
	            tempConfig = copyConfig({}, config);
	            if (config._useUTC != null) {
	                tempConfig._useUTC = config._useUTC;
	            }
	            tempConfig._f = config._f[i];
	            configFromStringAndFormat(tempConfig);

	            if (!valid__isValid(tempConfig)) {
	                continue;
	            }

	            // if there is any input that was not parsed add a penalty for that format
	            currentScore += getParsingFlags(tempConfig).charsLeftOver;

	            //or tokens
	            currentScore += getParsingFlags(tempConfig).unusedTokens.length * 10;

	            getParsingFlags(tempConfig).score = currentScore;

	            if (scoreToBeat == null || currentScore < scoreToBeat) {
	                scoreToBeat = currentScore;
	                bestMoment = tempConfig;
	            }
	        }

	        extend(config, bestMoment || tempConfig);
	    }

	    function configFromObject(config) {
	        if (config._d) {
	            return;
	        }

	        var i = normalizeObjectUnits(config._i);
	        config._a = [i.year, i.month, i.day || i.date, i.hour, i.minute, i.second, i.millisecond];

	        configFromArray(config);
	    }

	    function createFromConfig (config) {
	        var res = new Moment(checkOverflow(prepareConfig(config)));
	        if (res._nextDay) {
	            // Adding is smart enough around DST
	            res.add(1, 'd');
	            res._nextDay = undefined;
	        }

	        return res;
	    }

	    function prepareConfig (config) {
	        var input = config._i,
	            format = config._f;

	        config._locale = config._locale || locale_locales__getLocale(config._l);

	        if (input === null || (format === undefined && input === '')) {
	            return valid__createInvalid({nullInput: true});
	        }

	        if (typeof input === 'string') {
	            config._i = input = config._locale.preparse(input);
	        }

	        if (isMoment(input)) {
	            return new Moment(checkOverflow(input));
	        } else if (isArray(format)) {
	            configFromStringAndArray(config);
	        } else if (format) {
	            configFromStringAndFormat(config);
	        } else if (isDate(input)) {
	            config._d = input;
	        } else {
	            configFromInput(config);
	        }

	        return config;
	    }

	    function configFromInput(config) {
	        var input = config._i;
	        if (input === undefined) {
	            config._d = new Date();
	        } else if (isDate(input)) {
	            config._d = new Date(+input);
	        } else if (typeof input === 'string') {
	            configFromString(config);
	        } else if (isArray(input)) {
	            config._a = map(input.slice(0), function (obj) {
	                return parseInt(obj, 10);
	            });
	            configFromArray(config);
	        } else if (typeof(input) === 'object') {
	            configFromObject(config);
	        } else if (typeof(input) === 'number') {
	            // from milliseconds
	            config._d = new Date(input);
	        } else {
	            utils_hooks__hooks.createFromInputFallback(config);
	        }
	    }

	    function createLocalOrUTC (input, format, locale, strict, isUTC) {
	        var c = {};

	        if (typeof(locale) === 'boolean') {
	            strict = locale;
	            locale = undefined;
	        }
	        // object construction must be done this way.
	        // https://github.com/moment/moment/issues/1423
	        c._isAMomentObject = true;
	        c._useUTC = c._isUTC = isUTC;
	        c._l = locale;
	        c._i = input;
	        c._f = format;
	        c._strict = strict;

	        return createFromConfig(c);
	    }

	    function local__createLocal (input, format, locale, strict) {
	        return createLocalOrUTC(input, format, locale, strict, false);
	    }

	    var prototypeMin = deprecate(
	         'moment().min is deprecated, use moment.min instead. https://github.com/moment/moment/issues/1548',
	         function () {
	             var other = local__createLocal.apply(null, arguments);
	             return other < this ? this : other;
	         }
	     );

	    var prototypeMax = deprecate(
	        'moment().max is deprecated, use moment.max instead. https://github.com/moment/moment/issues/1548',
	        function () {
	            var other = local__createLocal.apply(null, arguments);
	            return other > this ? this : other;
	        }
	    );

	    // Pick a moment m from moments so that m[fn](other) is true for all
	    // other. This relies on the function fn to be transitive.
	    //
	    // moments should either be an array of moment objects or an array, whose
	    // first element is an array of moment objects.
	    function pickBy(fn, moments) {
	        var res, i;
	        if (moments.length === 1 && isArray(moments[0])) {
	            moments = moments[0];
	        }
	        if (!moments.length) {
	            return local__createLocal();
	        }
	        res = moments[0];
	        for (i = 1; i < moments.length; ++i) {
	            if (!moments[i].isValid() || moments[i][fn](res)) {
	                res = moments[i];
	            }
	        }
	        return res;
	    }

	    // TODO: Use [].sort instead?
	    function min () {
	        var args = [].slice.call(arguments, 0);

	        return pickBy('isBefore', args);
	    }

	    function max () {
	        var args = [].slice.call(arguments, 0);

	        return pickBy('isAfter', args);
	    }

	    function Duration (duration) {
	        var normalizedInput = normalizeObjectUnits(duration),
	            years = normalizedInput.year || 0,
	            quarters = normalizedInput.quarter || 0,
	            months = normalizedInput.month || 0,
	            weeks = normalizedInput.week || 0,
	            days = normalizedInput.day || 0,
	            hours = normalizedInput.hour || 0,
	            minutes = normalizedInput.minute || 0,
	            seconds = normalizedInput.second || 0,
	            milliseconds = normalizedInput.millisecond || 0;

	        // representation for dateAddRemove
	        this._milliseconds = +milliseconds +
	            seconds * 1e3 + // 1000
	            minutes * 6e4 + // 1000 * 60
	            hours * 36e5; // 1000 * 60 * 60
	        // Because of dateAddRemove treats 24 hours as different from a
	        // day when working around DST, we need to store them separately
	        this._days = +days +
	            weeks * 7;
	        // It is impossible translate months into days without knowing
	        // which months you are are talking about, so we have to store
	        // it separately.
	        this._months = +months +
	            quarters * 3 +
	            years * 12;

	        this._data = {};

	        this._locale = locale_locales__getLocale();

	        this._bubble();
	    }

	    function isDuration (obj) {
	        return obj instanceof Duration;
	    }

	    function offset (token, separator) {
	        addFormatToken(token, 0, 0, function () {
	            var offset = this.utcOffset();
	            var sign = '+';
	            if (offset < 0) {
	                offset = -offset;
	                sign = '-';
	            }
	            return sign + zeroFill(~~(offset / 60), 2) + separator + zeroFill(~~(offset) % 60, 2);
	        });
	    }

	    offset('Z', ':');
	    offset('ZZ', '');

	    // PARSING

	    addRegexToken('Z',  matchOffset);
	    addRegexToken('ZZ', matchOffset);
	    addParseToken(['Z', 'ZZ'], function (input, array, config) {
	        config._useUTC = true;
	        config._tzm = offsetFromString(input);
	    });

	    // HELPERS

	    // timezone chunker
	    // '+10:00' > ['10',  '00']
	    // '-1530'  > ['-15', '30']
	    var chunkOffset = /([\+\-]|\d\d)/gi;

	    function offsetFromString(string) {
	        var matches = ((string || '').match(matchOffset) || []);
	        var chunk   = matches[matches.length - 1] || [];
	        var parts   = (chunk + '').match(chunkOffset) || ['-', 0, 0];
	        var minutes = +(parts[1] * 60) + toInt(parts[2]);

	        return parts[0] === '+' ? minutes : -minutes;
	    }

	    // Return a moment from input, that is local/utc/zone equivalent to model.
	    function cloneWithOffset(input, model) {
	        var res, diff;
	        if (model._isUTC) {
	            res = model.clone();
	            diff = (isMoment(input) || isDate(input) ? +input : +local__createLocal(input)) - (+res);
	            // Use low-level api, because this fn is low-level api.
	            res._d.setTime(+res._d + diff);
	            utils_hooks__hooks.updateOffset(res, false);
	            return res;
	        } else {
	            return local__createLocal(input).local();
	        }
	    }

	    function getDateOffset (m) {
	        // On Firefox.24 Date#getTimezoneOffset returns a floating point.
	        // https://github.com/moment/moment/pull/1871
	        return -Math.round(m._d.getTimezoneOffset() / 15) * 15;
	    }

	    // HOOKS

	    // This function will be called whenever a moment is mutated.
	    // It is intended to keep the offset in sync with the timezone.
	    utils_hooks__hooks.updateOffset = function () {};

	    // MOMENTS

	    // keepLocalTime = true means only change the timezone, without
	    // affecting the local hour. So 5:31:26 +0300 --[utcOffset(2, true)]-->
	    // 5:31:26 +0200 It is possible that 5:31:26 doesn't exist with offset
	    // +0200, so we adjust the time as needed, to be valid.
	    //
	    // Keeping the time actually adds/subtracts (one hour)
	    // from the actual represented time. That is why we call updateOffset
	    // a second time. In case it wants us to change the offset again
	    // _changeInProgress == true case, then we have to adjust, because
	    // there is no such time in the given timezone.
	    function getSetOffset (input, keepLocalTime) {
	        var offset = this._offset || 0,
	            localAdjust;
	        if (input != null) {
	            if (typeof input === 'string') {
	                input = offsetFromString(input);
	            }
	            if (Math.abs(input) < 16) {
	                input = input * 60;
	            }
	            if (!this._isUTC && keepLocalTime) {
	                localAdjust = getDateOffset(this);
	            }
	            this._offset = input;
	            this._isUTC = true;
	            if (localAdjust != null) {
	                this.add(localAdjust, 'm');
	            }
	            if (offset !== input) {
	                if (!keepLocalTime || this._changeInProgress) {
	                    add_subtract__addSubtract(this, create__createDuration(input - offset, 'm'), 1, false);
	                } else if (!this._changeInProgress) {
	                    this._changeInProgress = true;
	                    utils_hooks__hooks.updateOffset(this, true);
	                    this._changeInProgress = null;
	                }
	            }
	            return this;
	        } else {
	            return this._isUTC ? offset : getDateOffset(this);
	        }
	    }

	    function getSetZone (input, keepLocalTime) {
	        if (input != null) {
	            if (typeof input !== 'string') {
	                input = -input;
	            }

	            this.utcOffset(input, keepLocalTime);

	            return this;
	        } else {
	            return -this.utcOffset();
	        }
	    }

	    function setOffsetToUTC (keepLocalTime) {
	        return this.utcOffset(0, keepLocalTime);
	    }

	    function setOffsetToLocal (keepLocalTime) {
	        if (this._isUTC) {
	            this.utcOffset(0, keepLocalTime);
	            this._isUTC = false;

	            if (keepLocalTime) {
	                this.subtract(getDateOffset(this), 'm');
	            }
	        }
	        return this;
	    }

	    function setOffsetToParsedOffset () {
	        if (this._tzm) {
	            this.utcOffset(this._tzm);
	        } else if (typeof this._i === 'string') {
	            this.utcOffset(offsetFromString(this._i));
	        }
	        return this;
	    }

	    function hasAlignedHourOffset (input) {
	        input = input ? local__createLocal(input).utcOffset() : 0;

	        return (this.utcOffset() - input) % 60 === 0;
	    }

	    function isDaylightSavingTime () {
	        return (
	            this.utcOffset() > this.clone().month(0).utcOffset() ||
	            this.utcOffset() > this.clone().month(5).utcOffset()
	        );
	    }

	    function isDaylightSavingTimeShifted () {
	        if (typeof this._isDSTShifted !== 'undefined') {
	            return this._isDSTShifted;
	        }

	        var c = {};

	        copyConfig(c, this);
	        c = prepareConfig(c);

	        if (c._a) {
	            var other = c._isUTC ? create_utc__createUTC(c._a) : local__createLocal(c._a);
	            this._isDSTShifted = this.isValid() &&
	                compareArrays(c._a, other.toArray()) > 0;
	        } else {
	            this._isDSTShifted = false;
	        }

	        return this._isDSTShifted;
	    }

	    function isLocal () {
	        return !this._isUTC;
	    }

	    function isUtcOffset () {
	        return this._isUTC;
	    }

	    function isUtc () {
	        return this._isUTC && this._offset === 0;
	    }

	    var aspNetRegex = /(\-)?(?:(\d*)\.)?(\d+)\:(\d+)(?:\:(\d+)\.?(\d{3})?)?/;

	    // from http://docs.closure-library.googlecode.com/git/closure_goog_date_date.js.source.html
	    // somewhat more in line with 4.4.3.2 2004 spec, but allows decimal anywhere
	    var create__isoRegex = /^(-)?P(?:(?:([0-9,.]*)Y)?(?:([0-9,.]*)M)?(?:([0-9,.]*)D)?(?:T(?:([0-9,.]*)H)?(?:([0-9,.]*)M)?(?:([0-9,.]*)S)?)?|([0-9,.]*)W)$/;

	    function create__createDuration (input, key) {
	        var duration = input,
	            // matching against regexp is expensive, do it on demand
	            match = null,
	            sign,
	            ret,
	            diffRes;

	        if (isDuration(input)) {
	            duration = {
	                ms : input._milliseconds,
	                d  : input._days,
	                M  : input._months
	            };
	        } else if (typeof input === 'number') {
	            duration = {};
	            if (key) {
	                duration[key] = input;
	            } else {
	                duration.milliseconds = input;
	            }
	        } else if (!!(match = aspNetRegex.exec(input))) {
	            sign = (match[1] === '-') ? -1 : 1;
	            duration = {
	                y  : 0,
	                d  : toInt(match[DATE])        * sign,
	                h  : toInt(match[HOUR])        * sign,
	                m  : toInt(match[MINUTE])      * sign,
	                s  : toInt(match[SECOND])      * sign,
	                ms : toInt(match[MILLISECOND]) * sign
	            };
	        } else if (!!(match = create__isoRegex.exec(input))) {
	            sign = (match[1] === '-') ? -1 : 1;
	            duration = {
	                y : parseIso(match[2], sign),
	                M : parseIso(match[3], sign),
	                d : parseIso(match[4], sign),
	                h : parseIso(match[5], sign),
	                m : parseIso(match[6], sign),
	                s : parseIso(match[7], sign),
	                w : parseIso(match[8], sign)
	            };
	        } else if (duration == null) {// checks for null or undefined
	            duration = {};
	        } else if (typeof duration === 'object' && ('from' in duration || 'to' in duration)) {
	            diffRes = momentsDifference(local__createLocal(duration.from), local__createLocal(duration.to));

	            duration = {};
	            duration.ms = diffRes.milliseconds;
	            duration.M = diffRes.months;
	        }

	        ret = new Duration(duration);

	        if (isDuration(input) && hasOwnProp(input, '_locale')) {
	            ret._locale = input._locale;
	        }

	        return ret;
	    }

	    create__createDuration.fn = Duration.prototype;

	    function parseIso (inp, sign) {
	        // We'd normally use ~~inp for this, but unfortunately it also
	        // converts floats to ints.
	        // inp may be undefined, so careful calling replace on it.
	        var res = inp && parseFloat(inp.replace(',', '.'));
	        // apply sign while we're at it
	        return (isNaN(res) ? 0 : res) * sign;
	    }

	    function positiveMomentsDifference(base, other) {
	        var res = {milliseconds: 0, months: 0};

	        res.months = other.month() - base.month() +
	            (other.year() - base.year()) * 12;
	        if (base.clone().add(res.months, 'M').isAfter(other)) {
	            --res.months;
	        }

	        res.milliseconds = +other - +(base.clone().add(res.months, 'M'));

	        return res;
	    }

	    function momentsDifference(base, other) {
	        var res;
	        other = cloneWithOffset(other, base);
	        if (base.isBefore(other)) {
	            res = positiveMomentsDifference(base, other);
	        } else {
	            res = positiveMomentsDifference(other, base);
	            res.milliseconds = -res.milliseconds;
	            res.months = -res.months;
	        }

	        return res;
	    }

	    function createAdder(direction, name) {
	        return function (val, period) {
	            var dur, tmp;
	            //invert the arguments, but complain about it
	            if (period !== null && !isNaN(+period)) {
	                deprecateSimple(name, 'moment().' + name  + '(period, number) is deprecated. Please use moment().' + name + '(number, period).');
	                tmp = val; val = period; period = tmp;
	            }

	            val = typeof val === 'string' ? +val : val;
	            dur = create__createDuration(val, period);
	            add_subtract__addSubtract(this, dur, direction);
	            return this;
	        };
	    }

	    function add_subtract__addSubtract (mom, duration, isAdding, updateOffset) {
	        var milliseconds = duration._milliseconds,
	            days = duration._days,
	            months = duration._months;
	        updateOffset = updateOffset == null ? true : updateOffset;

	        if (milliseconds) {
	            mom._d.setTime(+mom._d + milliseconds * isAdding);
	        }
	        if (days) {
	            get_set__set(mom, 'Date', get_set__get(mom, 'Date') + days * isAdding);
	        }
	        if (months) {
	            setMonth(mom, get_set__get(mom, 'Month') + months * isAdding);
	        }
	        if (updateOffset) {
	            utils_hooks__hooks.updateOffset(mom, days || months);
	        }
	    }

	    var add_subtract__add      = createAdder(1, 'add');
	    var add_subtract__subtract = createAdder(-1, 'subtract');

	    function moment_calendar__calendar (time, formats) {
	        // We want to compare the start of today, vs this.
	        // Getting start-of-today depends on whether we're local/utc/offset or not.
	        var now = time || local__createLocal(),
	            sod = cloneWithOffset(now, this).startOf('day'),
	            diff = this.diff(sod, 'days', true),
	            format = diff < -6 ? 'sameElse' :
	                diff < -1 ? 'lastWeek' :
	                diff < 0 ? 'lastDay' :
	                diff < 1 ? 'sameDay' :
	                diff < 2 ? 'nextDay' :
	                diff < 7 ? 'nextWeek' : 'sameElse';
	        return this.format(formats && formats[format] || this.localeData().calendar(format, this, local__createLocal(now)));
	    }

	    function clone () {
	        return new Moment(this);
	    }

	    function isAfter (input, units) {
	        var inputMs;
	        units = normalizeUnits(typeof units !== 'undefined' ? units : 'millisecond');
	        if (units === 'millisecond') {
	            input = isMoment(input) ? input : local__createLocal(input);
	            return +this > +input;
	        } else {
	            inputMs = isMoment(input) ? +input : +local__createLocal(input);
	            return inputMs < +this.clone().startOf(units);
	        }
	    }

	    function isBefore (input, units) {
	        var inputMs;
	        units = normalizeUnits(typeof units !== 'undefined' ? units : 'millisecond');
	        if (units === 'millisecond') {
	            input = isMoment(input) ? input : local__createLocal(input);
	            return +this < +input;
	        } else {
	            inputMs = isMoment(input) ? +input : +local__createLocal(input);
	            return +this.clone().endOf(units) < inputMs;
	        }
	    }

	    function isBetween (from, to, units) {
	        return this.isAfter(from, units) && this.isBefore(to, units);
	    }

	    function isSame (input, units) {
	        var inputMs;
	        units = normalizeUnits(units || 'millisecond');
	        if (units === 'millisecond') {
	            input = isMoment(input) ? input : local__createLocal(input);
	            return +this === +input;
	        } else {
	            inputMs = +local__createLocal(input);
	            return +(this.clone().startOf(units)) <= inputMs && inputMs <= +(this.clone().endOf(units));
	        }
	    }

	    function diff (input, units, asFloat) {
	        var that = cloneWithOffset(input, this),
	            zoneDelta = (that.utcOffset() - this.utcOffset()) * 6e4,
	            delta, output;

	        units = normalizeUnits(units);

	        if (units === 'year' || units === 'month' || units === 'quarter') {
	            output = monthDiff(this, that);
	            if (units === 'quarter') {
	                output = output / 3;
	            } else if (units === 'year') {
	                output = output / 12;
	            }
	        } else {
	            delta = this - that;
	            output = units === 'second' ? delta / 1e3 : // 1000
	                units === 'minute' ? delta / 6e4 : // 1000 * 60
	                units === 'hour' ? delta / 36e5 : // 1000 * 60 * 60
	                units === 'day' ? (delta - zoneDelta) / 864e5 : // 1000 * 60 * 60 * 24, negate dst
	                units === 'week' ? (delta - zoneDelta) / 6048e5 : // 1000 * 60 * 60 * 24 * 7, negate dst
	                delta;
	        }
	        return asFloat ? output : absFloor(output);
	    }

	    function monthDiff (a, b) {
	        // difference in months
	        var wholeMonthDiff = ((b.year() - a.year()) * 12) + (b.month() - a.month()),
	            // b is in (anchor - 1 month, anchor + 1 month)
	            anchor = a.clone().add(wholeMonthDiff, 'months'),
	            anchor2, adjust;

	        if (b - anchor < 0) {
	            anchor2 = a.clone().add(wholeMonthDiff - 1, 'months');
	            // linear across the month
	            adjust = (b - anchor) / (anchor - anchor2);
	        } else {
	            anchor2 = a.clone().add(wholeMonthDiff + 1, 'months');
	            // linear across the month
	            adjust = (b - anchor) / (anchor2 - anchor);
	        }

	        return -(wholeMonthDiff + adjust);
	    }

	    utils_hooks__hooks.defaultFormat = 'YYYY-MM-DDTHH:mm:ssZ';

	    function toString () {
	        return this.clone().locale('en').format('ddd MMM DD YYYY HH:mm:ss [GMT]ZZ');
	    }

	    function moment_format__toISOString () {
	        var m = this.clone().utc();
	        if (0 < m.year() && m.year() <= 9999) {
	            if ('function' === typeof Date.prototype.toISOString) {
	                // native implementation is ~50x faster, use it when we can
	                return this.toDate().toISOString();
	            } else {
	                return formatMoment(m, 'YYYY-MM-DD[T]HH:mm:ss.SSS[Z]');
	            }
	        } else {
	            return formatMoment(m, 'YYYYYY-MM-DD[T]HH:mm:ss.SSS[Z]');
	        }
	    }

	    function format (inputString) {
	        var output = formatMoment(this, inputString || utils_hooks__hooks.defaultFormat);
	        return this.localeData().postformat(output);
	    }

	    function from (time, withoutSuffix) {
	        if (!this.isValid()) {
	            return this.localeData().invalidDate();
	        }
	        return create__createDuration({to: this, from: time}).locale(this.locale()).humanize(!withoutSuffix);
	    }

	    function fromNow (withoutSuffix) {
	        return this.from(local__createLocal(), withoutSuffix);
	    }

	    function to (time, withoutSuffix) {
	        if (!this.isValid()) {
	            return this.localeData().invalidDate();
	        }
	        return create__createDuration({from: this, to: time}).locale(this.locale()).humanize(!withoutSuffix);
	    }

	    function toNow (withoutSuffix) {
	        return this.to(local__createLocal(), withoutSuffix);
	    }

	    function locale (key) {
	        var newLocaleData;

	        if (key === undefined) {
	            return this._locale._abbr;
	        } else {
	            newLocaleData = locale_locales__getLocale(key);
	            if (newLocaleData != null) {
	                this._locale = newLocaleData;
	            }
	            return this;
	        }
	    }

	    var lang = deprecate(
	        'moment().lang() is deprecated. Instead, use moment().localeData() to get the language configuration. Use moment().locale() to change languages.',
	        function (key) {
	            if (key === undefined) {
	                return this.localeData();
	            } else {
	                return this.locale(key);
	            }
	        }
	    );

	    function localeData () {
	        return this._locale;
	    }

	    function startOf (units) {
	        units = normalizeUnits(units);
	        // the following switch intentionally omits break keywords
	        // to utilize falling through the cases.
	        switch (units) {
	        case 'year':
	            this.month(0);
	            /* falls through */
	        case 'quarter':
	        case 'month':
	            this.date(1);
	            /* falls through */
	        case 'week':
	        case 'isoWeek':
	        case 'day':
	            this.hours(0);
	            /* falls through */
	        case 'hour':
	            this.minutes(0);
	            /* falls through */
	        case 'minute':
	            this.seconds(0);
	            /* falls through */
	        case 'second':
	            this.milliseconds(0);
	        }

	        // weeks are a special case
	        if (units === 'week') {
	            this.weekday(0);
	        }
	        if (units === 'isoWeek') {
	            this.isoWeekday(1);
	        }

	        // quarters are also special
	        if (units === 'quarter') {
	            this.month(Math.floor(this.month() / 3) * 3);
	        }

	        return this;
	    }

	    function endOf (units) {
	        units = normalizeUnits(units);
	        if (units === undefined || units === 'millisecond') {
	            return this;
	        }
	        return this.startOf(units).add(1, (units === 'isoWeek' ? 'week' : units)).subtract(1, 'ms');
	    }

	    function to_type__valueOf () {
	        return +this._d - ((this._offset || 0) * 60000);
	    }

	    function unix () {
	        return Math.floor(+this / 1000);
	    }

	    function toDate () {
	        return this._offset ? new Date(+this) : this._d;
	    }

	    function toArray () {
	        var m = this;
	        return [m.year(), m.month(), m.date(), m.hour(), m.minute(), m.second(), m.millisecond()];
	    }

	    function toObject () {
	        var m = this;
	        return {
	            years: m.year(),
	            months: m.month(),
	            date: m.date(),
	            hours: m.hours(),
	            minutes: m.minutes(),
	            seconds: m.seconds(),
	            milliseconds: m.milliseconds()
	        };
	    }

	    function moment_valid__isValid () {
	        return valid__isValid(this);
	    }

	    function parsingFlags () {
	        return extend({}, getParsingFlags(this));
	    }

	    function invalidAt () {
	        return getParsingFlags(this).overflow;
	    }

	    addFormatToken(0, ['gg', 2], 0, function () {
	        return this.weekYear() % 100;
	    });

	    addFormatToken(0, ['GG', 2], 0, function () {
	        return this.isoWeekYear() % 100;
	    });

	    function addWeekYearFormatToken (token, getter) {
	        addFormatToken(0, [token, token.length], 0, getter);
	    }

	    addWeekYearFormatToken('gggg',     'weekYear');
	    addWeekYearFormatToken('ggggg',    'weekYear');
	    addWeekYearFormatToken('GGGG',  'isoWeekYear');
	    addWeekYearFormatToken('GGGGG', 'isoWeekYear');

	    // ALIASES

	    addUnitAlias('weekYear', 'gg');
	    addUnitAlias('isoWeekYear', 'GG');

	    // PARSING

	    addRegexToken('G',      matchSigned);
	    addRegexToken('g',      matchSigned);
	    addRegexToken('GG',     match1to2, match2);
	    addRegexToken('gg',     match1to2, match2);
	    addRegexToken('GGGG',   match1to4, match4);
	    addRegexToken('gggg',   match1to4, match4);
	    addRegexToken('GGGGG',  match1to6, match6);
	    addRegexToken('ggggg',  match1to6, match6);

	    addWeekParseToken(['gggg', 'ggggg', 'GGGG', 'GGGGG'], function (input, week, config, token) {
	        week[token.substr(0, 2)] = toInt(input);
	    });

	    addWeekParseToken(['gg', 'GG'], function (input, week, config, token) {
	        week[token] = utils_hooks__hooks.parseTwoDigitYear(input);
	    });

	    // HELPERS

	    function weeksInYear(year, dow, doy) {
	        return weekOfYear(local__createLocal([year, 11, 31 + dow - doy]), dow, doy).week;
	    }

	    // MOMENTS

	    function getSetWeekYear (input) {
	        var year = weekOfYear(this, this.localeData()._week.dow, this.localeData()._week.doy).year;
	        return input == null ? year : this.add((input - year), 'y');
	    }

	    function getSetISOWeekYear (input) {
	        var year = weekOfYear(this, 1, 4).year;
	        return input == null ? year : this.add((input - year), 'y');
	    }

	    function getISOWeeksInYear () {
	        return weeksInYear(this.year(), 1, 4);
	    }

	    function getWeeksInYear () {
	        var weekInfo = this.localeData()._week;
	        return weeksInYear(this.year(), weekInfo.dow, weekInfo.doy);
	    }

	    addFormatToken('Q', 0, 0, 'quarter');

	    // ALIASES

	    addUnitAlias('quarter', 'Q');

	    // PARSING

	    addRegexToken('Q', match1);
	    addParseToken('Q', function (input, array) {
	        array[MONTH] = (toInt(input) - 1) * 3;
	    });

	    // MOMENTS

	    function getSetQuarter (input) {
	        return input == null ? Math.ceil((this.month() + 1) / 3) : this.month((input - 1) * 3 + this.month() % 3);
	    }

	    addFormatToken('D', ['DD', 2], 'Do', 'date');

	    // ALIASES

	    addUnitAlias('date', 'D');

	    // PARSING

	    addRegexToken('D',  match1to2);
	    addRegexToken('DD', match1to2, match2);
	    addRegexToken('Do', function (isStrict, locale) {
	        return isStrict ? locale._ordinalParse : locale._ordinalParseLenient;
	    });

	    addParseToken(['D', 'DD'], DATE);
	    addParseToken('Do', function (input, array) {
	        array[DATE] = toInt(input.match(match1to2)[0], 10);
	    });

	    // MOMENTS

	    var getSetDayOfMonth = makeGetSet('Date', true);

	    addFormatToken('d', 0, 'do', 'day');

	    addFormatToken('dd', 0, 0, function (format) {
	        return this.localeData().weekdaysMin(this, format);
	    });

	    addFormatToken('ddd', 0, 0, function (format) {
	        return this.localeData().weekdaysShort(this, format);
	    });

	    addFormatToken('dddd', 0, 0, function (format) {
	        return this.localeData().weekdays(this, format);
	    });

	    addFormatToken('e', 0, 0, 'weekday');
	    addFormatToken('E', 0, 0, 'isoWeekday');

	    // ALIASES

	    addUnitAlias('day', 'd');
	    addUnitAlias('weekday', 'e');
	    addUnitAlias('isoWeekday', 'E');

	    // PARSING

	    addRegexToken('d',    match1to2);
	    addRegexToken('e',    match1to2);
	    addRegexToken('E',    match1to2);
	    addRegexToken('dd',   matchWord);
	    addRegexToken('ddd',  matchWord);
	    addRegexToken('dddd', matchWord);

	    addWeekParseToken(['dd', 'ddd', 'dddd'], function (input, week, config) {
	        var weekday = config._locale.weekdaysParse(input);
	        // if we didn't get a weekday name, mark the date as invalid
	        if (weekday != null) {
	            week.d = weekday;
	        } else {
	            getParsingFlags(config).invalidWeekday = input;
	        }
	    });

	    addWeekParseToken(['d', 'e', 'E'], function (input, week, config, token) {
	        week[token] = toInt(input);
	    });

	    // HELPERS

	    function parseWeekday(input, locale) {
	        if (typeof input !== 'string') {
	            return input;
	        }

	        if (!isNaN(input)) {
	            return parseInt(input, 10);
	        }

	        input = locale.weekdaysParse(input);
	        if (typeof input === 'number') {
	            return input;
	        }

	        return null;
	    }

	    // LOCALES

	    var defaultLocaleWeekdays = 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split('_');
	    function localeWeekdays (m) {
	        return this._weekdays[m.day()];
	    }

	    var defaultLocaleWeekdaysShort = 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_');
	    function localeWeekdaysShort (m) {
	        return this._weekdaysShort[m.day()];
	    }

	    var defaultLocaleWeekdaysMin = 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_');
	    function localeWeekdaysMin (m) {
	        return this._weekdaysMin[m.day()];
	    }

	    function localeWeekdaysParse (weekdayName) {
	        var i, mom, regex;

	        this._weekdaysParse = this._weekdaysParse || [];

	        for (i = 0; i < 7; i++) {
	            // make the regex if we don't have it already
	            if (!this._weekdaysParse[i]) {
	                mom = local__createLocal([2000, 1]).day(i);
	                regex = '^' + this.weekdays(mom, '') + '|^' + this.weekdaysShort(mom, '') + '|^' + this.weekdaysMin(mom, '');
	                this._weekdaysParse[i] = new RegExp(regex.replace('.', ''), 'i');
	            }
	            // test the regex
	            if (this._weekdaysParse[i].test(weekdayName)) {
	                return i;
	            }
	        }
	    }

	    // MOMENTS

	    function getSetDayOfWeek (input) {
	        var day = this._isUTC ? this._d.getUTCDay() : this._d.getDay();
	        if (input != null) {
	            input = parseWeekday(input, this.localeData());
	            return this.add(input - day, 'd');
	        } else {
	            return day;
	        }
	    }

	    function getSetLocaleDayOfWeek (input) {
	        var weekday = (this.day() + 7 - this.localeData()._week.dow) % 7;
	        return input == null ? weekday : this.add(input - weekday, 'd');
	    }

	    function getSetISODayOfWeek (input) {
	        // behaves the same as moment#day except
	        // as a getter, returns 7 instead of 0 (1-7 range instead of 0-6)
	        // as a setter, sunday should belong to the previous week.
	        return input == null ? this.day() || 7 : this.day(this.day() % 7 ? input : input - 7);
	    }

	    addFormatToken('H', ['HH', 2], 0, 'hour');
	    addFormatToken('h', ['hh', 2], 0, function () {
	        return this.hours() % 12 || 12;
	    });

	    function meridiem (token, lowercase) {
	        addFormatToken(token, 0, 0, function () {
	            return this.localeData().meridiem(this.hours(), this.minutes(), lowercase);
	        });
	    }

	    meridiem('a', true);
	    meridiem('A', false);

	    // ALIASES

	    addUnitAlias('hour', 'h');

	    // PARSING

	    function matchMeridiem (isStrict, locale) {
	        return locale._meridiemParse;
	    }

	    addRegexToken('a',  matchMeridiem);
	    addRegexToken('A',  matchMeridiem);
	    addRegexToken('H',  match1to2);
	    addRegexToken('h',  match1to2);
	    addRegexToken('HH', match1to2, match2);
	    addRegexToken('hh', match1to2, match2);

	    addParseToken(['H', 'HH'], HOUR);
	    addParseToken(['a', 'A'], function (input, array, config) {
	        config._isPm = config._locale.isPM(input);
	        config._meridiem = input;
	    });
	    addParseToken(['h', 'hh'], function (input, array, config) {
	        array[HOUR] = toInt(input);
	        getParsingFlags(config).bigHour = true;
	    });

	    // LOCALES

	    function localeIsPM (input) {
	        // IE8 Quirks Mode & IE7 Standards Mode do not allow accessing strings like arrays
	        // Using charAt should be more compatible.
	        return ((input + '').toLowerCase().charAt(0) === 'p');
	    }

	    var defaultLocaleMeridiemParse = /[ap]\.?m?\.?/i;
	    function localeMeridiem (hours, minutes, isLower) {
	        if (hours > 11) {
	            return isLower ? 'pm' : 'PM';
	        } else {
	            return isLower ? 'am' : 'AM';
	        }
	    }


	    // MOMENTS

	    // Setting the hour should keep the time, because the user explicitly
	    // specified which hour he wants. So trying to maintain the same hour (in
	    // a new timezone) makes sense. Adding/subtracting hours does not follow
	    // this rule.
	    var getSetHour = makeGetSet('Hours', true);

	    addFormatToken('m', ['mm', 2], 0, 'minute');

	    // ALIASES

	    addUnitAlias('minute', 'm');

	    // PARSING

	    addRegexToken('m',  match1to2);
	    addRegexToken('mm', match1to2, match2);
	    addParseToken(['m', 'mm'], MINUTE);

	    // MOMENTS

	    var getSetMinute = makeGetSet('Minutes', false);

	    addFormatToken('s', ['ss', 2], 0, 'second');

	    // ALIASES

	    addUnitAlias('second', 's');

	    // PARSING

	    addRegexToken('s',  match1to2);
	    addRegexToken('ss', match1to2, match2);
	    addParseToken(['s', 'ss'], SECOND);

	    // MOMENTS

	    var getSetSecond = makeGetSet('Seconds', false);

	    addFormatToken('S', 0, 0, function () {
	        return ~~(this.millisecond() / 100);
	    });

	    addFormatToken(0, ['SS', 2], 0, function () {
	        return ~~(this.millisecond() / 10);
	    });

	    addFormatToken(0, ['SSS', 3], 0, 'millisecond');
	    addFormatToken(0, ['SSSS', 4], 0, function () {
	        return this.millisecond() * 10;
	    });
	    addFormatToken(0, ['SSSSS', 5], 0, function () {
	        return this.millisecond() * 100;
	    });
	    addFormatToken(0, ['SSSSSS', 6], 0, function () {
	        return this.millisecond() * 1000;
	    });
	    addFormatToken(0, ['SSSSSSS', 7], 0, function () {
	        return this.millisecond() * 10000;
	    });
	    addFormatToken(0, ['SSSSSSSS', 8], 0, function () {
	        return this.millisecond() * 100000;
	    });
	    addFormatToken(0, ['SSSSSSSSS', 9], 0, function () {
	        return this.millisecond() * 1000000;
	    });


	    // ALIASES

	    addUnitAlias('millisecond', 'ms');

	    // PARSING

	    addRegexToken('S',    match1to3, match1);
	    addRegexToken('SS',   match1to3, match2);
	    addRegexToken('SSS',  match1to3, match3);

	    var token;
	    for (token = 'SSSS'; token.length <= 9; token += 'S') {
	        addRegexToken(token, matchUnsigned);
	    }

	    function parseMs(input, array) {
	        array[MILLISECOND] = toInt(('0.' + input) * 1000);
	    }

	    for (token = 'S'; token.length <= 9; token += 'S') {
	        addParseToken(token, parseMs);
	    }
	    // MOMENTS

	    var getSetMillisecond = makeGetSet('Milliseconds', false);

	    addFormatToken('z',  0, 0, 'zoneAbbr');
	    addFormatToken('zz', 0, 0, 'zoneName');

	    // MOMENTS

	    function getZoneAbbr () {
	        return this._isUTC ? 'UTC' : '';
	    }

	    function getZoneName () {
	        return this._isUTC ? 'Coordinated Universal Time' : '';
	    }

	    var momentPrototype__proto = Moment.prototype;

	    momentPrototype__proto.add          = add_subtract__add;
	    momentPrototype__proto.calendar     = moment_calendar__calendar;
	    momentPrototype__proto.clone        = clone;
	    momentPrototype__proto.diff         = diff;
	    momentPrototype__proto.endOf        = endOf;
	    momentPrototype__proto.format       = format;
	    momentPrototype__proto.from         = from;
	    momentPrototype__proto.fromNow      = fromNow;
	    momentPrototype__proto.to           = to;
	    momentPrototype__proto.toNow        = toNow;
	    momentPrototype__proto.get          = getSet;
	    momentPrototype__proto.invalidAt    = invalidAt;
	    momentPrototype__proto.isAfter      = isAfter;
	    momentPrototype__proto.isBefore     = isBefore;
	    momentPrototype__proto.isBetween    = isBetween;
	    momentPrototype__proto.isSame       = isSame;
	    momentPrototype__proto.isValid      = moment_valid__isValid;
	    momentPrototype__proto.lang         = lang;
	    momentPrototype__proto.locale       = locale;
	    momentPrototype__proto.localeData   = localeData;
	    momentPrototype__proto.max          = prototypeMax;
	    momentPrototype__proto.min          = prototypeMin;
	    momentPrototype__proto.parsingFlags = parsingFlags;
	    momentPrototype__proto.set          = getSet;
	    momentPrototype__proto.startOf      = startOf;
	    momentPrototype__proto.subtract     = add_subtract__subtract;
	    momentPrototype__proto.toArray      = toArray;
	    momentPrototype__proto.toObject     = toObject;
	    momentPrototype__proto.toDate       = toDate;
	    momentPrototype__proto.toISOString  = moment_format__toISOString;
	    momentPrototype__proto.toJSON       = moment_format__toISOString;
	    momentPrototype__proto.toString     = toString;
	    momentPrototype__proto.unix         = unix;
	    momentPrototype__proto.valueOf      = to_type__valueOf;

	    // Year
	    momentPrototype__proto.year       = getSetYear;
	    momentPrototype__proto.isLeapYear = getIsLeapYear;

	    // Week Year
	    momentPrototype__proto.weekYear    = getSetWeekYear;
	    momentPrototype__proto.isoWeekYear = getSetISOWeekYear;

	    // Quarter
	    momentPrototype__proto.quarter = momentPrototype__proto.quarters = getSetQuarter;

	    // Month
	    momentPrototype__proto.month       = getSetMonth;
	    momentPrototype__proto.daysInMonth = getDaysInMonth;

	    // Week
	    momentPrototype__proto.week           = momentPrototype__proto.weeks        = getSetWeek;
	    momentPrototype__proto.isoWeek        = momentPrototype__proto.isoWeeks     = getSetISOWeek;
	    momentPrototype__proto.weeksInYear    = getWeeksInYear;
	    momentPrototype__proto.isoWeeksInYear = getISOWeeksInYear;

	    // Day
	    momentPrototype__proto.date       = getSetDayOfMonth;
	    momentPrototype__proto.day        = momentPrototype__proto.days             = getSetDayOfWeek;
	    momentPrototype__proto.weekday    = getSetLocaleDayOfWeek;
	    momentPrototype__proto.isoWeekday = getSetISODayOfWeek;
	    momentPrototype__proto.dayOfYear  = getSetDayOfYear;

	    // Hour
	    momentPrototype__proto.hour = momentPrototype__proto.hours = getSetHour;

	    // Minute
	    momentPrototype__proto.minute = momentPrototype__proto.minutes = getSetMinute;

	    // Second
	    momentPrototype__proto.second = momentPrototype__proto.seconds = getSetSecond;

	    // Millisecond
	    momentPrototype__proto.millisecond = momentPrototype__proto.milliseconds = getSetMillisecond;

	    // Offset
	    momentPrototype__proto.utcOffset            = getSetOffset;
	    momentPrototype__proto.utc                  = setOffsetToUTC;
	    momentPrototype__proto.local                = setOffsetToLocal;
	    momentPrototype__proto.parseZone            = setOffsetToParsedOffset;
	    momentPrototype__proto.hasAlignedHourOffset = hasAlignedHourOffset;
	    momentPrototype__proto.isDST                = isDaylightSavingTime;
	    momentPrototype__proto.isDSTShifted         = isDaylightSavingTimeShifted;
	    momentPrototype__proto.isLocal              = isLocal;
	    momentPrototype__proto.isUtcOffset          = isUtcOffset;
	    momentPrototype__proto.isUtc                = isUtc;
	    momentPrototype__proto.isUTC                = isUtc;

	    // Timezone
	    momentPrototype__proto.zoneAbbr = getZoneAbbr;
	    momentPrototype__proto.zoneName = getZoneName;

	    // Deprecations
	    momentPrototype__proto.dates  = deprecate('dates accessor is deprecated. Use date instead.', getSetDayOfMonth);
	    momentPrototype__proto.months = deprecate('months accessor is deprecated. Use month instead', getSetMonth);
	    momentPrototype__proto.years  = deprecate('years accessor is deprecated. Use year instead', getSetYear);
	    momentPrototype__proto.zone   = deprecate('moment().zone is deprecated, use moment().utcOffset instead. https://github.com/moment/moment/issues/1779', getSetZone);

	    var momentPrototype = momentPrototype__proto;

	    function moment__createUnix (input) {
	        return local__createLocal(input * 1000);
	    }

	    function moment__createInZone () {
	        return local__createLocal.apply(null, arguments).parseZone();
	    }

	    var defaultCalendar = {
	        sameDay : '[Today at] LT',
	        nextDay : '[Tomorrow at] LT',
	        nextWeek : 'dddd [at] LT',
	        lastDay : '[Yesterday at] LT',
	        lastWeek : '[Last] dddd [at] LT',
	        sameElse : 'L'
	    };

	    function locale_calendar__calendar (key, mom, now) {
	        var output = this._calendar[key];
	        return typeof output === 'function' ? output.call(mom, now) : output;
	    }

	    var defaultLongDateFormat = {
	        LTS  : 'h:mm:ss A',
	        LT   : 'h:mm A',
	        L    : 'MM/DD/YYYY',
	        LL   : 'MMMM D, YYYY',
	        LLL  : 'MMMM D, YYYY h:mm A',
	        LLLL : 'dddd, MMMM D, YYYY h:mm A'
	    };

	    function longDateFormat (key) {
	        var format = this._longDateFormat[key],
	            formatUpper = this._longDateFormat[key.toUpperCase()];

	        if (format || !formatUpper) {
	            return format;
	        }

	        this._longDateFormat[key] = formatUpper.replace(/MMMM|MM|DD|dddd/g, function (val) {
	            return val.slice(1);
	        });

	        return this._longDateFormat[key];
	    }

	    var defaultInvalidDate = 'Invalid date';

	    function invalidDate () {
	        return this._invalidDate;
	    }

	    var defaultOrdinal = '%d';
	    var defaultOrdinalParse = /\d{1,2}/;

	    function ordinal (number) {
	        return this._ordinal.replace('%d', number);
	    }

	    function preParsePostFormat (string) {
	        return string;
	    }

	    var defaultRelativeTime = {
	        future : 'in %s',
	        past   : '%s ago',
	        s  : 'a few seconds',
	        m  : 'a minute',
	        mm : '%d minutes',
	        h  : 'an hour',
	        hh : '%d hours',
	        d  : 'a day',
	        dd : '%d days',
	        M  : 'a month',
	        MM : '%d months',
	        y  : 'a year',
	        yy : '%d years'
	    };

	    function relative__relativeTime (number, withoutSuffix, string, isFuture) {
	        var output = this._relativeTime[string];
	        return (typeof output === 'function') ?
	            output(number, withoutSuffix, string, isFuture) :
	            output.replace(/%d/i, number);
	    }

	    function pastFuture (diff, output) {
	        var format = this._relativeTime[diff > 0 ? 'future' : 'past'];
	        return typeof format === 'function' ? format(output) : format.replace(/%s/i, output);
	    }

	    function locale_set__set (config) {
	        var prop, i;
	        for (i in config) {
	            prop = config[i];
	            if (typeof prop === 'function') {
	                this[i] = prop;
	            } else {
	                this['_' + i] = prop;
	            }
	        }
	        // Lenient ordinal parsing accepts just a number in addition to
	        // number + (possibly) stuff coming from _ordinalParseLenient.
	        this._ordinalParseLenient = new RegExp(this._ordinalParse.source + '|' + (/\d{1,2}/).source);
	    }

	    var prototype__proto = Locale.prototype;

	    prototype__proto._calendar       = defaultCalendar;
	    prototype__proto.calendar        = locale_calendar__calendar;
	    prototype__proto._longDateFormat = defaultLongDateFormat;
	    prototype__proto.longDateFormat  = longDateFormat;
	    prototype__proto._invalidDate    = defaultInvalidDate;
	    prototype__proto.invalidDate     = invalidDate;
	    prototype__proto._ordinal        = defaultOrdinal;
	    prototype__proto.ordinal         = ordinal;
	    prototype__proto._ordinalParse   = defaultOrdinalParse;
	    prototype__proto.preparse        = preParsePostFormat;
	    prototype__proto.postformat      = preParsePostFormat;
	    prototype__proto._relativeTime   = defaultRelativeTime;
	    prototype__proto.relativeTime    = relative__relativeTime;
	    prototype__proto.pastFuture      = pastFuture;
	    prototype__proto.set             = locale_set__set;

	    // Month
	    prototype__proto.months       =        localeMonths;
	    prototype__proto._months      = defaultLocaleMonths;
	    prototype__proto.monthsShort  =        localeMonthsShort;
	    prototype__proto._monthsShort = defaultLocaleMonthsShort;
	    prototype__proto.monthsParse  =        localeMonthsParse;

	    // Week
	    prototype__proto.week = localeWeek;
	    prototype__proto._week = defaultLocaleWeek;
	    prototype__proto.firstDayOfYear = localeFirstDayOfYear;
	    prototype__proto.firstDayOfWeek = localeFirstDayOfWeek;

	    // Day of Week
	    prototype__proto.weekdays       =        localeWeekdays;
	    prototype__proto._weekdays      = defaultLocaleWeekdays;
	    prototype__proto.weekdaysMin    =        localeWeekdaysMin;
	    prototype__proto._weekdaysMin   = defaultLocaleWeekdaysMin;
	    prototype__proto.weekdaysShort  =        localeWeekdaysShort;
	    prototype__proto._weekdaysShort = defaultLocaleWeekdaysShort;
	    prototype__proto.weekdaysParse  =        localeWeekdaysParse;

	    // Hours
	    prototype__proto.isPM = localeIsPM;
	    prototype__proto._meridiemParse = defaultLocaleMeridiemParse;
	    prototype__proto.meridiem = localeMeridiem;

	    function lists__get (format, index, field, setter) {
	        var locale = locale_locales__getLocale();
	        var utc = create_utc__createUTC().set(setter, index);
	        return locale[field](utc, format);
	    }

	    function list (format, index, field, count, setter) {
	        if (typeof format === 'number') {
	            index = format;
	            format = undefined;
	        }

	        format = format || '';

	        if (index != null) {
	            return lists__get(format, index, field, setter);
	        }

	        var i;
	        var out = [];
	        for (i = 0; i < count; i++) {
	            out[i] = lists__get(format, i, field, setter);
	        }
	        return out;
	    }

	    function lists__listMonths (format, index) {
	        return list(format, index, 'months', 12, 'month');
	    }

	    function lists__listMonthsShort (format, index) {
	        return list(format, index, 'monthsShort', 12, 'month');
	    }

	    function lists__listWeekdays (format, index) {
	        return list(format, index, 'weekdays', 7, 'day');
	    }

	    function lists__listWeekdaysShort (format, index) {
	        return list(format, index, 'weekdaysShort', 7, 'day');
	    }

	    function lists__listWeekdaysMin (format, index) {
	        return list(format, index, 'weekdaysMin', 7, 'day');
	    }

	    locale_locales__getSetGlobalLocale('en', {
	        ordinalParse: /\d{1,2}(th|st|nd|rd)/,
	        ordinal : function (number) {
	            var b = number % 10,
	                output = (toInt(number % 100 / 10) === 1) ? 'th' :
	                (b === 1) ? 'st' :
	                (b === 2) ? 'nd' :
	                (b === 3) ? 'rd' : 'th';
	            return number + output;
	        }
	    });

	    // Side effect imports
	    utils_hooks__hooks.lang = deprecate('moment.lang is deprecated. Use moment.locale instead.', locale_locales__getSetGlobalLocale);
	    utils_hooks__hooks.langData = deprecate('moment.langData is deprecated. Use moment.localeData instead.', locale_locales__getLocale);

	    var mathAbs = Math.abs;

	    function duration_abs__abs () {
	        var data           = this._data;

	        this._milliseconds = mathAbs(this._milliseconds);
	        this._days         = mathAbs(this._days);
	        this._months       = mathAbs(this._months);

	        data.milliseconds  = mathAbs(data.milliseconds);
	        data.seconds       = mathAbs(data.seconds);
	        data.minutes       = mathAbs(data.minutes);
	        data.hours         = mathAbs(data.hours);
	        data.months        = mathAbs(data.months);
	        data.years         = mathAbs(data.years);

	        return this;
	    }

	    function duration_add_subtract__addSubtract (duration, input, value, direction) {
	        var other = create__createDuration(input, value);

	        duration._milliseconds += direction * other._milliseconds;
	        duration._days         += direction * other._days;
	        duration._months       += direction * other._months;

	        return duration._bubble();
	    }

	    // supports only 2.0-style add(1, 's') or add(duration)
	    function duration_add_subtract__add (input, value) {
	        return duration_add_subtract__addSubtract(this, input, value, 1);
	    }

	    // supports only 2.0-style subtract(1, 's') or subtract(duration)
	    function duration_add_subtract__subtract (input, value) {
	        return duration_add_subtract__addSubtract(this, input, value, -1);
	    }

	    function absCeil (number) {
	        if (number < 0) {
	            return Math.floor(number);
	        } else {
	            return Math.ceil(number);
	        }
	    }

	    function bubble () {
	        var milliseconds = this._milliseconds;
	        var days         = this._days;
	        var months       = this._months;
	        var data         = this._data;
	        var seconds, minutes, hours, years, monthsFromDays;

	        // if we have a mix of positive and negative values, bubble down first
	        // check: https://github.com/moment/moment/issues/2166
	        if (!((milliseconds >= 0 && days >= 0 && months >= 0) ||
	                (milliseconds <= 0 && days <= 0 && months <= 0))) {
	            milliseconds += absCeil(monthsToDays(months) + days) * 864e5;
	            days = 0;
	            months = 0;
	        }

	        // The following code bubbles up values, see the tests for
	        // examples of what that means.
	        data.milliseconds = milliseconds % 1000;

	        seconds           = absFloor(milliseconds / 1000);
	        data.seconds      = seconds % 60;

	        minutes           = absFloor(seconds / 60);
	        data.minutes      = minutes % 60;

	        hours             = absFloor(minutes / 60);
	        data.hours        = hours % 24;

	        days += absFloor(hours / 24);

	        // convert days to months
	        monthsFromDays = absFloor(daysToMonths(days));
	        months += monthsFromDays;
	        days -= absCeil(monthsToDays(monthsFromDays));

	        // 12 months -> 1 year
	        years = absFloor(months / 12);
	        months %= 12;

	        data.days   = days;
	        data.months = months;
	        data.years  = years;

	        return this;
	    }

	    function daysToMonths (days) {
	        // 400 years have 146097 days (taking into account leap year rules)
	        // 400 years have 12 months === 4800
	        return days * 4800 / 146097;
	    }

	    function monthsToDays (months) {
	        // the reverse of daysToMonths
	        return months * 146097 / 4800;
	    }

	    function as (units) {
	        var days;
	        var months;
	        var milliseconds = this._milliseconds;

	        units = normalizeUnits(units);

	        if (units === 'month' || units === 'year') {
	            days   = this._days   + milliseconds / 864e5;
	            months = this._months + daysToMonths(days);
	            return units === 'month' ? months : months / 12;
	        } else {
	            // handle milliseconds separately because of floating point math errors (issue #1867)
	            days = this._days + Math.round(monthsToDays(this._months));
	            switch (units) {
	                case 'week'   : return days / 7     + milliseconds / 6048e5;
	                case 'day'    : return days         + milliseconds / 864e5;
	                case 'hour'   : return days * 24    + milliseconds / 36e5;
	                case 'minute' : return days * 1440  + milliseconds / 6e4;
	                case 'second' : return days * 86400 + milliseconds / 1000;
	                // Math.floor prevents floating point math errors here
	                case 'millisecond': return Math.floor(days * 864e5) + milliseconds;
	                default: throw new Error('Unknown unit ' + units);
	            }
	        }
	    }

	    // TODO: Use this.as('ms')?
	    function duration_as__valueOf () {
	        return (
	            this._milliseconds +
	            this._days * 864e5 +
	            (this._months % 12) * 2592e6 +
	            toInt(this._months / 12) * 31536e6
	        );
	    }

	    function makeAs (alias) {
	        return function () {
	            return this.as(alias);
	        };
	    }

	    var asMilliseconds = makeAs('ms');
	    var asSeconds      = makeAs('s');
	    var asMinutes      = makeAs('m');
	    var asHours        = makeAs('h');
	    var asDays         = makeAs('d');
	    var asWeeks        = makeAs('w');
	    var asMonths       = makeAs('M');
	    var asYears        = makeAs('y');

	    function duration_get__get (units) {
	        units = normalizeUnits(units);
	        return this[units + 's']();
	    }

	    function makeGetter(name) {
	        return function () {
	            return this._data[name];
	        };
	    }

	    var milliseconds = makeGetter('milliseconds');
	    var seconds      = makeGetter('seconds');
	    var minutes      = makeGetter('minutes');
	    var hours        = makeGetter('hours');
	    var days         = makeGetter('days');
	    var months       = makeGetter('months');
	    var years        = makeGetter('years');

	    function weeks () {
	        return absFloor(this.days() / 7);
	    }

	    var round = Math.round;
	    var thresholds = {
	        s: 45,  // seconds to minute
	        m: 45,  // minutes to hour
	        h: 22,  // hours to day
	        d: 26,  // days to month
	        M: 11   // months to year
	    };

	    // helper function for moment.fn.from, moment.fn.fromNow, and moment.duration.fn.humanize
	    function substituteTimeAgo(string, number, withoutSuffix, isFuture, locale) {
	        return locale.relativeTime(number || 1, !!withoutSuffix, string, isFuture);
	    }

	    function duration_humanize__relativeTime (posNegDuration, withoutSuffix, locale) {
	        var duration = create__createDuration(posNegDuration).abs();
	        var seconds  = round(duration.as('s'));
	        var minutes  = round(duration.as('m'));
	        var hours    = round(duration.as('h'));
	        var days     = round(duration.as('d'));
	        var months   = round(duration.as('M'));
	        var years    = round(duration.as('y'));

	        var a = seconds < thresholds.s && ['s', seconds]  ||
	                minutes === 1          && ['m']           ||
	                minutes < thresholds.m && ['mm', minutes] ||
	                hours   === 1          && ['h']           ||
	                hours   < thresholds.h && ['hh', hours]   ||
	                days    === 1          && ['d']           ||
	                days    < thresholds.d && ['dd', days]    ||
	                months  === 1          && ['M']           ||
	                months  < thresholds.M && ['MM', months]  ||
	                years   === 1          && ['y']           || ['yy', years];

	        a[2] = withoutSuffix;
	        a[3] = +posNegDuration > 0;
	        a[4] = locale;
	        return substituteTimeAgo.apply(null, a);
	    }

	    // This function allows you to set a threshold for relative time strings
	    function duration_humanize__getSetRelativeTimeThreshold (threshold, limit) {
	        if (thresholds[threshold] === undefined) {
	            return false;
	        }
	        if (limit === undefined) {
	            return thresholds[threshold];
	        }
	        thresholds[threshold] = limit;
	        return true;
	    }

	    function humanize (withSuffix) {
	        var locale = this.localeData();
	        var output = duration_humanize__relativeTime(this, !withSuffix, locale);

	        if (withSuffix) {
	            output = locale.pastFuture(+this, output);
	        }

	        return locale.postformat(output);
	    }

	    var iso_string__abs = Math.abs;

	    function iso_string__toISOString() {
	        // for ISO strings we do not use the normal bubbling rules:
	        //  * milliseconds bubble up until they become hours
	        //  * days do not bubble at all
	        //  * months bubble up until they become years
	        // This is because there is no context-free conversion between hours and days
	        // (think of clock changes)
	        // and also not between days and months (28-31 days per month)
	        var seconds = iso_string__abs(this._milliseconds) / 1000;
	        var days         = iso_string__abs(this._days);
	        var months       = iso_string__abs(this._months);
	        var minutes, hours, years;

	        // 3600 seconds -> 60 minutes -> 1 hour
	        minutes           = absFloor(seconds / 60);
	        hours             = absFloor(minutes / 60);
	        seconds %= 60;
	        minutes %= 60;

	        // 12 months -> 1 year
	        years  = absFloor(months / 12);
	        months %= 12;


	        // inspired by https://github.com/dordille/moment-isoduration/blob/master/moment.isoduration.js
	        var Y = years;
	        var M = months;
	        var D = days;
	        var h = hours;
	        var m = minutes;
	        var s = seconds;
	        var total = this.asSeconds();

	        if (!total) {
	            // this is the same as C#'s (Noda) and python (isodate)...
	            // but not other JS (goog.date)
	            return 'P0D';
	        }

	        return (total < 0 ? '-' : '') +
	            'P' +
	            (Y ? Y + 'Y' : '') +
	            (M ? M + 'M' : '') +
	            (D ? D + 'D' : '') +
	            ((h || m || s) ? 'T' : '') +
	            (h ? h + 'H' : '') +
	            (m ? m + 'M' : '') +
	            (s ? s + 'S' : '');
	    }

	    var duration_prototype__proto = Duration.prototype;

	    duration_prototype__proto.abs            = duration_abs__abs;
	    duration_prototype__proto.add            = duration_add_subtract__add;
	    duration_prototype__proto.subtract       = duration_add_subtract__subtract;
	    duration_prototype__proto.as             = as;
	    duration_prototype__proto.asMilliseconds = asMilliseconds;
	    duration_prototype__proto.asSeconds      = asSeconds;
	    duration_prototype__proto.asMinutes      = asMinutes;
	    duration_prototype__proto.asHours        = asHours;
	    duration_prototype__proto.asDays         = asDays;
	    duration_prototype__proto.asWeeks        = asWeeks;
	    duration_prototype__proto.asMonths       = asMonths;
	    duration_prototype__proto.asYears        = asYears;
	    duration_prototype__proto.valueOf        = duration_as__valueOf;
	    duration_prototype__proto._bubble        = bubble;
	    duration_prototype__proto.get            = duration_get__get;
	    duration_prototype__proto.milliseconds   = milliseconds;
	    duration_prototype__proto.seconds        = seconds;
	    duration_prototype__proto.minutes        = minutes;
	    duration_prototype__proto.hours          = hours;
	    duration_prototype__proto.days           = days;
	    duration_prototype__proto.weeks          = weeks;
	    duration_prototype__proto.months         = months;
	    duration_prototype__proto.years          = years;
	    duration_prototype__proto.humanize       = humanize;
	    duration_prototype__proto.toISOString    = iso_string__toISOString;
	    duration_prototype__proto.toString       = iso_string__toISOString;
	    duration_prototype__proto.toJSON         = iso_string__toISOString;
	    duration_prototype__proto.locale         = locale;
	    duration_prototype__proto.localeData     = localeData;

	    // Deprecations
	    duration_prototype__proto.toIsoString = deprecate('toIsoString() is deprecated. Please use toISOString() instead (notice the capitals)', iso_string__toISOString);
	    duration_prototype__proto.lang = lang;

	    // Side effect imports

	    addFormatToken('X', 0, 0, 'unix');
	    addFormatToken('x', 0, 0, 'valueOf');

	    // PARSING

	    addRegexToken('x', matchSigned);
	    addRegexToken('X', matchTimestamp);
	    addParseToken('X', function (input, array, config) {
	        config._d = new Date(parseFloat(input, 10) * 1000);
	    });
	    addParseToken('x', function (input, array, config) {
	        config._d = new Date(toInt(input));
	    });

	    // Side effect imports


	    utils_hooks__hooks.version = '2.10.6';

	    setHookCallback(local__createLocal);

	    utils_hooks__hooks.fn                    = momentPrototype;
	    utils_hooks__hooks.min                   = min;
	    utils_hooks__hooks.max                   = max;
	    utils_hooks__hooks.utc                   = create_utc__createUTC;
	    utils_hooks__hooks.unix                  = moment__createUnix;
	    utils_hooks__hooks.months                = lists__listMonths;
	    utils_hooks__hooks.isDate                = isDate;
	    utils_hooks__hooks.locale                = locale_locales__getSetGlobalLocale;
	    utils_hooks__hooks.invalid               = valid__createInvalid;
	    utils_hooks__hooks.duration              = create__createDuration;
	    utils_hooks__hooks.isMoment              = isMoment;
	    utils_hooks__hooks.weekdays              = lists__listWeekdays;
	    utils_hooks__hooks.parseZone             = moment__createInZone;
	    utils_hooks__hooks.localeData            = locale_locales__getLocale;
	    utils_hooks__hooks.isDuration            = isDuration;
	    utils_hooks__hooks.monthsShort           = lists__listMonthsShort;
	    utils_hooks__hooks.weekdaysMin           = lists__listWeekdaysMin;
	    utils_hooks__hooks.defineLocale          = defineLocale;
	    utils_hooks__hooks.weekdaysShort         = lists__listWeekdaysShort;
	    utils_hooks__hooks.normalizeUnits        = normalizeUnits;
	    utils_hooks__hooks.relativeTimeThreshold = duration_humanize__getSetRelativeTimeThreshold;

	    var _moment = utils_hooks__hooks;

	    return _moment;

	}));
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(4)(module)))

/***/ },
/* 57 */
/***/ function(module, exports, __webpack_require__) {

	var map = {
		"./af": 58,
		"./af.js": 58,
		"./ar": 59,
		"./ar-ma": 60,
		"./ar-ma.js": 60,
		"./ar-sa": 61,
		"./ar-sa.js": 61,
		"./ar-tn": 62,
		"./ar-tn.js": 62,
		"./ar.js": 59,
		"./az": 63,
		"./az.js": 63,
		"./be": 64,
		"./be.js": 64,
		"./bg": 65,
		"./bg.js": 65,
		"./bn": 66,
		"./bn.js": 66,
		"./bo": 67,
		"./bo.js": 67,
		"./br": 68,
		"./br.js": 68,
		"./bs": 69,
		"./bs.js": 69,
		"./ca": 70,
		"./ca.js": 70,
		"./cs": 71,
		"./cs.js": 71,
		"./cv": 72,
		"./cv.js": 72,
		"./cy": 73,
		"./cy.js": 73,
		"./da": 74,
		"./da.js": 74,
		"./de": 75,
		"./de-at": 76,
		"./de-at.js": 76,
		"./de.js": 75,
		"./el": 77,
		"./el.js": 77,
		"./en-au": 78,
		"./en-au.js": 78,
		"./en-ca": 79,
		"./en-ca.js": 79,
		"./en-gb": 80,
		"./en-gb.js": 80,
		"./eo": 81,
		"./eo.js": 81,
		"./es": 82,
		"./es.js": 82,
		"./et": 83,
		"./et.js": 83,
		"./eu": 84,
		"./eu.js": 84,
		"./fa": 85,
		"./fa.js": 85,
		"./fi": 86,
		"./fi.js": 86,
		"./fo": 87,
		"./fo.js": 87,
		"./fr": 88,
		"./fr-ca": 89,
		"./fr-ca.js": 89,
		"./fr.js": 88,
		"./fy": 90,
		"./fy.js": 90,
		"./gl": 91,
		"./gl.js": 91,
		"./he": 92,
		"./he.js": 92,
		"./hi": 93,
		"./hi.js": 93,
		"./hr": 94,
		"./hr.js": 94,
		"./hu": 95,
		"./hu.js": 95,
		"./hy-am": 96,
		"./hy-am.js": 96,
		"./id": 97,
		"./id.js": 97,
		"./is": 98,
		"./is.js": 98,
		"./it": 99,
		"./it.js": 99,
		"./ja": 100,
		"./ja.js": 100,
		"./jv": 101,
		"./jv.js": 101,
		"./ka": 102,
		"./ka.js": 102,
		"./km": 103,
		"./km.js": 103,
		"./ko": 104,
		"./ko.js": 104,
		"./lb": 105,
		"./lb.js": 105,
		"./lt": 106,
		"./lt.js": 106,
		"./lv": 107,
		"./lv.js": 107,
		"./me": 108,
		"./me.js": 108,
		"./mk": 109,
		"./mk.js": 109,
		"./ml": 110,
		"./ml.js": 110,
		"./mr": 111,
		"./mr.js": 111,
		"./ms": 112,
		"./ms-my": 113,
		"./ms-my.js": 113,
		"./ms.js": 112,
		"./my": 114,
		"./my.js": 114,
		"./nb": 115,
		"./nb.js": 115,
		"./ne": 116,
		"./ne.js": 116,
		"./nl": 117,
		"./nl.js": 117,
		"./nn": 118,
		"./nn.js": 118,
		"./pl": 119,
		"./pl.js": 119,
		"./pt": 120,
		"./pt-br": 121,
		"./pt-br.js": 121,
		"./pt.js": 120,
		"./ro": 122,
		"./ro.js": 122,
		"./ru": 123,
		"./ru.js": 123,
		"./si": 124,
		"./si.js": 124,
		"./sk": 125,
		"./sk.js": 125,
		"./sl": 126,
		"./sl.js": 126,
		"./sq": 127,
		"./sq.js": 127,
		"./sr": 128,
		"./sr-cyrl": 129,
		"./sr-cyrl.js": 129,
		"./sr.js": 128,
		"./sv": 130,
		"./sv.js": 130,
		"./ta": 131,
		"./ta.js": 131,
		"./th": 132,
		"./th.js": 132,
		"./tl-ph": 133,
		"./tl-ph.js": 133,
		"./tr": 134,
		"./tr.js": 134,
		"./tzl": 135,
		"./tzl.js": 135,
		"./tzm": 136,
		"./tzm-latn": 137,
		"./tzm-latn.js": 137,
		"./tzm.js": 136,
		"./uk": 138,
		"./uk.js": 138,
		"./uz": 139,
		"./uz.js": 139,
		"./vi": 140,
		"./vi.js": 140,
		"./zh-cn": 141,
		"./zh-cn.js": 141,
		"./zh-tw": 142,
		"./zh-tw.js": 142
	};
	function webpackContext(req) {
		return __webpack_require__(webpackContextResolve(req));
	};
	function webpackContextResolve(req) {
		return map[req] || (function() { throw new Error("Cannot find module '" + req + "'.") }());
	};
	webpackContext.keys = function webpackContextKeys() {
		return Object.keys(map);
	};
	webpackContext.resolve = webpackContextResolve;
	module.exports = webpackContext;
	webpackContext.id = 57;


/***/ },
/* 58 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : afrikaans (af)
	//! author : Werner Mollentze : https://github.com/wernerm

	(function (global, factory) {
	    true ? factory(__webpack_require__(56)) :
	   typeof define === 'function' && define.amd ? define(['moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';


	    var af = moment.defineLocale('af', {
	        months : 'Januarie_Februarie_Maart_April_Mei_Junie_Julie_Augustus_September_Oktober_November_Desember'.split('_'),
	        monthsShort : 'Jan_Feb_Mar_Apr_Mei_Jun_Jul_Aug_Sep_Okt_Nov_Des'.split('_'),
	        weekdays : 'Sondag_Maandag_Dinsdag_Woensdag_Donderdag_Vrydag_Saterdag'.split('_'),
	        weekdaysShort : 'Son_Maa_Din_Woe_Don_Vry_Sat'.split('_'),
	        weekdaysMin : 'So_Ma_Di_Wo_Do_Vr_Sa'.split('_'),
	        meridiemParse: /vm|nm/i,
	        isPM : function (input) {
	            return /^nm$/i.test(input);
	        },
	        meridiem : function (hours, minutes, isLower) {
	            if (hours < 12) {
	                return isLower ? 'vm' : 'VM';
	            } else {
	                return isLower ? 'nm' : 'NM';
	            }
	        },
	        longDateFormat : {
	            LT : 'HH:mm',
	            LTS : 'HH:mm:ss',
	            L : 'DD/MM/YYYY',
	            LL : 'D MMMM YYYY',
	            LLL : 'D MMMM YYYY HH:mm',
	            LLLL : 'dddd, D MMMM YYYY HH:mm'
	        },
	        calendar : {
	            sameDay : '[Vandag om] LT',
	            nextDay : '[Mre om] LT',
	            nextWeek : 'dddd [om] LT',
	            lastDay : '[Gister om] LT',
	            lastWeek : '[Laas] dddd [om] LT',
	            sameElse : 'L'
	        },
	        relativeTime : {
	            future : 'oor %s',
	            past : '%s gelede',
	            s : '\'n paar sekondes',
	            m : '\'n minuut',
	            mm : '%d minute',
	            h : '\'n uur',
	            hh : '%d ure',
	            d : '\'n dag',
	            dd : '%d dae',
	            M : '\'n maand',
	            MM : '%d maande',
	            y : '\'n jaar',
	            yy : '%d jaar'
	        },
	        ordinalParse: /\d{1,2}(ste|de)/,
	        ordinal : function (number) {
	            return number + ((number === 1 || number === 8 || number >= 20) ? 'ste' : 'de'); // Thanks to Joris Rling : https://github.com/jjupiter
	        },
	        week : {
	            dow : 1, // Maandag is die eerste dag van die week.
	            doy : 4  // Die week wat die 4de Januarie bevat is die eerste week van die jaar.
	        }
	    });

	    return af;

	}));

/***/ },
/* 59 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! Locale: Arabic (ar)
	//! Author: Abdel Said: https://github.com/abdelsaid
	//! Changes in months, weekdays: Ahmed Elkhatib
	//! Native plural forms: forabi https://github.com/forabi

	(function (global, factory) {
	    true ? factory(__webpack_require__(56)) :
	   typeof define === 'function' && define.amd ? define(['moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';


	    var symbolMap = {
	        '1': '',
	        '2': '',
	        '3': '',
	        '4': '',
	        '5': '',
	        '6': '',
	        '7': '',
	        '8': '',
	        '9': '',
	        '0': ''
	    }, numberMap = {
	        '': '1',
	        '': '2',
	        '': '3',
	        '': '4',
	        '': '5',
	        '': '6',
	        '': '7',
	        '': '8',
	        '': '9',
	        '': '0'
	    }, pluralForm = function (n) {
	        return n === 0 ? 0 : n === 1 ? 1 : n === 2 ? 2 : n % 100 >= 3 && n % 100 <= 10 ? 3 : n % 100 >= 11 ? 4 : 5;
	    }, plurals = {
	        s : ['  ', ' ', ['', ''], '%d ', '%d ', '%d '],
	        m : ['  ', ' ', ['', ''], '%d ', '%d ', '%d '],
	        h : ['  ', ' ', ['', ''], '%d ', '%d ', '%d '],
	        d : ['  ', ' ', ['', ''], '%d ', '%d ', '%d '],
	        M : ['  ', ' ', ['', ''], '%d ', '%d ', '%d '],
	        y : ['  ', ' ', ['', ''], '%d ', '%d ', '%d ']
	    }, pluralize = function (u) {
	        return function (number, withoutSuffix, string, isFuture) {
	            var f = pluralForm(number),
	                str = plurals[u][pluralForm(number)];
	            if (f === 2) {
	                str = str[withoutSuffix ? 0 : 1];
	            }
	            return str.replace(/%d/i, number);
	        };
	    }, months = [
	        '  ',
	        ' ',
	        ' ',
	        ' ',
	        ' ',
	        ' ',
	        ' ',
	        ' ',
	        ' ',
	        '  ',
	        '  ',
	        '  '
	    ];

	    var ar = moment.defineLocale('ar', {
	        months : months,
	        monthsShort : months,
	        weekdays : '______'.split('_'),
	        weekdaysShort : '______'.split('_'),
	        weekdaysMin : '______'.split('_'),
	        longDateFormat : {
	            LT : 'HH:mm',
	            LTS : 'HH:mm:ss',
	            L : 'D/\u200FM/\u200FYYYY',
	            LL : 'D MMMM YYYY',
	            LLL : 'D MMMM YYYY HH:mm',
	            LLLL : 'dddd D MMMM YYYY HH:mm'
	        },
	        meridiemParse: /|/,
	        isPM : function (input) {
	            return '' === input;
	        },
	        meridiem : function (hour, minute, isLower) {
	            if (hour < 12) {
	                return '';
	            } else {
	                return '';
	            }
	        },
	        calendar : {
	            sameDay: '[  ] LT',
	            nextDay: '[  ] LT',
	            nextWeek: 'dddd [ ] LT',
	            lastDay: '[  ] LT',
	            lastWeek: 'dddd [ ] LT',
	            sameElse: 'L'
	        },
	        relativeTime : {
	            future : ' %s',
	            past : ' %s',
	            s : pluralize('s'),
	            m : pluralize('m'),
	            mm : pluralize('m'),
	            h : pluralize('h'),
	            hh : pluralize('h'),
	            d : pluralize('d'),
	            dd : pluralize('d'),
	            M : pluralize('M'),
	            MM : pluralize('M'),
	            y : pluralize('y'),
	            yy : pluralize('y')
	        },
	        preparse: function (string) {
	            return string.replace(/\u200f/g, '').replace(/[]/g, function (match) {
	                return numberMap[match];
	            }).replace(//g, ',');
	        },
	        postformat: function (string) {
	            return string.replace(/\d/g, function (match) {
	                return symbolMap[match];
	            }).replace(/,/g, '');
	        },
	        week : {
	            dow : 6, // Saturday is the first day of the week.
	            doy : 12  // The week that contains Jan 1st is the first week of the year.
	        }
	    });

	    return ar;

	}));

/***/ },
/* 60 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Moroccan Arabic (ar-ma)
	//! author : ElFadili Yassine : https://github.com/ElFadiliY
	//! author : Abdel Said : https://github.com/abdelsaid

	(function (global, factory) {
	    true ? factory(__webpack_require__(56)) :
	   typeof define === 'function' && define.amd ? define(['moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';


	    var ar_ma = moment.defineLocale('ar-ma', {
	        months : '___________'.split('_'),
	        monthsShort : '___________'.split('_'),
	        weekdays : '______'.split('_'),
	        weekdaysShort : '______'.split('_'),
	        weekdaysMin : '______'.split('_'),
	        longDateFormat : {
	            LT : 'HH:mm',
	            LTS : 'HH:mm:ss',
	            L : 'DD/MM/YYYY',
	            LL : 'D MMMM YYYY',
	            LLL : 'D MMMM YYYY HH:mm',
	            LLLL : 'dddd D MMMM YYYY HH:mm'
	        },
	        calendar : {
	            sameDay: '[  ] LT',
	            nextDay: '[  ] LT',
	            nextWeek: 'dddd [ ] LT',
	            lastDay: '[  ] LT',
	            lastWeek: 'dddd [ ] LT',
	            sameElse: 'L'
	        },
	        relativeTime : {
	            future : ' %s',
	            past : ' %s',
	            s : '',
	            m : '',
	            mm : '%d ',
	            h : '',
	            hh : '%d ',
	            d : '',
	            dd : '%d ',
	            M : '',
	            MM : '%d ',
	            y : '',
	            yy : '%d '
	        },
	        week : {
	            dow : 6, // Saturday is the first day of the week.
	            doy : 12  // The week that contains Jan 1st is the first week of the year.
	        }
	    });

	    return ar_ma;

	}));

/***/ },
/* 61 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Arabic Saudi Arabia (ar-sa)
	//! author : Suhail Alkowaileet : https://github.com/xsoh

	(function (global, factory) {
	    true ? factory(__webpack_require__(56)) :
	   typeof define === 'function' && define.amd ? define(['moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';


	    var symbolMap = {
	        '1': '',
	        '2': '',
	        '3': '',
	        '4': '',
	        '5': '',
	        '6': '',
	        '7': '',
	        '8': '',
	        '9': '',
	        '0': ''
	    }, numberMap = {
	        '': '1',
	        '': '2',
	        '': '3',
	        '': '4',
	        '': '5',
	        '': '6',
	        '': '7',
	        '': '8',
	        '': '9',
	        '': '0'
	    };

	    var ar_sa = moment.defineLocale('ar-sa', {
	        months : '___________'.split('_'),
	        monthsShort : '___________'.split('_'),
	        weekdays : '______'.split('_'),
	        weekdaysShort : '______'.split('_'),
	        weekdaysMin : '______'.split('_'),
	        longDateFormat : {
	            LT : 'HH:mm',
	            LTS : 'HH:mm:ss',
	            L : 'DD/MM/YYYY',
	            LL : 'D MMMM YYYY',
	            LLL : 'D MMMM YYYY HH:mm',
	            LLLL : 'dddd D MMMM YYYY HH:mm'
	        },
	        meridiemParse: /|/,
	        isPM : function (input) {
	            return '' === input;
	        },
	        meridiem : function (hour, minute, isLower) {
	            if (hour < 12) {
	                return '';
	            } else {
	                return '';
	            }
	        },
	        calendar : {
	            sameDay: '[  ] LT',
	            nextDay: '[  ] LT',
	            nextWeek: 'dddd [ ] LT',
	            lastDay: '[  ] LT',
	            lastWeek: 'dddd [ ] LT',
	            sameElse: 'L'
	        },
	        relativeTime : {
	            future : ' %s',
	            past : ' %s',
	            s : '',
	            m : '',
	            mm : '%d ',
	            h : '',
	            hh : '%d ',
	            d : '',
	            dd : '%d ',
	            M : '',
	            MM : '%d ',
	            y : '',
	            yy : '%d '
	        },
	        preparse: function (string) {
	            return string.replace(/[]/g, function (match) {
	                return numberMap[match];
	            }).replace(//g, ',');
	        },
	        postformat: function (string) {
	            return string.replace(/\d/g, function (match) {
	                return symbolMap[match];
	            }).replace(/,/g, '');
	        },
	        week : {
	            dow : 6, // Saturday is the first day of the week.
	            doy : 12  // The week that contains Jan 1st is the first week of the year.
	        }
	    });

	    return ar_sa;

	}));

/***/ },
/* 62 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale  : Tunisian Arabic (ar-tn)

	(function (global, factory) {
	    true ? factory(__webpack_require__(56)) :
	   typeof define === 'function' && define.amd ? define(['moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';


	    var ar_tn = moment.defineLocale('ar-tn', {
	        months: '___________'.split('_'),
	        monthsShort: '___________'.split('_'),
	        weekdays: '______'.split('_'),
	        weekdaysShort: '______'.split('_'),
	        weekdaysMin: '______'.split('_'),
	        longDateFormat: {
	            LT: 'HH:mm',
	            LTS: 'HH:mm:ss',
	            L: 'DD/MM/YYYY',
	            LL: 'D MMMM YYYY',
	            LLL: 'D MMMM YYYY HH:mm',
	            LLLL: 'dddd D MMMM YYYY HH:mm'
	        },
	        calendar: {
	            sameDay: '[  ] LT',
	            nextDay: '[  ] LT',
	            nextWeek: 'dddd [ ] LT',
	            lastDay: '[  ] LT',
	            lastWeek: 'dddd [ ] LT',
	            sameElse: 'L'
	        },
	        relativeTime: {
	            future: ' %s',
	            past: ' %s',
	            s: '',
	            m: '',
	            mm: '%d ',
	            h: '',
	            hh: '%d ',
	            d: '',
	            dd: '%d ',
	            M: '',
	            MM: '%d ',
	            y: '',
	            yy: '%d '
	        },
	        week: {
	            dow: 1, // Monday is the first day of the week.
	            doy: 4 // The week that contains Jan 4th is the first week of the year.
	        }
	    });

	    return ar_tn;

	}));

/***/ },
/* 63 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : azerbaijani (az)
	//! author : topchiyev : https://github.com/topchiyev

	(function (global, factory) {
	    true ? factory(__webpack_require__(56)) :
	   typeof define === 'function' && define.amd ? define(['moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';


	    var suffixes = {
	        1: '-inci',
	        5: '-inci',
	        8: '-inci',
	        70: '-inci',
	        80: '-inci',
	        2: '-nci',
	        7: '-nci',
	        20: '-nci',
	        50: '-nci',
	        3: '-nc',
	        4: '-nc',
	        100: '-nc',
	        6: '-nc',
	        9: '-uncu',
	        10: '-uncu',
	        30: '-uncu',
	        60: '-nc',
	        90: '-nc'
	    };

	    var az = moment.defineLocale('az', {
	        months : 'yanvar_fevral_mart_aprel_may_iyun_iyul_avqust_sentyabr_oktyabr_noyabr_dekabr'.split('_'),
	        monthsShort : 'yan_fev_mar_apr_may_iyn_iyl_avq_sen_okt_noy_dek'.split('_'),
	        weekdays : 'Bazar_Bazar ertsi_rnb axam_rnb_Cm axam_Cm_nb'.split('_'),
	        weekdaysShort : 'Baz_BzE_Ax_r_CAx_Cm_n'.split('_'),
	        weekdaysMin : 'Bz_BE_A__CA_C_'.split('_'),
	        longDateFormat : {
	            LT : 'HH:mm',
	            LTS : 'HH:mm:ss',
	            L : 'DD.MM.YYYY',
	            LL : 'D MMMM YYYY',
	            LLL : 'D MMMM YYYY HH:mm',
	            LLLL : 'dddd, D MMMM YYYY HH:mm'
	        },
	        calendar : {
	            sameDay : '[bugn saat] LT',
	            nextDay : '[sabah saat] LT',
	            nextWeek : '[gln hft] dddd [saat] LT',
	            lastDay : '[dnn] LT',
	            lastWeek : '[ken hft] dddd [saat] LT',
	            sameElse : 'L'
	        },
	        relativeTime : {
	            future : '%s sonra',
	            past : '%s vvl',
	            s : 'birne saniyy',
	            m : 'bir dqiq',
	            mm : '%d dqiq',
	            h : 'bir saat',
	            hh : '%d saat',
	            d : 'bir gn',
	            dd : '%d gn',
	            M : 'bir ay',
	            MM : '%d ay',
	            y : 'bir il',
	            yy : '%d il'
	        },
	        meridiemParse: /gec|shr|gndz|axam/,
	        isPM : function (input) {
	            return /^(gndz|axam)$/.test(input);
	        },
	        meridiem : function (hour, minute, isLower) {
	            if (hour < 4) {
	                return 'gec';
	            } else if (hour < 12) {
	                return 'shr';
	            } else if (hour < 17) {
	                return 'gndz';
	            } else {
	                return 'axam';
	            }
	        },
	        ordinalParse: /\d{1,2}-(nc|inci|nci|nc|nc|uncu)/,
	        ordinal : function (number) {
	            if (number === 0) {  // special case for zero
	                return number + '-nc';
	            }
	            var a = number % 10,
	                b = number % 100 - a,
	                c = number >= 100 ? 100 : null;
	            return number + (suffixes[a] || suffixes[b] || suffixes[c]);
	        },
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 7  // The week that contains Jan 1st is the first week of the year.
	        }
	    });

	    return az;

	}));

/***/ },
/* 64 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : belarusian (be)
	//! author : Dmitry Demidov : https://github.com/demidov91
	//! author: Praleska: http://praleska.pro/
	//! Author : Menelion Elensle : https://github.com/Oire

	(function (global, factory) {
	    true ? factory(__webpack_require__(56)) :
	   typeof define === 'function' && define.amd ? define(['moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';


	    function plural(word, num) {
	        var forms = word.split('_');
	        return num % 10 === 1 && num % 100 !== 11 ? forms[0] : (num % 10 >= 2 && num % 10 <= 4 && (num % 100 < 10 || num % 100 >= 20) ? forms[1] : forms[2]);
	    }
	    function relativeTimeWithPlural(number, withoutSuffix, key) {
	        var format = {
	            'mm': withoutSuffix ? '__' : '__',
	            'hh': withoutSuffix ? '__' : '__',
	            'dd': '__',
	            'MM': '__',
	            'yy': '__'
	        };
	        if (key === 'm') {
	            return withoutSuffix ? '' : '';
	        }
	        else if (key === 'h') {
	            return withoutSuffix ? '' : '';
	        }
	        else {
	            return number + ' ' + plural(format[key], +number);
	        }
	    }
	    function monthsCaseReplace(m, format) {
	        var months = {
	            'nominative': '___________'.split('_'),
	            'accusative': '___________'.split('_')
	        },
	        nounCase = (/D[oD]?(\[[^\[\]]*\]|\s+)+MMMM?/).test(format) ?
	            'accusative' :
	            'nominative';
	        return months[nounCase][m.month()];
	    }
	    function weekdaysCaseReplace(m, format) {
	        var weekdays = {
	            'nominative': '______'.split('_'),
	            'accusative': '______'.split('_')
	        },
	        nounCase = (/\[ ?[] ?(?:|)? ?\] ?dddd/).test(format) ?
	            'accusative' :
	            'nominative';
	        return weekdays[nounCase][m.day()];
	    }

	    var be = moment.defineLocale('be', {
	        months : monthsCaseReplace,
	        monthsShort : '___________'.split('_'),
	        weekdays : weekdaysCaseReplace,
	        weekdaysShort : '______'.split('_'),
	        weekdaysMin : '______'.split('_'),
	        longDateFormat : {
	            LT : 'HH:mm',
	            LTS : 'HH:mm:ss',
	            L : 'DD.MM.YYYY',
	            LL : 'D MMMM YYYY .',
	            LLL : 'D MMMM YYYY ., HH:mm',
	            LLLL : 'dddd, D MMMM YYYY ., HH:mm'
	        },
	        calendar : {
	            sameDay: '[ ] LT',
	            nextDay: '[ ] LT',
	            lastDay: '[ ] LT',
	            nextWeek: function () {
	                return '[] dddd [] LT';
	            },
	            lastWeek: function () {
	                switch (this.day()) {
	                case 0:
	                case 3:
	                case 5:
	                case 6:
	                    return '[ ] dddd [] LT';
	                case 1:
	                case 2:
	                case 4:
	                    return '[ ] dddd [] LT';
	                }
	            },
	            sameElse: 'L'
	        },
	        relativeTime : {
	            future : ' %s',
	            past : '%s ',
	            s : ' ',
	            m : relativeTimeWithPlural,
	            mm : relativeTimeWithPlural,
	            h : relativeTimeWithPlural,
	            hh : relativeTimeWithPlural,
	            d : '',
	            dd : relativeTimeWithPlural,
	            M : '',
	            MM : relativeTimeWithPlural,
	            y : '',
	            yy : relativeTimeWithPlural
	        },
	        meridiemParse: /|||/,
	        isPM : function (input) {
	            return /^(|)$/.test(input);
	        },
	        meridiem : function (hour, minute, isLower) {
	            if (hour < 4) {
	                return '';
	            } else if (hour < 12) {
	                return '';
	            } else if (hour < 17) {
	                return '';
	            } else {
	                return '';
	            }
	        },
	        ordinalParse: /\d{1,2}-(||)/,
	        ordinal: function (number, period) {
	            switch (period) {
	            case 'M':
	            case 'd':
	            case 'DDD':
	            case 'w':
	            case 'W':
	                return (number % 10 === 2 || number % 10 === 3) && (number % 100 !== 12 && number % 100 !== 13) ? number + '-' : number + '-';
	            case 'D':
	                return number + '-';
	            default:
	                return number;
	            }
	        },
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 7  // The week that contains Jan 1st is the first week of the year.
	        }
	    });

	    return be;

	}));

/***/ },
/* 65 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : bulgarian (bg)
	//! author : Krasen Borisov : https://github.com/kraz

	(function (global, factory) {
	    true ? factory(__webpack_require__(56)) :
	   typeof define === 'function' && define.amd ? define(['moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';


	    var bg = moment.defineLocale('bg', {
	        months : '___________'.split('_'),
	        monthsShort : '___________'.split('_'),
	        weekdays : '______'.split('_'),
	        weekdaysShort : '______'.split('_'),
	        weekdaysMin : '______'.split('_'),
	        longDateFormat : {
	            LT : 'H:mm',
	            LTS : 'H:mm:ss',
	            L : 'D.MM.YYYY',
	            LL : 'D MMMM YYYY',
	            LLL : 'D MMMM YYYY H:mm',
	            LLLL : 'dddd, D MMMM YYYY H:mm'
	        },
	        calendar : {
	            sameDay : '[ ] LT',
	            nextDay : '[ ] LT',
	            nextWeek : 'dddd [] LT',
	            lastDay : '[ ] LT',
	            lastWeek : function () {
	                switch (this.day()) {
	                case 0:
	                case 3:
	                case 6:
	                    return '[ ] dddd [] LT';
	                case 1:
	                case 2:
	                case 4:
	                case 5:
	                    return '[ ] dddd [] LT';
	                }
	            },
	            sameElse : 'L'
	        },
	        relativeTime : {
	            future : ' %s',
	            past : ' %s',
	            s : ' ',
	            m : '',
	            mm : '%d ',
	            h : '',
	            hh : '%d ',
	            d : '',
	            dd : '%d ',
	            M : '',
	            MM : '%d ',
	            y : '',
	            yy : '%d '
	        },
	        ordinalParse: /\d{1,2}-(|||||)/,
	        ordinal : function (number) {
	            var lastDigit = number % 10,
	                last2Digits = number % 100;
	            if (number === 0) {
	                return number + '-';
	            } else if (last2Digits === 0) {
	                return number + '-';
	            } else if (last2Digits > 10 && last2Digits < 20) {
	                return number + '-';
	            } else if (lastDigit === 1) {
	                return number + '-';
	            } else if (lastDigit === 2) {
	                return number + '-';
	            } else if (lastDigit === 7 || lastDigit === 8) {
	                return number + '-';
	            } else {
	                return number + '-';
	            }
	        },
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 7  // The week that contains Jan 1st is the first week of the year.
	        }
	    });

	    return bg;

	}));

/***/ },
/* 66 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Bengali (bn)
	//! author : Kaushik Gandhi : https://github.com/kaushikgandhi

	(function (global, factory) {
	    true ? factory(__webpack_require__(56)) :
	   typeof define === 'function' && define.amd ? define(['moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';


	    var symbolMap = {
	        '1': '',
	        '2': '',
	        '3': '',
	        '4': '',
	        '5': '',
	        '6': '',
	        '7': '',
	        '8': '',
	        '9': '',
	        '0': ''
	    },
	    numberMap = {
	        '': '1',
	        '': '2',
	        '': '3',
	        '': '4',
	        '': '5',
	        '': '6',
	        '': '7',
	        '': '8',
	        '': '9',
	        '': '0'
	    };

	    var bn = moment.defineLocale('bn', {
	        months : '___________'.split('_'),
	        monthsShort : '___________'.split('_'),
	        weekdays : '______'.split('_'),
	        weekdaysShort : '______'.split('_'),
	        weekdaysMin : '______'.split('_'),
	        longDateFormat : {
	            LT : 'A h:mm ',
	            LTS : 'A h:mm:ss ',
	            L : 'DD/MM/YYYY',
	            LL : 'D MMMM YYYY',
	            LLL : 'D MMMM YYYY, A h:mm ',
	            LLLL : 'dddd, D MMMM YYYY, A h:mm '
	        },
	        calendar : {
	            sameDay : '[] LT',
	            nextDay : '[] LT',
	            nextWeek : 'dddd, LT',
	            lastDay : '[] LT',
	            lastWeek : '[] dddd, LT',
	            sameElse : 'L'
	        },
	        relativeTime : {
	            future : '%s ',
	            past : '%s ',
	            s : ' ',
	            m : ' ',
	            mm : '%d ',
	            h : ' ',
	            hh : '%d ',
	            d : ' ',
	            dd : '%d ',
	            M : ' ',
	            MM : '%d ',
	            y : ' ',
	            yy : '%d '
	        },
	        preparse: function (string) {
	            return string.replace(/[]/g, function (match) {
	                return numberMap[match];
	            });
	        },
	        postformat: function (string) {
	            return string.replace(/\d/g, function (match) {
	                return symbolMap[match];
	            });
	        },
	        meridiemParse: /||||/,
	        isPM: function (input) {
	            return /^(||)$/.test(input);
	        },
	        //Bengali is a vast language its spoken
	        //in different forms in various parts of the world.
	        //I have just generalized with most common one used
	        meridiem : function (hour, minute, isLower) {
	            if (hour < 4) {
	                return '';
	            } else if (hour < 10) {
	                return '';
	            } else if (hour < 17) {
	                return '';
	            } else if (hour < 20) {
	                return '';
	            } else {
	                return '';
	            }
	        },
	        week : {
	            dow : 0, // Sunday is the first day of the week.
	            doy : 6  // The week that contains Jan 1st is the first week of the year.
	        }
	    });

	    return bn;

	}));

/***/ },
/* 67 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : tibetan (bo)
	//! author : Thupten N. Chakrishar : https://github.com/vajradog

	(function (global, factory) {
	    true ? factory(__webpack_require__(56)) :
	   typeof define === 'function' && define.amd ? define(['moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';


	    var symbolMap = {
	        '1': '',
	        '2': '',
	        '3': '',
	        '4': '',
	        '5': '',
	        '6': '',
	        '7': '',
	        '8': '',
	        '9': '',
	        '0': ''
	    },
	    numberMap = {
	        '': '1',
	        '': '2',
	        '': '3',
	        '': '4',
	        '': '5',
	        '': '6',
	        '': '7',
	        '': '8',
	        '': '9',
	        '': '0'
	    };

	    var bo = moment.defineLocale('bo', {
	        months : '___________'.split('_'),
	        monthsShort : '___________'.split('_'),
	        weekdays : '______'.split('_'),
	        weekdaysShort : '______'.split('_'),
	        weekdaysMin : '______'.split('_'),
	        longDateFormat : {
	            LT : 'A h:mm',
	            LTS : 'A h:mm:ss',
	            L : 'DD/MM/YYYY',
	            LL : 'D MMMM YYYY',
	            LLL : 'D MMMM YYYY, A h:mm',
	            LLLL : 'dddd, D MMMM YYYY, A h:mm'
	        },
	        calendar : {
	            sameDay : '[] LT',
	            nextDay : '[] LT',
	            nextWeek : '[], LT',
	            lastDay : '[] LT',
	            lastWeek : '[] dddd, LT',
	            sameElse : 'L'
	        },
	        relativeTime : {
	            future : '%s ',
	            past : '%s ',
	            s : '',
	            m : '',
	            mm : '%d ',
	            h : '',
	            hh : '%d ',
	            d : '',
	            dd : '%d ',
	            M : '',
	            MM : '%d ',
	            y : '',
	            yy : '%d '
	        },
	        preparse: function (string) {
	            return string.replace(/[]/g, function (match) {
	                return numberMap[match];
	            });
	        },
	        postformat: function (string) {
	            return string.replace(/\d/g, function (match) {
	                return symbolMap[match];
	            });
	        },
	        meridiemParse: /||||/,
	        isPM: function (input) {
	            return /^(||)$/.test(input);
	        },
	        meridiem : function (hour, minute, isLower) {
	            if (hour < 4) {
	                return '';
	            } else if (hour < 10) {
	                return '';
	            } else if (hour < 17) {
	                return '';
	            } else if (hour < 20) {
	                return '';
	            } else {
	                return '';
	            }
	        },
	        week : {
	            dow : 0, // Sunday is the first day of the week.
	            doy : 6  // The week that contains Jan 1st is the first week of the year.
	        }
	    });

	    return bo;

	}));

/***/ },
/* 68 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : breton (br)
	//! author : Jean-Baptiste Le Duigou : https://github.com/jbleduigou

	(function (global, factory) {
	    true ? factory(__webpack_require__(56)) :
	   typeof define === 'function' && define.amd ? define(['moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';


	    function relativeTimeWithMutation(number, withoutSuffix, key) {
	        var format = {
	            'mm': 'munutenn',
	            'MM': 'miz',
	            'dd': 'devezh'
	        };
	        return number + ' ' + mutation(format[key], number);
	    }
	    function specialMutationForYears(number) {
	        switch (lastNumber(number)) {
	        case 1:
	        case 3:
	        case 4:
	        case 5:
	        case 9:
	            return number + ' bloaz';
	        default:
	            return number + ' vloaz';
	        }
	    }
	    function lastNumber(number) {
	        if (number > 9) {
	            return lastNumber(number % 10);
	        }
	        return number;
	    }
	    function mutation(text, number) {
	        if (number === 2) {
	            return softMutation(text);
	        }
	        return text;
	    }
	    function softMutation(text) {
	        var mutationTable = {
	            'm': 'v',
	            'b': 'v',
	            'd': 'z'
	        };
	        if (mutationTable[text.charAt(0)] === undefined) {
	            return text;
	        }
	        return mutationTable[text.charAt(0)] + text.substring(1);
	    }

	    var br = moment.defineLocale('br', {
	        months : 'Genver_C\'hwevrer_Meurzh_Ebrel_Mae_Mezheven_Gouere_Eost_Gwengolo_Here_Du_Kerzu'.split('_'),
	        monthsShort : 'Gen_C\'hwe_Meu_Ebr_Mae_Eve_Gou_Eos_Gwe_Her_Du_Ker'.split('_'),
	        weekdays : 'Sul_Lun_Meurzh_Merc\'her_Yaou_Gwener_Sadorn'.split('_'),
	        weekdaysShort : 'Sul_Lun_Meu_Mer_Yao_Gwe_Sad'.split('_'),
	        weekdaysMin : 'Su_Lu_Me_Mer_Ya_Gw_Sa'.split('_'),
	        longDateFormat : {
	            LT : 'h[e]mm A',
	            LTS : 'h[e]mm:ss A',
	            L : 'DD/MM/YYYY',
	            LL : 'D [a viz] MMMM YYYY',
	            LLL : 'D [a viz] MMMM YYYY h[e]mm A',
	            LLLL : 'dddd, D [a viz] MMMM YYYY h[e]mm A'
	        },
	        calendar : {
	            sameDay : '[Hiziv da] LT',
	            nextDay : '[Warc\'hoazh da] LT',
	            nextWeek : 'dddd [da] LT',
	            lastDay : '[Dec\'h da] LT',
	            lastWeek : 'dddd [paset da] LT',
	            sameElse : 'L'
	        },
	        relativeTime : {
	            future : 'a-benn %s',
	            past : '%s \'zo',
	            s : 'un nebeud segondenno',
	            m : 'ur vunutenn',
	            mm : relativeTimeWithMutation,
	            h : 'un eur',
	            hh : '%d eur',
	            d : 'un devezh',
	            dd : relativeTimeWithMutation,
	            M : 'ur miz',
	            MM : relativeTimeWithMutation,
	            y : 'ur bloaz',
	            yy : specialMutationForYears
	        },
	        ordinalParse: /\d{1,2}(a|vet)/,
	        ordinal : function (number) {
	            var output = (number === 1) ? 'a' : 'vet';
	            return number + output;
	        },
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 4  // The week that contains Jan 4th is the first week of the year.
	        }
	    });

	    return br;

	}));

/***/ },
/* 69 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : bosnian (bs)
	//! author : Nedim Cholich : https://github.com/frontyard
	//! based on (hr) translation by Bojan Markovi

	(function (global, factory) {
	    true ? factory(__webpack_require__(56)) :
	   typeof define === 'function' && define.amd ? define(['moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';


	    function translate(number, withoutSuffix, key) {
	        var result = number + ' ';
	        switch (key) {
	        case 'm':
	            return withoutSuffix ? 'jedna minuta' : 'jedne minute';
	        case 'mm':
	            if (number === 1) {
	                result += 'minuta';
	            } else if (number === 2 || number === 3 || number === 4) {
	                result += 'minute';
	            } else {
	                result += 'minuta';
	            }
	            return result;
	        case 'h':
	            return withoutSuffix ? 'jedan sat' : 'jednog sata';
	        case 'hh':
	            if (number === 1) {
	                result += 'sat';
	            } else if (number === 2 || number === 3 || number === 4) {
	                result += 'sata';
	            } else {
	                result += 'sati';
	            }
	            return result;
	        case 'dd':
	            if (number === 1) {
	                result += 'dan';
	            } else {
	                result += 'dana';
	            }
	            return result;
	        case 'MM':
	            if (number === 1) {
	                result += 'mjesec';
	            } else if (number === 2 || number === 3 || number === 4) {
	                result += 'mjeseca';
	            } else {
	                result += 'mjeseci';
	            }
	            return result;
	        case 'yy':
	            if (number === 1) {
	                result += 'godina';
	            } else if (number === 2 || number === 3 || number === 4) {
	                result += 'godine';
	            } else {
	                result += 'godina';
	            }
	            return result;
	        }
	    }

	    var bs = moment.defineLocale('bs', {
	        months : 'januar_februar_mart_april_maj_juni_juli_august_septembar_oktobar_novembar_decembar'.split('_'),
	        monthsShort : 'jan._feb._mar._apr._maj._jun._jul._aug._sep._okt._nov._dec.'.split('_'),
	        weekdays : 'nedjelja_ponedjeljak_utorak_srijeda_etvrtak_petak_subota'.split('_'),
	        weekdaysShort : 'ned._pon._uto._sri._et._pet._sub.'.split('_'),
	        weekdaysMin : 'ne_po_ut_sr_e_pe_su'.split('_'),
	        longDateFormat : {
	            LT : 'H:mm',
	            LTS : 'H:mm:ss',
	            L : 'DD. MM. YYYY',
	            LL : 'D. MMMM YYYY',
	            LLL : 'D. MMMM YYYY H:mm',
	            LLLL : 'dddd, D. MMMM YYYY H:mm'
	        },
	        calendar : {
	            sameDay  : '[danas u] LT',
	            nextDay  : '[sutra u] LT',
	            nextWeek : function () {
	                switch (this.day()) {
	                case 0:
	                    return '[u] [nedjelju] [u] LT';
	                case 3:
	                    return '[u] [srijedu] [u] LT';
	                case 6:
	                    return '[u] [subotu] [u] LT';
	                case 1:
	                case 2:
	                case 4:
	                case 5:
	                    return '[u] dddd [u] LT';
	                }
	            },
	            lastDay  : '[juer u] LT',
	            lastWeek : function () {
	                switch (this.day()) {
	                case 0:
	                case 3:
	                    return '[prolu] dddd [u] LT';
	                case 6:
	                    return '[prole] [subote] [u] LT';
	                case 1:
	                case 2:
	                case 4:
	                case 5:
	                    return '[proli] dddd [u] LT';
	                }
	            },
	            sameElse : 'L'
	        },
	        relativeTime : {
	            future : 'za %s',
	            past   : 'prije %s',
	            s      : 'par sekundi',
	            m      : translate,
	            mm     : translate,
	            h      : translate,
	            hh     : translate,
	            d      : 'dan',
	            dd     : translate,
	            M      : 'mjesec',
	            MM     : translate,
	            y      : 'godinu',
	            yy     : translate
	        },
	        ordinalParse: /\d{1,2}\./,
	        ordinal : '%d.',
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 7  // The week that contains Jan 1st is the first week of the year.
	        }
	    });

	    return bs;

	}));

/***/ },
/* 70 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : catalan (ca)
	//! author : Juan G. Hurtado : https://github.com/juanghurtado

	(function (global, factory) {
	    true ? factory(__webpack_require__(56)) :
	   typeof define === 'function' && define.amd ? define(['moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';


	    var ca = moment.defineLocale('ca', {
	        months : 'gener_febrer_mar_abril_maig_juny_juliol_agost_setembre_octubre_novembre_desembre'.split('_'),
	        monthsShort : 'gen._febr._mar._abr._mai._jun._jul._ag._set._oct._nov._des.'.split('_'),
	        weekdays : 'diumenge_dilluns_dimarts_dimecres_dijous_divendres_dissabte'.split('_'),
	        weekdaysShort : 'dg._dl._dt._dc._dj._dv._ds.'.split('_'),
	        weekdaysMin : 'Dg_Dl_Dt_Dc_Dj_Dv_Ds'.split('_'),
	        longDateFormat : {
	            LT : 'H:mm',
	            LTS : 'LT:ss',
	            L : 'DD/MM/YYYY',
	            LL : 'D MMMM YYYY',
	            LLL : 'D MMMM YYYY H:mm',
	            LLLL : 'dddd D MMMM YYYY H:mm'
	        },
	        calendar : {
	            sameDay : function () {
	                return '[avui a ' + ((this.hours() !== 1) ? 'les' : 'la') + '] LT';
	            },
	            nextDay : function () {
	                return '[dem a ' + ((this.hours() !== 1) ? 'les' : 'la') + '] LT';
	            },
	            nextWeek : function () {
	                return 'dddd [a ' + ((this.hours() !== 1) ? 'les' : 'la') + '] LT';
	            },
	            lastDay : function () {
	                return '[ahir a ' + ((this.hours() !== 1) ? 'les' : 'la') + '] LT';
	            },
	            lastWeek : function () {
	                return '[el] dddd [passat a ' + ((this.hours() !== 1) ? 'les' : 'la') + '] LT';
	            },
	            sameElse : 'L'
	        },
	        relativeTime : {
	            future : 'en %s',
	            past : 'fa %s',
	            s : 'uns segons',
	            m : 'un minut',
	            mm : '%d minuts',
	            h : 'una hora',
	            hh : '%d hores',
	            d : 'un dia',
	            dd : '%d dies',
	            M : 'un mes',
	            MM : '%d mesos',
	            y : 'un any',
	            yy : '%d anys'
	        },
	        ordinalParse: /\d{1,2}(r|n|t||a)/,
	        ordinal : function (number, period) {
	            var output = (number === 1) ? 'r' :
	                (number === 2) ? 'n' :
	                (number === 3) ? 'r' :
	                (number === 4) ? 't' : '';
	            if (period === 'w' || period === 'W') {
	                output = 'a';
	            }
	            return number + output;
	        },
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 4  // The week that contains Jan 4th is the first week of the year.
	        }
	    });

	    return ca;

	}));

/***/ },
/* 71 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : czech (cs)
	//! author : petrbela : https://github.com/petrbela

	(function (global, factory) {
	    true ? factory(__webpack_require__(56)) :
	   typeof define === 'function' && define.amd ? define(['moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';


	    var months = 'leden_nor_bezen_duben_kvten_erven_ervenec_srpen_z_jen_listopad_prosinec'.split('_'),
	        monthsShort = 'led_no_be_dub_kv_vn_vc_srp_z_j_lis_pro'.split('_');
	    function plural(n) {
	        return (n > 1) && (n < 5) && (~~(n / 10) !== 1);
	    }
	    function translate(number, withoutSuffix, key, isFuture) {
	        var result = number + ' ';
	        switch (key) {
	        case 's':  // a few seconds / in a few seconds / a few seconds ago
	            return (withoutSuffix || isFuture) ? 'pr sekund' : 'pr sekundami';
	        case 'm':  // a minute / in a minute / a minute ago
	            return withoutSuffix ? 'minuta' : (isFuture ? 'minutu' : 'minutou');
	        case 'mm': // 9 minutes / in 9 minutes / 9 minutes ago
	            if (withoutSuffix || isFuture) {
	                return result + (plural(number) ? 'minuty' : 'minut');
	            } else {
	                return result + 'minutami';
	            }
	            break;
	        case 'h':  // an hour / in an hour / an hour ago
	            return withoutSuffix ? 'hodina' : (isFuture ? 'hodinu' : 'hodinou');
	        case 'hh': // 9 hours / in 9 hours / 9 hours ago
	            if (withoutSuffix || isFuture) {
	                return result + (plural(number) ? 'hodiny' : 'hodin');
	            } else {
	                return result + 'hodinami';
	            }
	            break;
	        case 'd':  // a day / in a day / a day ago
	            return (withoutSuffix || isFuture) ? 'den' : 'dnem';
	        case 'dd': // 9 days / in 9 days / 9 days ago
	            if (withoutSuffix || isFuture) {
	                return result + (plural(number) ? 'dny' : 'dn');
	            } else {
	                return result + 'dny';
	            }
	            break;
	        case 'M':  // a month / in a month / a month ago
	            return (withoutSuffix || isFuture) ? 'msc' : 'mscem';
	        case 'MM': // 9 months / in 9 months / 9 months ago
	            if (withoutSuffix || isFuture) {
	                return result + (plural(number) ? 'msce' : 'msc');
	            } else {
	                return result + 'msci';
	            }
	            break;
	        case 'y':  // a year / in a year / a year ago
	            return (withoutSuffix || isFuture) ? 'rok' : 'rokem';
	        case 'yy': // 9 years / in 9 years / 9 years ago
	            if (withoutSuffix || isFuture) {
	                return result + (plural(number) ? 'roky' : 'let');
	            } else {
	                return result + 'lety';
	            }
	            break;
	        }
	    }

	    var cs = moment.defineLocale('cs', {
	        months : months,
	        monthsShort : monthsShort,
	        monthsParse : (function (months, monthsShort) {
	            var i, _monthsParse = [];
	            for (i = 0; i < 12; i++) {
	                // use custom parser to solve problem with July (ervenec)
	                _monthsParse[i] = new RegExp('^' + months[i] + '$|^' + monthsShort[i] + '$', 'i');
	            }
	            return _monthsParse;
	        }(months, monthsShort)),
	        weekdays : 'nedle_pondl_ter_steda_tvrtek_ptek_sobota'.split('_'),
	        weekdaysShort : 'ne_po_t_st_t_p_so'.split('_'),
	        weekdaysMin : 'ne_po_t_st_t_p_so'.split('_'),
	        longDateFormat : {
	            LT: 'H:mm',
	            LTS : 'H:mm:ss',
	            L : 'DD.MM.YYYY',
	            LL : 'D. MMMM YYYY',
	            LLL : 'D. MMMM YYYY H:mm',
	            LLLL : 'dddd D. MMMM YYYY H:mm'
	        },
	        calendar : {
	            sameDay: '[dnes v] LT',
	            nextDay: '[ztra v] LT',
	            nextWeek: function () {
	                switch (this.day()) {
	                case 0:
	                    return '[v nedli v] LT';
	                case 1:
	                case 2:
	                    return '[v] dddd [v] LT';
	                case 3:
	                    return '[ve stedu v] LT';
	                case 4:
	                    return '[ve tvrtek v] LT';
	                case 5:
	                    return '[v ptek v] LT';
	                case 6:
	                    return '[v sobotu v] LT';
	                }
	            },
	            lastDay: '[vera v] LT',
	            lastWeek: function () {
	                switch (this.day()) {
	                case 0:
	                    return '[minulou nedli v] LT';
	                case 1:
	                case 2:
	                    return '[minul] dddd [v] LT';
	                case 3:
	                    return '[minulou stedu v] LT';
	                case 4:
	                case 5:
	                    return '[minul] dddd [v] LT';
	                case 6:
	                    return '[minulou sobotu v] LT';
	                }
	            },
	            sameElse: 'L'
	        },
	        relativeTime : {
	            future : 'za %s',
	            past : 'ped %s',
	            s : translate,
	            m : translate,
	            mm : translate,
	            h : translate,
	            hh : translate,
	            d : translate,
	            dd : translate,
	            M : translate,
	            MM : translate,
	            y : translate,
	            yy : translate
	        },
	        ordinalParse : /\d{1,2}\./,
	        ordinal : '%d.',
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 4  // The week that contains Jan 4th is the first week of the year.
	        }
	    });

	    return cs;

	}));

/***/ },
/* 72 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : chuvash (cv)
	//! author : Anatoly Mironov : https://github.com/mirontoli

	(function (global, factory) {
	    true ? factory(__webpack_require__(56)) :
	   typeof define === 'function' && define.amd ? define(['moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';


	    var cv = moment.defineLocale('cv', {
	        months : '___________'.split('_'),
	        monthsShort : '___________'.split('_'),
	        weekdays : '______'.split('_'),
	        weekdaysShort : '______'.split('_'),
	        weekdaysMin : '______'.split('_'),
	        longDateFormat : {
	            LT : 'HH:mm',
	            LTS : 'HH:mm:ss',
	            L : 'DD-MM-YYYY',
	            LL : 'YYYY [] MMMM [] D[-]',
	            LLL : 'YYYY [] MMMM [] D[-], HH:mm',
	            LLLL : 'dddd, YYYY [] MMMM [] D[-], HH:mm'
	        },
	        calendar : {
	            sameDay: '[] LT []',
	            nextDay: '[] LT []',
	            lastDay: '[] LT []',
	            nextWeek: '[] dddd LT []',
	            lastWeek: '[] dddd LT []',
	            sameElse: 'L'
	        },
	        relativeTime : {
	            future : function (output) {
	                var affix = /$/i.exec(output) ? '' : /$/i.exec(output) ? '' : '';
	                return output + affix;
	            },
	            past : '%s ',
	            s : '- ',
	            m : ' ',
	            mm : '%d ',
	            h : ' ',
	            hh : '%d ',
	            d : ' ',
	            dd : '%d ',
	            M : ' ',
	            MM : '%d ',
	            y : ' ',
	            yy : '%d '
	        },
	        ordinalParse: /\d{1,2}-/,
	        ordinal : '%d-',
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 7  // The week that contains Jan 1st is the first week of the year.
	        }
	    });

	    return cv;

	}));

/***/ },
/* 73 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Welsh (cy)
	//! author : Robert Allen

	(function (global, factory) {
	    true ? factory(__webpack_require__(56)) :
	   typeof define === 'function' && define.amd ? define(['moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';


	    var cy = moment.defineLocale('cy', {
	        months: 'Ionawr_Chwefror_Mawrth_Ebrill_Mai_Mehefin_Gorffennaf_Awst_Medi_Hydref_Tachwedd_Rhagfyr'.split('_'),
	        monthsShort: 'Ion_Chwe_Maw_Ebr_Mai_Meh_Gor_Aws_Med_Hyd_Tach_Rhag'.split('_'),
	        weekdays: 'Dydd Sul_Dydd Llun_Dydd Mawrth_Dydd Mercher_Dydd Iau_Dydd Gwener_Dydd Sadwrn'.split('_'),
	        weekdaysShort: 'Sul_Llun_Maw_Mer_Iau_Gwe_Sad'.split('_'),
	        weekdaysMin: 'Su_Ll_Ma_Me_Ia_Gw_Sa'.split('_'),
	        // time formats are the same as en-gb
	        longDateFormat: {
	            LT: 'HH:mm',
	            LTS : 'HH:mm:ss',
	            L: 'DD/MM/YYYY',
	            LL: 'D MMMM YYYY',
	            LLL: 'D MMMM YYYY HH:mm',
	            LLLL: 'dddd, D MMMM YYYY HH:mm'
	        },
	        calendar: {
	            sameDay: '[Heddiw am] LT',
	            nextDay: '[Yfory am] LT',
	            nextWeek: 'dddd [am] LT',
	            lastDay: '[Ddoe am] LT',
	            lastWeek: 'dddd [diwethaf am] LT',
	            sameElse: 'L'
	        },
	        relativeTime: {
	            future: 'mewn %s',
	            past: '%s yn l',
	            s: 'ychydig eiliadau',
	            m: 'munud',
	            mm: '%d munud',
	            h: 'awr',
	            hh: '%d awr',
	            d: 'diwrnod',
	            dd: '%d diwrnod',
	            M: 'mis',
	            MM: '%d mis',
	            y: 'blwyddyn',
	            yy: '%d flynedd'
	        },
	        ordinalParse: /\d{1,2}(fed|ain|af|il|ydd|ed|eg)/,
	        // traditional ordinal numbers above 31 are not commonly used in colloquial Welsh
	        ordinal: function (number) {
	            var b = number,
	                output = '',
	                lookup = [
	                    '', 'af', 'il', 'ydd', 'ydd', 'ed', 'ed', 'ed', 'fed', 'fed', 'fed', // 1af to 10fed
	                    'eg', 'fed', 'eg', 'eg', 'fed', 'eg', 'eg', 'fed', 'eg', 'fed' // 11eg to 20fed
	                ];
	            if (b > 20) {
	                if (b === 40 || b === 50 || b === 60 || b === 80 || b === 100) {
	                    output = 'fed'; // not 30ain, 70ain or 90ain
	                } else {
	                    output = 'ain';
	                }
	            } else if (b > 0) {
	                output = lookup[b];
	            }
	            return number + output;
	        },
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 4  // The week that contains Jan 4th is the first week of the year.
	        }
	    });

	    return cy;

	}));

/***/ },
/* 74 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : danish (da)
	//! author : Ulrik Nielsen : https://github.com/mrbase

	(function (global, factory) {
	    true ? factory(__webpack_require__(56)) :
	   typeof define === 'function' && define.amd ? define(['moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';


	    var da = moment.defineLocale('da', {
	        months : 'januar_februar_marts_april_maj_juni_juli_august_september_oktober_november_december'.split('_'),
	        monthsShort : 'jan_feb_mar_apr_maj_jun_jul_aug_sep_okt_nov_dec'.split('_'),
	        weekdays : 'sndag_mandag_tirsdag_onsdag_torsdag_fredag_lrdag'.split('_'),
	        weekdaysShort : 'sn_man_tir_ons_tor_fre_lr'.split('_'),
	        weekdaysMin : 's_ma_ti_on_to_fr_l'.split('_'),
	        longDateFormat : {
	            LT : 'HH:mm',
	            LTS : 'HH:mm:ss',
	            L : 'DD/MM/YYYY',
	            LL : 'D. MMMM YYYY',
	            LLL : 'D. MMMM YYYY HH:mm',
	            LLLL : 'dddd [d.] D. MMMM YYYY HH:mm'
	        },
	        calendar : {
	            sameDay : '[I dag kl.] LT',
	            nextDay : '[I morgen kl.] LT',
	            nextWeek : 'dddd [kl.] LT',
	            lastDay : '[I gr kl.] LT',
	            lastWeek : '[sidste] dddd [kl] LT',
	            sameElse : 'L'
	        },
	        relativeTime : {
	            future : 'om %s',
	            past : '%s siden',
	            s : 'f sekunder',
	            m : 'et minut',
	            mm : '%d minutter',
	            h : 'en time',
	            hh : '%d timer',
	            d : 'en dag',
	            dd : '%d dage',
	            M : 'en mned',
	            MM : '%d mneder',
	            y : 'et r',
	            yy : '%d r'
	        },
	        ordinalParse: /\d{1,2}\./,
	        ordinal : '%d.',
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 4  // The week that contains Jan 4th is the first week of the year.
	        }
	    });

	    return da;

	}));

/***/ },
/* 75 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : german (de)
	//! author : lluchs : https://github.com/lluchs
	//! author: Menelion Elensle: https://github.com/Oire

	(function (global, factory) {
	    true ? factory(__webpack_require__(56)) :
	   typeof define === 'function' && define.amd ? define(['moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';


	    function processRelativeTime(number, withoutSuffix, key, isFuture) {
	        var format = {
	            'm': ['eine Minute', 'einer Minute'],
	            'h': ['eine Stunde', 'einer Stunde'],
	            'd': ['ein Tag', 'einem Tag'],
	            'dd': [number + ' Tage', number + ' Tagen'],
	            'M': ['ein Monat', 'einem Monat'],
	            'MM': [number + ' Monate', number + ' Monaten'],
	            'y': ['ein Jahr', 'einem Jahr'],
	            'yy': [number + ' Jahre', number + ' Jahren']
	        };
	        return withoutSuffix ? format[key][0] : format[key][1];
	    }

	    var de = moment.defineLocale('de', {
	        months : 'Januar_Februar_Mrz_April_Mai_Juni_Juli_August_September_Oktober_November_Dezember'.split('_'),
	        monthsShort : 'Jan._Febr._Mrz._Apr._Mai_Jun._Jul._Aug._Sept._Okt._Nov._Dez.'.split('_'),
	        weekdays : 'Sonntag_Montag_Dienstag_Mittwoch_Donnerstag_Freitag_Samstag'.split('_'),
	        weekdaysShort : 'So._Mo._Di._Mi._Do._Fr._Sa.'.split('_'),
	        weekdaysMin : 'So_Mo_Di_Mi_Do_Fr_Sa'.split('_'),
	        longDateFormat : {
	            LT: 'HH:mm',
	            LTS: 'HH:mm:ss',
	            L : 'DD.MM.YYYY',
	            LL : 'D. MMMM YYYY',
	            LLL : 'D. MMMM YYYY HH:mm',
	            LLLL : 'dddd, D. MMMM YYYY HH:mm'
	        },
	        calendar : {
	            sameDay: '[Heute um] LT [Uhr]',
	            sameElse: 'L',
	            nextDay: '[Morgen um] LT [Uhr]',
	            nextWeek: 'dddd [um] LT [Uhr]',
	            lastDay: '[Gestern um] LT [Uhr]',
	            lastWeek: '[letzten] dddd [um] LT [Uhr]'
	        },
	        relativeTime : {
	            future : 'in %s',
	            past : 'vor %s',
	            s : 'ein paar Sekunden',
	            m : processRelativeTime,
	            mm : '%d Minuten',
	            h : processRelativeTime,
	            hh : '%d Stunden',
	            d : processRelativeTime,
	            dd : processRelativeTime,
	            M : processRelativeTime,
	            MM : processRelativeTime,
	            y : processRelativeTime,
	            yy : processRelativeTime
	        },
	        ordinalParse: /\d{1,2}\./,
	        ordinal : '%d.',
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 4  // The week that contains Jan 4th is the first week of the year.
	        }
	    });

	    return de;

	}));

/***/ },
/* 76 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : austrian german (de-at)
	//! author : lluchs : https://github.com/lluchs
	//! author: Menelion Elensle: https://github.com/Oire
	//! author : Martin Groller : https://github.com/MadMG

	(function (global, factory) {
	    true ? factory(__webpack_require__(56)) :
	   typeof define === 'function' && define.amd ? define(['moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';


	    function processRelativeTime(number, withoutSuffix, key, isFuture) {
	        var format = {
	            'm': ['eine Minute', 'einer Minute'],
	            'h': ['eine Stunde', 'einer Stunde'],
	            'd': ['ein Tag', 'einem Tag'],
	            'dd': [number + ' Tage', number + ' Tagen'],
	            'M': ['ein Monat', 'einem Monat'],
	            'MM': [number + ' Monate', number + ' Monaten'],
	            'y': ['ein Jahr', 'einem Jahr'],
	            'yy': [number + ' Jahre', number + ' Jahren']
	        };
	        return withoutSuffix ? format[key][0] : format[key][1];
	    }

	    var de_at = moment.defineLocale('de-at', {
	        months : 'Jnner_Februar_Mrz_April_Mai_Juni_Juli_August_September_Oktober_November_Dezember'.split('_'),
	        monthsShort : 'Jn._Febr._Mrz._Apr._Mai_Jun._Jul._Aug._Sept._Okt._Nov._Dez.'.split('_'),
	        weekdays : 'Sonntag_Montag_Dienstag_Mittwoch_Donnerstag_Freitag_Samstag'.split('_'),
	        weekdaysShort : 'So._Mo._Di._Mi._Do._Fr._Sa.'.split('_'),
	        weekdaysMin : 'So_Mo_Di_Mi_Do_Fr_Sa'.split('_'),
	        longDateFormat : {
	            LT: 'HH:mm',
	            LTS: 'HH:mm:ss',
	            L : 'DD.MM.YYYY',
	            LL : 'D. MMMM YYYY',
	            LLL : 'D. MMMM YYYY HH:mm',
	            LLLL : 'dddd, D. MMMM YYYY HH:mm'
	        },
	        calendar : {
	            sameDay: '[Heute um] LT [Uhr]',
	            sameElse: 'L',
	            nextDay: '[Morgen um] LT [Uhr]',
	            nextWeek: 'dddd [um] LT [Uhr]',
	            lastDay: '[Gestern um] LT [Uhr]',
	            lastWeek: '[letzten] dddd [um] LT [Uhr]'
	        },
	        relativeTime : {
	            future : 'in %s',
	            past : 'vor %s',
	            s : 'ein paar Sekunden',
	            m : processRelativeTime,
	            mm : '%d Minuten',
	            h : processRelativeTime,
	            hh : '%d Stunden',
	            d : processRelativeTime,
	            dd : processRelativeTime,
	            M : processRelativeTime,
	            MM : processRelativeTime,
	            y : processRelativeTime,
	            yy : processRelativeTime
	        },
	        ordinalParse: /\d{1,2}\./,
	        ordinal : '%d.',
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 4  // The week that contains Jan 4th is the first week of the year.
	        }
	    });

	    return de_at;

	}));

/***/ },
/* 77 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : modern greek (el)
	//! author : Aggelos Karalias : https://github.com/mehiel

	(function (global, factory) {
	    true ? factory(__webpack_require__(56)) :
	   typeof define === 'function' && define.amd ? define(['moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';


	    var el = moment.defineLocale('el', {
	        monthsNominativeEl : '___________'.split('_'),
	        monthsGenitiveEl : '___________'.split('_'),
	        months : function (momentToFormat, format) {
	            if (/D/.test(format.substring(0, format.indexOf('MMMM')))) { // if there is a day number before 'MMMM'
	                return this._monthsGenitiveEl[momentToFormat.month()];
	            } else {
	                return this._monthsNominativeEl[momentToFormat.month()];
	            }
	        },
	        monthsShort : '___________'.split('_'),
	        weekdays : '______'.split('_'),
	        weekdaysShort : '______'.split('_'),
	        weekdaysMin : '______'.split('_'),
	        meridiem : function (hours, minutes, isLower) {
	            if (hours > 11) {
	                return isLower ? '' : '';
	            } else {
	                return isLower ? '' : '';
	            }
	        },
	        isPM : function (input) {
	            return ((input + '').toLowerCase()[0] === '');
	        },
	        meridiemParse : /[]\.??\.?/i,
	        longDateFormat : {
	            LT : 'h:mm A',
	            LTS : 'h:mm:ss A',
	            L : 'DD/MM/YYYY',
	            LL : 'D MMMM YYYY',
	            LLL : 'D MMMM YYYY h:mm A',
	            LLLL : 'dddd, D MMMM YYYY h:mm A'
	        },
	        calendarEl : {
	            sameDay : '[ {}] LT',
	            nextDay : '[ {}] LT',
	            nextWeek : 'dddd [{}] LT',
	            lastDay : '[ {}] LT',
	            lastWeek : function () {
	                switch (this.day()) {
	                    case 6:
	                        return '[ ] dddd [{}] LT';
	                    default:
	                        return '[ ] dddd [{}] LT';
	                }
	            },
	            sameElse : 'L'
	        },
	        calendar : function (key, mom) {
	            var output = this._calendarEl[key],
	                hours = mom && mom.hours();
	            if (typeof output === 'function') {
	                output = output.apply(mom);
	            }
	            return output.replace('{}', (hours % 12 === 1 ? '' : ''));
	        },
	        relativeTime : {
	            future : ' %s',
	            past : '%s ',
	            s : ' ',
	            m : ' ',
	            mm : '%d ',
	            h : ' ',
	            hh : '%d ',
	            d : ' ',
	            dd : '%d ',
	            M : ' ',
	            MM : '%d ',
	            y : ' ',
	            yy : '%d '
	        },
	        ordinalParse: /\d{1,2}/,
	        ordinal: '%d',
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 4  // The week that contains Jan 4st is the first week of the year.
	        }
	    });

	    return el;

	}));

/***/ },
/* 78 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : australian english (en-au)

	(function (global, factory) {
	    true ? factory(__webpack_require__(56)) :
	   typeof define === 'function' && define.amd ? define(['moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';


	    var en_au = moment.defineLocale('en-au', {
	        months : 'January_February_March_April_May_June_July_August_September_October_November_December'.split('_'),
	        monthsShort : 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_'),
	        weekdays : 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split('_'),
	        weekdaysShort : 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_'),
	        weekdaysMin : 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_'),
	        longDateFormat : {
	            LT : 'h:mm A',
	            LTS : 'h:mm:ss A',
	            L : 'DD/MM/YYYY',
	            LL : 'D MMMM YYYY',
	            LLL : 'D MMMM YYYY h:mm A',
	            LLLL : 'dddd, D MMMM YYYY h:mm A'
	        },
	        calendar : {
	            sameDay : '[Today at] LT',
	            nextDay : '[Tomorrow at] LT',
	            nextWeek : 'dddd [at] LT',
	            lastDay : '[Yesterday at] LT',
	            lastWeek : '[Last] dddd [at] LT',
	            sameElse : 'L'
	        },
	        relativeTime : {
	            future : 'in %s',
	            past : '%s ago',
	            s : 'a few seconds',
	            m : 'a minute',
	            mm : '%d minutes',
	            h : 'an hour',
	            hh : '%d hours',
	            d : 'a day',
	            dd : '%d days',
	            M : 'a month',
	            MM : '%d months',
	            y : 'a year',
	            yy : '%d years'
	        },
	        ordinalParse: /\d{1,2}(st|nd|rd|th)/,
	        ordinal : function (number) {
	            var b = number % 10,
	                output = (~~(number % 100 / 10) === 1) ? 'th' :
	                (b === 1) ? 'st' :
	                (b === 2) ? 'nd' :
	                (b === 3) ? 'rd' : 'th';
	            return number + output;
	        },
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 4  // The week that contains Jan 4th is the first week of the year.
	        }
	    });

	    return en_au;

	}));

/***/ },
/* 79 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : canadian english (en-ca)
	//! author : Jonathan Abourbih : https://github.com/jonbca

	(function (global, factory) {
	    true ? factory(__webpack_require__(56)) :
	   typeof define === 'function' && define.amd ? define(['moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';


	    var en_ca = moment.defineLocale('en-ca', {
	        months : 'January_February_March_April_May_June_July_August_September_October_November_December'.split('_'),
	        monthsShort : 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_'),
	        weekdays : 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split('_'),
	        weekdaysShort : 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_'),
	        weekdaysMin : 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_'),
	        longDateFormat : {
	            LT : 'h:mm A',
	            LTS : 'h:mm:ss A',
	            L : 'YYYY-MM-DD',
	            LL : 'D MMMM, YYYY',
	            LLL : 'D MMMM, YYYY h:mm A',
	            LLLL : 'dddd, D MMMM, YYYY h:mm A'
	        },
	        calendar : {
	            sameDay : '[Today at] LT',
	            nextDay : '[Tomorrow at] LT',
	            nextWeek : 'dddd [at] LT',
	            lastDay : '[Yesterday at] LT',
	            lastWeek : '[Last] dddd [at] LT',
	            sameElse : 'L'
	        },
	        relativeTime : {
	            future : 'in %s',
	            past : '%s ago',
	            s : 'a few seconds',
	            m : 'a minute',
	            mm : '%d minutes',
	            h : 'an hour',
	            hh : '%d hours',
	            d : 'a day',
	            dd : '%d days',
	            M : 'a month',
	            MM : '%d months',
	            y : 'a year',
	            yy : '%d years'
	        },
	        ordinalParse: /\d{1,2}(st|nd|rd|th)/,
	        ordinal : function (number) {
	            var b = number % 10,
	                output = (~~(number % 100 / 10) === 1) ? 'th' :
	                (b === 1) ? 'st' :
	                (b === 2) ? 'nd' :
	                (b === 3) ? 'rd' : 'th';
	            return number + output;
	        }
	    });

	    return en_ca;

	}));

/***/ },
/* 80 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : great britain english (en-gb)
	//! author : Chris Gedrim : https://github.com/chrisgedrim

	(function (global, factory) {
	    true ? factory(__webpack_require__(56)) :
	   typeof define === 'function' && define.amd ? define(['moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';


	    var en_gb = moment.defineLocale('en-gb', {
	        months : 'January_February_March_April_May_June_July_August_September_October_November_December'.split('_'),
	        monthsShort : 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_'),
	        weekdays : 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split('_'),
	        weekdaysShort : 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_'),
	        weekdaysMin : 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_'),
	        longDateFormat : {
	            LT : 'HH:mm',
	            LTS : 'HH:mm:ss',
	            L : 'DD/MM/YYYY',
	            LL : 'D MMMM YYYY',
	            LLL : 'D MMMM YYYY HH:mm',
	            LLLL : 'dddd, D MMMM YYYY HH:mm'
	        },
	        calendar : {
	            sameDay : '[Today at] LT',
	            nextDay : '[Tomorrow at] LT',
	            nextWeek : 'dddd [at] LT',
	            lastDay : '[Yesterday at] LT',
	            lastWeek : '[Last] dddd [at] LT',
	            sameElse : 'L'
	        },
	        relativeTime : {
	            future : 'in %s',
	            past : '%s ago',
	            s : 'a few seconds',
	            m : 'a minute',
	            mm : '%d minutes',
	            h : 'an hour',
	            hh : '%d hours',
	            d : 'a day',
	            dd : '%d days',
	            M : 'a month',
	            MM : '%d months',
	            y : 'a year',
	            yy : '%d years'
	        },
	        ordinalParse: /\d{1,2}(st|nd|rd|th)/,
	        ordinal : function (number) {
	            var b = number % 10,
	                output = (~~(number % 100 / 10) === 1) ? 'th' :
	                (b === 1) ? 'st' :
	                (b === 2) ? 'nd' :
	                (b === 3) ? 'rd' : 'th';
	            return number + output;
	        },
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 4  // The week that contains Jan 4th is the first week of the year.
	        }
	    });

	    return en_gb;

	}));

/***/ },
/* 81 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : esperanto (eo)
	//! author : Colin Dean : https://github.com/colindean
	//! komento: Mi estas malcerta se mi korekte traktis akuzativojn en tiu traduko.
	//!          Se ne, bonvolu korekti kaj avizi min por ke mi povas lerni!

	(function (global, factory) {
	    true ? factory(__webpack_require__(56)) :
	   typeof define === 'function' && define.amd ? define(['moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';


	    var eo = moment.defineLocale('eo', {
	        months : 'januaro_februaro_marto_aprilo_majo_junio_julio_agusto_septembro_oktobro_novembro_decembro'.split('_'),
	        monthsShort : 'jan_feb_mar_apr_maj_jun_jul_ag_sep_okt_nov_dec'.split('_'),
	        weekdays : 'Dimano_Lundo_Mardo_Merkredo_ado_Vendredo_Sabato'.split('_'),
	        weekdaysShort : 'Dim_Lun_Mard_Merk_a_Ven_Sab'.split('_'),
	        weekdaysMin : 'Di_Lu_Ma_Me_a_Ve_Sa'.split('_'),
	        longDateFormat : {
	            LT : 'HH:mm',
	            LTS : 'HH:mm:ss',
	            L : 'YYYY-MM-DD',
	            LL : 'D[-an de] MMMM, YYYY',
	            LLL : 'D[-an de] MMMM, YYYY HH:mm',
	            LLLL : 'dddd, [la] D[-an de] MMMM, YYYY HH:mm'
	        },
	        meridiemParse: /[ap]\.t\.m/i,
	        isPM: function (input) {
	            return input.charAt(0).toLowerCase() === 'p';
	        },
	        meridiem : function (hours, minutes, isLower) {
	            if (hours > 11) {
	                return isLower ? 'p.t.m.' : 'P.T.M.';
	            } else {
	                return isLower ? 'a.t.m.' : 'A.T.M.';
	            }
	        },
	        calendar : {
	            sameDay : '[Hodia je] LT',
	            nextDay : '[Morga je] LT',
	            nextWeek : 'dddd [je] LT',
	            lastDay : '[Hiera je] LT',
	            lastWeek : '[pasinta] dddd [je] LT',
	            sameElse : 'L'
	        },
	        relativeTime : {
	            future : 'je %s',
	            past : 'anta %s',
	            s : 'sekundoj',
	            m : 'minuto',
	            mm : '%d minutoj',
	            h : 'horo',
	            hh : '%d horoj',
	            d : 'tago',//ne 'diurno', ar estas uzita por proksimumo
	            dd : '%d tagoj',
	            M : 'monato',
	            MM : '%d monatoj',
	            y : 'jaro',
	            yy : '%d jaroj'
	        },
	        ordinalParse: /\d{1,2}a/,
	        ordinal : '%da',
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 7  // The week that contains Jan 1st is the first week of the year.
	        }
	    });

	    return eo;

	}));

/***/ },
/* 82 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : spanish (es)
	//! author : Julio Napur : https://github.com/julionc

	(function (global, factory) {
	    true ? factory(__webpack_require__(56)) :
	   typeof define === 'function' && define.amd ? define(['moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';


	    var monthsShortDot = 'Ene._Feb._Mar._Abr._May._Jun._Jul._Ago._Sep._Oct._Nov._Dic.'.split('_'),
	        monthsShort = 'Ene_Feb_Mar_Abr_May_Jun_Jul_Ago_Sep_Oct_Nov_Dic'.split('_');

	    var es = moment.defineLocale('es', {
	        months : 'Enero_Febrero_Marzo_Abril_Mayo_Junio_Julio_Agosto_Septiembre_Octubre_Noviembre_Diciembre'.split('_'),
	        monthsShort : function (m, format) {
	            if (/-MMM-/.test(format)) {
	                return monthsShort[m.month()];
	            } else {
	                return monthsShortDot[m.month()];
	            }
	        },
	        weekdays : 'Domingo_Lunes_Martes_Mircoles_Jueves_Viernes_Sbado'.split('_'),
	        weekdaysShort : 'Dom._Lun._Mar._Mi._Jue._Vie._Sb.'.split('_'),
	        weekdaysMin : 'Do_Lu_Ma_Mi_Ju_Vi_S'.split('_'),
	        longDateFormat : {
	            LT : 'H:mm',
	            LTS : 'H:mm:ss',
	            L : 'DD/MM/YYYY',
	            LL : 'D [de] MMMM [de] YYYY',
	            LLL : 'D [de] MMMM [de] YYYY H:mm',
	            LLLL : 'dddd, D [de] MMMM [de] YYYY H:mm'
	        },
	        calendar : {
	            sameDay : function () {
	                return '[hoy a la' + ((this.hours() !== 1) ? 's' : '') + '] LT';
	            },
	            nextDay : function () {
	                return '[maana a la' + ((this.hours() !== 1) ? 's' : '') + '] LT';
	            },
	            nextWeek : function () {
	                return 'dddd [a la' + ((this.hours() !== 1) ? 's' : '') + '] LT';
	            },
	            lastDay : function () {
	                return '[ayer a la' + ((this.hours() !== 1) ? 's' : '') + '] LT';
	            },
	            lastWeek : function () {
	                return '[el] dddd [pasado a la' + ((this.hours() !== 1) ? 's' : '') + '] LT';
	            },
	            sameElse : 'L'
	        },
	        relativeTime : {
	            future : 'en %s',
	            past : 'hace %s',
	            s : 'unos segundos',
	            m : 'un minuto',
	            mm : '%d minutos',
	            h : 'una hora',
	            hh : '%d horas',
	            d : 'un da',
	            dd : '%d das',
	            M : 'un mes',
	            MM : '%d meses',
	            y : 'un ao',
	            yy : '%d aos'
	        },
	        ordinalParse : /\d{1,2}/,
	        ordinal : '%d',
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 4  // The week that contains Jan 4th is the first week of the year.
	        }
	    });

	    return es;

	}));

/***/ },
/* 83 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : estonian (et)
	//! author : Henry Kehlmann : https://github.com/madhenry
	//! improvements : Illimar Tambek : https://github.com/ragulka

	(function (global, factory) {
	    true ? factory(__webpack_require__(56)) :
	   typeof define === 'function' && define.amd ? define(['moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';


	    function processRelativeTime(number, withoutSuffix, key, isFuture) {
	        var format = {
	            's' : ['mne sekundi', 'mni sekund', 'paar sekundit'],
	            'm' : ['he minuti', 'ks minut'],
	            'mm': [number + ' minuti', number + ' minutit'],
	            'h' : ['he tunni', 'tund aega', 'ks tund'],
	            'hh': [number + ' tunni', number + ' tundi'],
	            'd' : ['he peva', 'ks pev'],
	            'M' : ['kuu aja', 'kuu aega', 'ks kuu'],
	            'MM': [number + ' kuu', number + ' kuud'],
	            'y' : ['he aasta', 'aasta', 'ks aasta'],
	            'yy': [number + ' aasta', number + ' aastat']
	        };
	        if (withoutSuffix) {
	            return format[key][2] ? format[key][2] : format[key][1];
	        }
	        return isFuture ? format[key][0] : format[key][1];
	    }

	    var et = moment.defineLocale('et', {
	        months        : 'jaanuar_veebruar_mrts_aprill_mai_juuni_juuli_august_september_oktoober_november_detsember'.split('_'),
	        monthsShort   : 'jaan_veebr_mrts_apr_mai_juuni_juuli_aug_sept_okt_nov_dets'.split('_'),
	        weekdays      : 'phapev_esmaspev_teisipev_kolmapev_neljapev_reede_laupev'.split('_'),
	        weekdaysShort : 'P_E_T_K_N_R_L'.split('_'),
	        weekdaysMin   : 'P_E_T_K_N_R_L'.split('_'),
	        longDateFormat : {
	            LT   : 'H:mm',
	            LTS : 'H:mm:ss',
	            L    : 'DD.MM.YYYY',
	            LL   : 'D. MMMM YYYY',
	            LLL  : 'D. MMMM YYYY H:mm',
	            LLLL : 'dddd, D. MMMM YYYY H:mm'
	        },
	        calendar : {
	            sameDay  : '[Tna,] LT',
	            nextDay  : '[Homme,] LT',
	            nextWeek : '[Jrgmine] dddd LT',
	            lastDay  : '[Eile,] LT',
	            lastWeek : '[Eelmine] dddd LT',
	            sameElse : 'L'
	        },
	        relativeTime : {
	            future : '%s prast',
	            past   : '%s tagasi',
	            s      : processRelativeTime,
	            m      : processRelativeTime,
	            mm     : processRelativeTime,
	            h      : processRelativeTime,
	            hh     : processRelativeTime,
	            d      : processRelativeTime,
	            dd     : '%d peva',
	            M      : processRelativeTime,
	            MM     : processRelativeTime,
	            y      : processRelativeTime,
	            yy     : processRelativeTime
	        },
	        ordinalParse: /\d{1,2}\./,
	        ordinal : '%d.',
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 4  // The week that contains Jan 4th is the first week of the year.
	        }
	    });

	    return et;

	}));

/***/ },
/* 84 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : euskara (eu)
	//! author : Eneko Illarramendi : https://github.com/eillarra

	(function (global, factory) {
	    true ? factory(__webpack_require__(56)) :
	   typeof define === 'function' && define.amd ? define(['moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';


	    var eu = moment.defineLocale('eu', {
	        months : 'urtarrila_otsaila_martxoa_apirila_maiatza_ekaina_uztaila_abuztua_iraila_urria_azaroa_abendua'.split('_'),
	        monthsShort : 'urt._ots._mar._api._mai._eka._uzt._abu._ira._urr._aza._abe.'.split('_'),
	        weekdays : 'igandea_astelehena_asteartea_asteazkena_osteguna_ostirala_larunbata'.split('_'),
	        weekdaysShort : 'ig._al._ar._az._og._ol._lr.'.split('_'),
	        weekdaysMin : 'ig_al_ar_az_og_ol_lr'.split('_'),
	        longDateFormat : {
	            LT : 'HH:mm',
	            LTS : 'HH:mm:ss',
	            L : 'YYYY-MM-DD',
	            LL : 'YYYY[ko] MMMM[ren] D[a]',
	            LLL : 'YYYY[ko] MMMM[ren] D[a] HH:mm',
	            LLLL : 'dddd, YYYY[ko] MMMM[ren] D[a] HH:mm',
	            l : 'YYYY-M-D',
	            ll : 'YYYY[ko] MMM D[a]',
	            lll : 'YYYY[ko] MMM D[a] HH:mm',
	            llll : 'ddd, YYYY[ko] MMM D[a] HH:mm'
	        },
	        calendar : {
	            sameDay : '[gaur] LT[etan]',
	            nextDay : '[bihar] LT[etan]',
	            nextWeek : 'dddd LT[etan]',
	            lastDay : '[atzo] LT[etan]',
	            lastWeek : '[aurreko] dddd LT[etan]',
	            sameElse : 'L'
	        },
	        relativeTime : {
	            future : '%s barru',
	            past : 'duela %s',
	            s : 'segundo batzuk',
	            m : 'minutu bat',
	            mm : '%d minutu',
	            h : 'ordu bat',
	            hh : '%d ordu',
	            d : 'egun bat',
	            dd : '%d egun',
	            M : 'hilabete bat',
	            MM : '%d hilabete',
	            y : 'urte bat',
	            yy : '%d urte'
	        },
	        ordinalParse: /\d{1,2}\./,
	        ordinal : '%d.',
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 7  // The week that contains Jan 1st is the first week of the year.
	        }
	    });

	    return eu;

	}));

/***/ },
/* 85 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Persian (fa)
	//! author : Ebrahim Byagowi : https://github.com/ebraminio

	(function (global, factory) {
	    true ? factory(__webpack_require__(56)) :
	   typeof define === 'function' && define.amd ? define(['moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';


	    var symbolMap = {
	        '1': '',
	        '2': '',
	        '3': '',
	        '4': '',
	        '5': '',
	        '6': '',
	        '7': '',
	        '8': '',
	        '9': '',
	        '0': ''
	    }, numberMap = {
	        '': '1',
	        '': '2',
	        '': '3',
	        '': '4',
	        '': '5',
	        '': '6',
	        '': '7',
	        '': '8',
	        '': '9',
	        '': '0'
	    };

	    var fa = moment.defineLocale('fa', {
	        months : '___________'.split('_'),
	        monthsShort : '___________'.split('_'),
	        weekdays : '\u200c__\u200c__\u200c__'.split('_'),
	        weekdaysShort : '\u200c__\u200c__\u200c__'.split('_'),
	        weekdaysMin : '______'.split('_'),
	        longDateFormat : {
	            LT : 'HH:mm',
	            LTS : 'HH:mm:ss',
	            L : 'DD/MM/YYYY',
	            LL : 'D MMMM YYYY',
	            LLL : 'D MMMM YYYY HH:mm',
	            LLLL : 'dddd, D MMMM YYYY HH:mm'
	        },
	        meridiemParse: /  |  /,
	        isPM: function (input) {
	            return /  /.test(input);
	        },
	        meridiem : function (hour, minute, isLower) {
	            if (hour < 12) {
	                return '  ';
	            } else {
	                return '  ';
	            }
	        },
	        calendar : {
	            sameDay : '[ ] LT',
	            nextDay : '[ ] LT',
	            nextWeek : 'dddd [] LT',
	            lastDay : '[ ] LT',
	            lastWeek : 'dddd [] [] LT',
	            sameElse : 'L'
	        },
	        relativeTime : {
	            future : ' %s',
	            past : '%s ',
	            s : ' ',
	            m : ' ',
	            mm : '%d ',
	            h : ' ',
	            hh : '%d ',
	            d : ' ',
	            dd : '%d ',
	            M : ' ',
	            MM : '%d ',
	            y : ' ',
	            yy : '%d '
	        },
	        preparse: function (string) {
	            return string.replace(/[-]/g, function (match) {
	                return numberMap[match];
	            }).replace(//g, ',');
	        },
	        postformat: function (string) {
	            return string.replace(/\d/g, function (match) {
	                return symbolMap[match];
	            }).replace(/,/g, '');
	        },
	        ordinalParse: /\d{1,2}/,
	        ordinal : '%d',
	        week : {
	            dow : 6, // Saturday is the first day of the week.
	            doy : 12 // The week that contains Jan 1st is the first week of the year.
	        }
	    });

	    return fa;

	}));

/***/ },
/* 86 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : finnish (fi)
	//! author : Tarmo Aidantausta : https://github.com/bleadof

	(function (global, factory) {
	    true ? factory(__webpack_require__(56)) :
	   typeof define === 'function' && define.amd ? define(['moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';


	    var numbersPast = 'nolla yksi kaksi kolme nelj viisi kuusi seitsemn kahdeksan yhdeksn'.split(' '),
	        numbersFuture = [
	            'nolla', 'yhden', 'kahden', 'kolmen', 'neljn', 'viiden', 'kuuden',
	            numbersPast[7], numbersPast[8], numbersPast[9]
	        ];
	    function translate(number, withoutSuffix, key, isFuture) {
	        var result = '';
	        switch (key) {
	        case 's':
	            return isFuture ? 'muutaman sekunnin' : 'muutama sekunti';
	        case 'm':
	            return isFuture ? 'minuutin' : 'minuutti';
	        case 'mm':
	            result = isFuture ? 'minuutin' : 'minuuttia';
	            break;
	        case 'h':
	            return isFuture ? 'tunnin' : 'tunti';
	        case 'hh':
	            result = isFuture ? 'tunnin' : 'tuntia';
	            break;
	        case 'd':
	            return isFuture ? 'pivn' : 'piv';
	        case 'dd':
	            result = isFuture ? 'pivn' : 'piv';
	            break;
	        case 'M':
	            return isFuture ? 'kuukauden' : 'kuukausi';
	        case 'MM':
	            result = isFuture ? 'kuukauden' : 'kuukautta';
	            break;
	        case 'y':
	            return isFuture ? 'vuoden' : 'vuosi';
	        case 'yy':
	            result = isFuture ? 'vuoden' : 'vuotta';
	            break;
	        }
	        result = verbalNumber(number, isFuture) + ' ' + result;
	        return result;
	    }
	    function verbalNumber(number, isFuture) {
	        return number < 10 ? (isFuture ? numbersFuture[number] : numbersPast[number]) : number;
	    }

	    var fi = moment.defineLocale('fi', {
	        months : 'tammikuu_helmikuu_maaliskuu_huhtikuu_toukokuu_keskuu_heinkuu_elokuu_syyskuu_lokakuu_marraskuu_joulukuu'.split('_'),
	        monthsShort : 'tammi_helmi_maalis_huhti_touko_kes_hein_elo_syys_loka_marras_joulu'.split('_'),
	        weekdays : 'sunnuntai_maanantai_tiistai_keskiviikko_torstai_perjantai_lauantai'.split('_'),
	        weekdaysShort : 'su_ma_ti_ke_to_pe_la'.split('_'),
	        weekdaysMin : 'su_ma_ti_ke_to_pe_la'.split('_'),
	        longDateFormat : {
	            LT : 'HH.mm',
	            LTS : 'HH.mm.ss',
	            L : 'DD.MM.YYYY',
	            LL : 'Do MMMM[ta] YYYY',
	            LLL : 'Do MMMM[ta] YYYY, [klo] HH.mm',
	            LLLL : 'dddd, Do MMMM[ta] YYYY, [klo] HH.mm',
	            l : 'D.M.YYYY',
	            ll : 'Do MMM YYYY',
	            lll : 'Do MMM YYYY, [klo] HH.mm',
	            llll : 'ddd, Do MMM YYYY, [klo] HH.mm'
	        },
	        calendar : {
	            sameDay : '[tnn] [klo] LT',
	            nextDay : '[huomenna] [klo] LT',
	            nextWeek : 'dddd [klo] LT',
	            lastDay : '[eilen] [klo] LT',
	            lastWeek : '[viime] dddd[na] [klo] LT',
	            sameElse : 'L'
	        },
	        relativeTime : {
	            future : '%s pst',
	            past : '%s sitten',
	            s : translate,
	            m : translate,
	            mm : translate,
	            h : translate,
	            hh : translate,
	            d : translate,
	            dd : translate,
	            M : translate,
	            MM : translate,
	            y : translate,
	            yy : translate
	        },
	        ordinalParse: /\d{1,2}\./,
	        ordinal : '%d.',
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 4  // The week that contains Jan 4th is the first week of the year.
	        }
	    });

	    return fi;

	}));

/***/ },
/* 87 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : faroese (fo)
	//! author : Ragnar Johannesen : https://github.com/ragnar123

	(function (global, factory) {
	    true ? factory(__webpack_require__(56)) :
	   typeof define === 'function' && define.amd ? define(['moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';


	    var fo = moment.defineLocale('fo', {
	        months : 'januar_februar_mars_aprl_mai_juni_juli_august_september_oktober_november_desember'.split('_'),
	        monthsShort : 'jan_feb_mar_apr_mai_jun_jul_aug_sep_okt_nov_des'.split('_'),
	        weekdays : 'sunnudagur_mnadagur_tsdagur_mikudagur_hsdagur_frggjadagur_leygardagur'.split('_'),
	        weekdaysShort : 'sun_mn_ts_mik_hs_fr_ley'.split('_'),
	        weekdaysMin : 'su_m_t_mi_h_fr_le'.split('_'),
	        longDateFormat : {
	            LT : 'HH:mm',
	            LTS : 'HH:mm:ss',
	            L : 'DD/MM/YYYY',
	            LL : 'D MMMM YYYY',
	            LLL : 'D MMMM YYYY HH:mm',
	            LLLL : 'dddd D. MMMM, YYYY HH:mm'
	        },
	        calendar : {
	            sameDay : '[ dag kl.] LT',
	            nextDay : '[ morgin kl.] LT',
	            nextWeek : 'dddd [kl.] LT',
	            lastDay : '[ gjr kl.] LT',
	            lastWeek : '[sstu] dddd [kl] LT',
	            sameElse : 'L'
	        },
	        relativeTime : {
	            future : 'um %s',
	            past : '%s sani',
	            s : 'f sekund',
	            m : 'ein minutt',
	            mm : '%d minuttir',
	            h : 'ein tmi',
	            hh : '%d tmar',
	            d : 'ein dagur',
	            dd : '%d dagar',
	            M : 'ein mnai',
	            MM : '%d mnair',
	            y : 'eitt r',
	            yy : '%d r'
	        },
	        ordinalParse: /\d{1,2}\./,
	        ordinal : '%d.',
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 4  // The week that contains Jan 4th is the first week of the year.
	        }
	    });

	    return fo;

	}));

/***/ },
/* 88 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : french (fr)
	//! author : John Fischer : https://github.com/jfroffice

	(function (global, factory) {
	    true ? factory(__webpack_require__(56)) :
	   typeof define === 'function' && define.amd ? define(['moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';


	    var fr = moment.defineLocale('fr', {
	        months : 'janvier_fvrier_mars_avril_mai_juin_juillet_aot_septembre_octobre_novembre_dcembre'.split('_'),
	        monthsShort : 'janv._fvr._mars_avr._mai_juin_juil._aot_sept._oct._nov._dc.'.split('_'),
	        weekdays : 'dimanche_lundi_mardi_mercredi_jeudi_vendredi_samedi'.split('_'),
	        weekdaysShort : 'dim._lun._mar._mer._jeu._ven._sam.'.split('_'),
	        weekdaysMin : 'Di_Lu_Ma_Me_Je_Ve_Sa'.split('_'),
	        longDateFormat : {
	            LT : 'HH:mm',
	            LTS : 'HH:mm:ss',
	            L : 'DD/MM/YYYY',
	            LL : 'D MMMM YYYY',
	            LLL : 'D MMMM YYYY HH:mm',
	            LLLL : 'dddd D MMMM YYYY HH:mm'
	        },
	        calendar : {
	            sameDay: '[Aujourd\'hui ] LT',
	            nextDay: '[Demain ] LT',
	            nextWeek: 'dddd [] LT',
	            lastDay: '[Hier ] LT',
	            lastWeek: 'dddd [dernier ] LT',
	            sameElse: 'L'
	        },
	        relativeTime : {
	            future : 'dans %s',
	            past : 'il y a %s',
	            s : 'quelques secondes',
	            m : 'une minute',
	            mm : '%d minutes',
	            h : 'une heure',
	            hh : '%d heures',
	            d : 'un jour',
	            dd : '%d jours',
	            M : 'un mois',
	            MM : '%d mois',
	            y : 'un an',
	            yy : '%d ans'
	        },
	        ordinalParse: /\d{1,2}(er|)/,
	        ordinal : function (number) {
	            return number + (number === 1 ? 'er' : '');
	        },
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 4  // The week that contains Jan 4th is the first week of the year.
	        }
	    });

	    return fr;

	}));

/***/ },
/* 89 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : canadian french (fr-ca)
	//! author : Jonathan Abourbih : https://github.com/jonbca

	(function (global, factory) {
	    true ? factory(__webpack_require__(56)) :
	   typeof define === 'function' && define.amd ? define(['moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';


	    var fr_ca = moment.defineLocale('fr-ca', {
	        months : 'janvier_fvrier_mars_avril_mai_juin_juillet_aot_septembre_octobre_novembre_dcembre'.split('_'),
	        monthsShort : 'janv._fvr._mars_avr._mai_juin_juil._aot_sept._oct._nov._dc.'.split('_'),
	        weekdays : 'dimanche_lundi_mardi_mercredi_jeudi_vendredi_samedi'.split('_'),
	        weekdaysShort : 'dim._lun._mar._mer._jeu._ven._sam.'.split('_'),
	        weekdaysMin : 'Di_Lu_Ma_Me_Je_Ve_Sa'.split('_'),
	        longDateFormat : {
	            LT : 'HH:mm',
	            LTS : 'HH:mm:ss',
	            L : 'YYYY-MM-DD',
	            LL : 'D MMMM YYYY',
	            LLL : 'D MMMM YYYY HH:mm',
	            LLLL : 'dddd D MMMM YYYY HH:mm'
	        },
	        calendar : {
	            sameDay: '[Aujourd\'hui ] LT',
	            nextDay: '[Demain ] LT',
	            nextWeek: 'dddd [] LT',
	            lastDay: '[Hier ] LT',
	            lastWeek: 'dddd [dernier ] LT',
	            sameElse: 'L'
	        },
	        relativeTime : {
	            future : 'dans %s',
	            past : 'il y a %s',
	            s : 'quelques secondes',
	            m : 'une minute',
	            mm : '%d minutes',
	            h : 'une heure',
	            hh : '%d heures',
	            d : 'un jour',
	            dd : '%d jours',
	            M : 'un mois',
	            MM : '%d mois',
	            y : 'un an',
	            yy : '%d ans'
	        },
	        ordinalParse: /\d{1,2}(er|e)/,
	        ordinal : function (number) {
	            return number + (number === 1 ? 'er' : 'e');
	        }
	    });

	    return fr_ca;

	}));

/***/ },
/* 90 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : frisian (fy)
	//! author : Robin van der Vliet : https://github.com/robin0van0der0v

	(function (global, factory) {
	    true ? factory(__webpack_require__(56)) :
	   typeof define === 'function' && define.amd ? define(['moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';


	    var monthsShortWithDots = 'jan._feb._mrt._apr._mai_jun._jul._aug._sep._okt._nov._des.'.split('_'),
	        monthsShortWithoutDots = 'jan_feb_mrt_apr_mai_jun_jul_aug_sep_okt_nov_des'.split('_');

	    var fy = moment.defineLocale('fy', {
	        months : 'jannewaris_febrewaris_maart_april_maaie_juny_july_augustus_septimber_oktober_novimber_desimber'.split('_'),
	        monthsShort : function (m, format) {
	            if (/-MMM-/.test(format)) {
	                return monthsShortWithoutDots[m.month()];
	            } else {
	                return monthsShortWithDots[m.month()];
	            }
	        },
	        weekdays : 'snein_moandei_tiisdei_woansdei_tongersdei_freed_sneon'.split('_'),
	        weekdaysShort : 'si._mo._ti._wo._to._fr._so.'.split('_'),
	        weekdaysMin : 'Si_Mo_Ti_Wo_To_Fr_So'.split('_'),
	        longDateFormat : {
	            LT : 'HH:mm',
	            LTS : 'HH:mm:ss',
	            L : 'DD-MM-YYYY',
	            LL : 'D MMMM YYYY',
	            LLL : 'D MMMM YYYY HH:mm',
	            LLLL : 'dddd D MMMM YYYY HH:mm'
	        },
	        calendar : {
	            sameDay: '[hjoed om] LT',
	            nextDay: '[moarn om] LT',
	            nextWeek: 'dddd [om] LT',
	            lastDay: '[juster om] LT',
	            lastWeek: '[frne] dddd [om] LT',
	            sameElse: 'L'
	        },
	        relativeTime : {
	            future : 'oer %s',
	            past : '%s lyn',
	            s : 'in pear sekonden',
	            m : 'ien mint',
	            mm : '%d minuten',
	            h : 'ien oere',
	            hh : '%d oeren',
	            d : 'ien dei',
	            dd : '%d dagen',
	            M : 'ien moanne',
	            MM : '%d moannen',
	            y : 'ien jier',
	            yy : '%d jierren'
	        },
	        ordinalParse: /\d{1,2}(ste|de)/,
	        ordinal : function (number) {
	            return number + ((number === 1 || number === 8 || number >= 20) ? 'ste' : 'de');
	        },
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 4  // The week that contains Jan 4th is the first week of the year.
	        }
	    });

	    return fy;

	}));

/***/ },
/* 91 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : galician (gl)
	//! author : Juan G. Hurtado : https://github.com/juanghurtado

	(function (global, factory) {
	    true ? factory(__webpack_require__(56)) :
	   typeof define === 'function' && define.amd ? define(['moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';


	    var gl = moment.defineLocale('gl', {
	        months : 'Xaneiro_Febreiro_Marzo_Abril_Maio_Xuo_Xullo_Agosto_Setembro_Outubro_Novembro_Decembro'.split('_'),
	        monthsShort : 'Xan._Feb._Mar._Abr._Mai._Xu._Xul._Ago._Set._Out._Nov._Dec.'.split('_'),
	        weekdays : 'Domingo_Luns_Martes_Mrcores_Xoves_Venres_Sbado'.split('_'),
	        weekdaysShort : 'Dom._Lun._Mar._Mr._Xov._Ven._Sb.'.split('_'),
	        weekdaysMin : 'Do_Lu_Ma_M_Xo_Ve_S'.split('_'),
	        longDateFormat : {
	            LT : 'H:mm',
	            LTS : 'H:mm:ss',
	            L : 'DD/MM/YYYY',
	            LL : 'D MMMM YYYY',
	            LLL : 'D MMMM YYYY H:mm',
	            LLLL : 'dddd D MMMM YYYY H:mm'
	        },
	        calendar : {
	            sameDay : function () {
	                return '[hoxe ' + ((this.hours() !== 1) ? 's' : '') + '] LT';
	            },
	            nextDay : function () {
	                return '[ma ' + ((this.hours() !== 1) ? 's' : '') + '] LT';
	            },
	            nextWeek : function () {
	                return 'dddd [' + ((this.hours() !== 1) ? 's' : 'a') + '] LT';
	            },
	            lastDay : function () {
	                return '[onte ' + ((this.hours() !== 1) ? '' : 'a') + '] LT';
	            },
	            lastWeek : function () {
	                return '[o] dddd [pasado ' + ((this.hours() !== 1) ? 's' : 'a') + '] LT';
	            },
	            sameElse : 'L'
	        },
	        relativeTime : {
	            future : function (str) {
	                if (str === 'uns segundos') {
	                    return 'nuns segundos';
	                }
	                return 'en ' + str;
	            },
	            past : 'hai %s',
	            s : 'uns segundos',
	            m : 'un minuto',
	            mm : '%d minutos',
	            h : 'unha hora',
	            hh : '%d horas',
	            d : 'un da',
	            dd : '%d das',
	            M : 'un mes',
	            MM : '%d meses',
	            y : 'un ano',
	            yy : '%d anos'
	        },
	        ordinalParse : /\d{1,2}/,
	        ordinal : '%d',
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 7  // The week that contains Jan 1st is the first week of the year.
	        }
	    });

	    return gl;

	}));

/***/ },
/* 92 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Hebrew (he)
	//! author : Tomer Cohen : https://github.com/tomer
	//! author : Moshe Simantov : https://github.com/DevelopmentIL
	//! author : Tal Ater : https://github.com/TalAter

	(function (global, factory) {
	    true ? factory(__webpack_require__(56)) :
	   typeof define === 'function' && define.amd ? define(['moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';


	    var he = moment.defineLocale('he', {
	        months : '___________'.split('_'),
	        monthsShort : '___________'.split('_'),
	        weekdays : '______'.split('_'),
	        weekdaysShort : '______'.split('_'),
	        weekdaysMin : '______'.split('_'),
	        longDateFormat : {
	            LT : 'HH:mm',
	            LTS : 'HH:mm:ss',
	            L : 'DD/MM/YYYY',
	            LL : 'D []MMMM YYYY',
	            LLL : 'D []MMMM YYYY HH:mm',
	            LLLL : 'dddd, D []MMMM YYYY HH:mm',
	            l : 'D/M/YYYY',
	            ll : 'D MMM YYYY',
	            lll : 'D MMM YYYY HH:mm',
	            llll : 'ddd, D MMM YYYY HH:mm'
	        },
	        calendar : {
	            sameDay : '[ ]LT',
	            nextDay : '[ ]LT',
	            nextWeek : 'dddd [] LT',
	            lastDay : '[ ]LT',
	            lastWeek : '[] dddd [ ] LT',
	            sameElse : 'L'
	        },
	        relativeTime : {
	            future : ' %s',
	            past : ' %s',
	            s : ' ',
	            m : '',
	            mm : '%d ',
	            h : '',
	            hh : function (number) {
	                if (number === 2) {
	                    return '';
	                }
	                return number + ' ';
	            },
	            d : '',
	            dd : function (number) {
	                if (number === 2) {
	                    return '';
	                }
	                return number + ' ';
	            },
	            M : '',
	            MM : function (number) {
	                if (number === 2) {
	                    return '';
	                }
	                return number + ' ';
	            },
	            y : '',
	            yy : function (number) {
	                if (number === 2) {
	                    return '';
	                } else if (number % 10 === 0 && number !== 10) {
	                    return number + ' ';
	                }
	                return number + ' ';
	            }
	        }
	    });

	    return he;

	}));

/***/ },
/* 93 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : hindi (hi)
	//! author : Mayank Singhal : https://github.com/mayanksinghal

	(function (global, factory) {
	    true ? factory(__webpack_require__(56)) :
	   typeof define === 'function' && define.amd ? define(['moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';


	    var symbolMap = {
	        '1': '',
	        '2': '',
	        '3': '',
	        '4': '',
	        '5': '',
	        '6': '',
	        '7': '',
	        '8': '',
	        '9': '',
	        '0': ''
	    },
	    numberMap = {
	        '': '1',
	        '': '2',
	        '': '3',
	        '': '4',
	        '': '5',
	        '': '6',
	        '': '7',
	        '': '8',
	        '': '9',
	        '': '0'
	    };

	    var hi = moment.defineLocale('hi', {
	        months : '___________'.split('_'),
	        monthsShort : '._.__.___._._._._._.'.split('_'),
	        weekdays : '______'.split('_'),
	        weekdaysShort : '______'.split('_'),
	        weekdaysMin : '______'.split('_'),
	        longDateFormat : {
	            LT : 'A h:mm ',
	            LTS : 'A h:mm:ss ',
	            L : 'DD/MM/YYYY',
	            LL : 'D MMMM YYYY',
	            LLL : 'D MMMM YYYY, A h:mm ',
	            LLLL : 'dddd, D MMMM YYYY, A h:mm '
	        },
	        calendar : {
	            sameDay : '[] LT',
	            nextDay : '[] LT',
	            nextWeek : 'dddd, LT',
	            lastDay : '[] LT',
	            lastWeek : '[] dddd, LT',
	            sameElse : 'L'
	        },
	        relativeTime : {
	            future : '%s ',
	            past : '%s ',
	            s : '  ',
	            m : ' ',
	            mm : '%d ',
	            h : ' ',
	            hh : '%d ',
	            d : ' ',
	            dd : '%d ',
	            M : ' ',
	            MM : '%d ',
	            y : ' ',
	            yy : '%d '
	        },
	        preparse: function (string) {
	            return string.replace(/[]/g, function (match) {
	                return numberMap[match];
	            });
	        },
	        postformat: function (string) {
	            return string.replace(/\d/g, function (match) {
	                return symbolMap[match];
	            });
	        },
	        // Hindi notation for meridiems are quite fuzzy in practice. While there exists
	        // a rigid notion of a 'Pahar' it is not used as rigidly in modern Hindi.
	        meridiemParse: /|||/,
	        meridiemHour : function (hour, meridiem) {
	            if (hour === 12) {
	                hour = 0;
	            }
	            if (meridiem === '') {
	                return hour < 4 ? hour : hour + 12;
	            } else if (meridiem === '') {
	                return hour;
	            } else if (meridiem === '') {
	                return hour >= 10 ? hour : hour + 12;
	            } else if (meridiem === '') {
	                return hour + 12;
	            }
	        },
	        meridiem : function (hour, minute, isLower) {
	            if (hour < 4) {
	                return '';
	            } else if (hour < 10) {
	                return '';
	            } else if (hour < 17) {
	                return '';
	            } else if (hour < 20) {
	                return '';
	            } else {
	                return '';
	            }
	        },
	        week : {
	            dow : 0, // Sunday is the first day of the week.
	            doy : 6  // The week that contains Jan 1st is the first week of the year.
	        }
	    });

	    return hi;

	}));

/***/ },
/* 94 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : hrvatski (hr)
	//! author : Bojan Markovi : https://github.com/bmarkovic

	(function (global, factory) {
	    true ? factory(__webpack_require__(56)) :
	   typeof define === 'function' && define.amd ? define(['moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';


	    function translate(number, withoutSuffix, key) {
	        var result = number + ' ';
	        switch (key) {
	        case 'm':
	            return withoutSuffix ? 'jedna minuta' : 'jedne minute';
	        case 'mm':
	            if (number === 1) {
	                result += 'minuta';
	            } else if (number === 2 || number === 3 || number === 4) {
	                result += 'minute';
	            } else {
	                result += 'minuta';
	            }
	            return result;
	        case 'h':
	            return withoutSuffix ? 'jedan sat' : 'jednog sata';
	        case 'hh':
	            if (number === 1) {
	                result += 'sat';
	            } else if (number === 2 || number === 3 || number === 4) {
	                result += 'sata';
	            } else {
	                result += 'sati';
	            }
	            return result;
	        case 'dd':
	            if (number === 1) {
	                result += 'dan';
	            } else {
	                result += 'dana';
	            }
	            return result;
	        case 'MM':
	            if (number === 1) {
	                result += 'mjesec';
	            } else if (number === 2 || number === 3 || number === 4) {
	                result += 'mjeseca';
	            } else {
	                result += 'mjeseci';
	            }
	            return result;
	        case 'yy':
	            if (number === 1) {
	                result += 'godina';
	            } else if (number === 2 || number === 3 || number === 4) {
	                result += 'godine';
	            } else {
	                result += 'godina';
	            }
	            return result;
	        }
	    }

	    var hr = moment.defineLocale('hr', {
	        months : 'sijeanj_veljaa_oujak_travanj_svibanj_lipanj_srpanj_kolovoz_rujan_listopad_studeni_prosinac'.split('_'),
	        monthsShort : 'sij._velj._ou._tra._svi._lip._srp._kol._ruj._lis._stu._pro.'.split('_'),
	        weekdays : 'nedjelja_ponedjeljak_utorak_srijeda_etvrtak_petak_subota'.split('_'),
	        weekdaysShort : 'ned._pon._uto._sri._et._pet._sub.'.split('_'),
	        weekdaysMin : 'ne_po_ut_sr_e_pe_su'.split('_'),
	        longDateFormat : {
	            LT : 'H:mm',
	            LTS : 'H:mm:ss',
	            L : 'DD. MM. YYYY',
	            LL : 'D. MMMM YYYY',
	            LLL : 'D. MMMM YYYY H:mm',
	            LLLL : 'dddd, D. MMMM YYYY H:mm'
	        },
	        calendar : {
	            sameDay  : '[danas u] LT',
	            nextDay  : '[sutra u] LT',
	            nextWeek : function () {
	                switch (this.day()) {
	                case 0:
	                    return '[u] [nedjelju] [u] LT';
	                case 3:
	                    return '[u] [srijedu] [u] LT';
	                case 6:
	                    return '[u] [subotu] [u] LT';
	                case 1:
	                case 2:
	                case 4:
	                case 5:
	                    return '[u] dddd [u] LT';
	                }
	            },
	            lastDay  : '[juer u] LT',
	            lastWeek : function () {
	                switch (this.day()) {
	                case 0:
	                case 3:
	                    return '[prolu] dddd [u] LT';
	                case 6:
	                    return '[prole] [subote] [u] LT';
	                case 1:
	                case 2:
	                case 4:
	                case 5:
	                    return '[proli] dddd [u] LT';
	                }
	            },
	            sameElse : 'L'
	        },
	        relativeTime : {
	            future : 'za %s',
	            past   : 'prije %s',
	            s      : 'par sekundi',
	            m      : translate,
	            mm     : translate,
	            h      : translate,
	            hh     : translate,
	            d      : 'dan',
	            dd     : translate,
	            M      : 'mjesec',
	            MM     : translate,
	            y      : 'godinu',
	            yy     : translate
	        },
	        ordinalParse: /\d{1,2}\./,
	        ordinal : '%d.',
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 7  // The week that contains Jan 1st is the first week of the year.
	        }
	    });

	    return hr;

	}));

/***/ },
/* 95 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : hungarian (hu)
	//! author : Adam Brunner : https://github.com/adambrunner

	(function (global, factory) {
	    true ? factory(__webpack_require__(56)) :
	   typeof define === 'function' && define.amd ? define(['moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';


	    var weekEndings = 'vasrnap htfn kedden szerdn cstrtkn pnteken szombaton'.split(' ');
	    function translate(number, withoutSuffix, key, isFuture) {
	        var num = number,
	            suffix;
	        switch (key) {
	        case 's':
	            return (isFuture || withoutSuffix) ? 'nhny msodperc' : 'nhny msodperce';
	        case 'm':
	            return 'egy' + (isFuture || withoutSuffix ? ' perc' : ' perce');
	        case 'mm':
	            return num + (isFuture || withoutSuffix ? ' perc' : ' perce');
	        case 'h':
	            return 'egy' + (isFuture || withoutSuffix ? ' ra' : ' rja');
	        case 'hh':
	            return num + (isFuture || withoutSuffix ? ' ra' : ' rja');
	        case 'd':
	            return 'egy' + (isFuture || withoutSuffix ? ' nap' : ' napja');
	        case 'dd':
	            return num + (isFuture || withoutSuffix ? ' nap' : ' napja');
	        case 'M':
	            return 'egy' + (isFuture || withoutSuffix ? ' hnap' : ' hnapja');
	        case 'MM':
	            return num + (isFuture || withoutSuffix ? ' hnap' : ' hnapja');
	        case 'y':
	            return 'egy' + (isFuture || withoutSuffix ? ' v' : ' ve');
	        case 'yy':
	            return num + (isFuture || withoutSuffix ? ' v' : ' ve');
	        }
	        return '';
	    }
	    function week(isFuture) {
	        return (isFuture ? '' : '[mlt] ') + '[' + weekEndings[this.day()] + '] LT[-kor]';
	    }

	    var hu = moment.defineLocale('hu', {
	        months : 'janur_februr_mrcius_prilis_mjus_jnius_jlius_augusztus_szeptember_oktber_november_december'.split('_'),
	        monthsShort : 'jan_feb_mrc_pr_mj_jn_jl_aug_szept_okt_nov_dec'.split('_'),
	        weekdays : 'vasrnap_htf_kedd_szerda_cstrtk_pntek_szombat'.split('_'),
	        weekdaysShort : 'vas_ht_kedd_sze_cst_pn_szo'.split('_'),
	        weekdaysMin : 'v_h_k_sze_cs_p_szo'.split('_'),
	        longDateFormat : {
	            LT : 'H:mm',
	            LTS : 'H:mm:ss',
	            L : 'YYYY.MM.DD.',
	            LL : 'YYYY. MMMM D.',
	            LLL : 'YYYY. MMMM D. H:mm',
	            LLLL : 'YYYY. MMMM D., dddd H:mm'
	        },
	        meridiemParse: /de|du/i,
	        isPM: function (input) {
	            return input.charAt(1).toLowerCase() === 'u';
	        },
	        meridiem : function (hours, minutes, isLower) {
	            if (hours < 12) {
	                return isLower === true ? 'de' : 'DE';
	            } else {
	                return isLower === true ? 'du' : 'DU';
	            }
	        },
	        calendar : {
	            sameDay : '[ma] LT[-kor]',
	            nextDay : '[holnap] LT[-kor]',
	            nextWeek : function () {
	                return week.call(this, true);
	            },
	            lastDay : '[tegnap] LT[-kor]',
	            lastWeek : function () {
	                return week.call(this, false);
	            },
	            sameElse : 'L'
	        },
	        relativeTime : {
	            future : '%s mlva',
	            past : '%s',
	            s : translate,
	            m : translate,
	            mm : translate,
	            h : translate,
	            hh : translate,
	            d : translate,
	            dd : translate,
	            M : translate,
	            MM : translate,
	            y : translate,
	            yy : translate
	        },
	        ordinalParse: /\d{1,2}\./,
	        ordinal : '%d.',
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 7  // The week that contains Jan 1st is the first week of the year.
	        }
	    });

	    return hu;

	}));

/***/ },
/* 96 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Armenian (hy-am)
	//! author : Armendarabyan : https://github.com/armendarabyan

	(function (global, factory) {
	    true ? factory(__webpack_require__(56)) :
	   typeof define === 'function' && define.amd ? define(['moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';


	    function monthsCaseReplace(m, format) {
	        var months = {
	            'nominative': '___________'.split('_'),
	            'accusative': '___________'.split('_')
	        },
	        nounCase = (/D[oD]?(\[[^\[\]]*\]|\s+)+MMMM?/).test(format) ?
	            'accusative' :
	            'nominative';
	        return months[nounCase][m.month()];
	    }
	    function monthsShortCaseReplace(m, format) {
	        var monthsShort = '___________'.split('_');
	        return monthsShort[m.month()];
	    }
	    function weekdaysCaseReplace(m, format) {
	        var weekdays = '______'.split('_');
	        return weekdays[m.day()];
	    }

	    var hy_am = moment.defineLocale('hy-am', {
	        months : monthsCaseReplace,
	        monthsShort : monthsShortCaseReplace,
	        weekdays : weekdaysCaseReplace,
	        weekdaysShort : '______'.split('_'),
	        weekdaysMin : '______'.split('_'),
	        longDateFormat : {
	            LT : 'HH:mm',
	            LTS : 'HH:mm:ss',
	            L : 'DD.MM.YYYY',
	            LL : 'D MMMM YYYY .',
	            LLL : 'D MMMM YYYY ., HH:mm',
	            LLLL : 'dddd, D MMMM YYYY ., HH:mm'
	        },
	        calendar : {
	            sameDay: '[] LT',
	            nextDay: '[] LT',
	            lastDay: '[] LT',
	            nextWeek: function () {
	                return 'dddd [ ] LT';
	            },
	            lastWeek: function () {
	                return '[] dddd [ ] LT';
	            },
	            sameElse: 'L'
	        },
	        relativeTime : {
	            future : '%s ',
	            past : '%s ',
	            s : '  ',
	            m : '',
	            mm : '%d ',
	            h : '',
	            hh : '%d ',
	            d : '',
	            dd : '%d ',
	            M : '',
	            MM : '%d ',
	            y : '',
	            yy : '%d '
	        },
	        meridiemParse: /|||/,
	        isPM: function (input) {
	            return /^(|)$/.test(input);
	        },
	        meridiem : function (hour) {
	            if (hour < 4) {
	                return '';
	            } else if (hour < 12) {
	                return '';
	            } else if (hour < 17) {
	                return '';
	            } else {
	                return '';
	            }
	        },
	        ordinalParse: /\d{1,2}|\d{1,2}-(|)/,
	        ordinal: function (number, period) {
	            switch (period) {
	            case 'DDD':
	            case 'w':
	            case 'W':
	            case 'DDDo':
	                if (number === 1) {
	                    return number + '-';
	                }
	                return number + '-';
	            default:
	                return number;
	            }
	        },
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 7  // The week that contains Jan 1st is the first week of the year.
	        }
	    });

	    return hy_am;

	}));

/***/ },
/* 97 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Bahasa Indonesia (id)
	//! author : Mohammad Satrio Utomo : https://github.com/tyok
	//! reference: http://id.wikisource.org/wiki/Pedoman_Umum_Ejaan_Bahasa_Indonesia_yang_Disempurnakan

	(function (global, factory) {
	    true ? factory(__webpack_require__(56)) :
	   typeof define === 'function' && define.amd ? define(['moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';


	    var id = moment.defineLocale('id', {
	        months : 'Januari_Februari_Maret_April_Mei_Juni_Juli_Agustus_September_Oktober_November_Desember'.split('_'),
	        monthsShort : 'Jan_Feb_Mar_Apr_Mei_Jun_Jul_Ags_Sep_Okt_Nov_Des'.split('_'),
	        weekdays : 'Minggu_Senin_Selasa_Rabu_Kamis_Jumat_Sabtu'.split('_'),
	        weekdaysShort : 'Min_Sen_Sel_Rab_Kam_Jum_Sab'.split('_'),
	        weekdaysMin : 'Mg_Sn_Sl_Rb_Km_Jm_Sb'.split('_'),
	        longDateFormat : {
	            LT : 'HH.mm',
	            LTS : 'HH.mm.ss',
	            L : 'DD/MM/YYYY',
	            LL : 'D MMMM YYYY',
	            LLL : 'D MMMM YYYY [pukul] HH.mm',
	            LLLL : 'dddd, D MMMM YYYY [pukul] HH.mm'
	        },
	        meridiemParse: /pagi|siang|sore|malam/,
	        meridiemHour : function (hour, meridiem) {
	            if (hour === 12) {
	                hour = 0;
	            }
	            if (meridiem === 'pagi') {
	                return hour;
	            } else if (meridiem === 'siang') {
	                return hour >= 11 ? hour : hour + 12;
	            } else if (meridiem === 'sore' || meridiem === 'malam') {
	                return hour + 12;
	            }
	        },
	        meridiem : function (hours, minutes, isLower) {
	            if (hours < 11) {
	                return 'pagi';
	            } else if (hours < 15) {
	                return 'siang';
	            } else if (hours < 19) {
	                return 'sore';
	            } else {
	                return 'malam';
	            }
	        },
	        calendar : {
	            sameDay : '[Hari ini pukul] LT',
	            nextDay : '[Besok pukul] LT',
	            nextWeek : 'dddd [pukul] LT',
	            lastDay : '[Kemarin pukul] LT',
	            lastWeek : 'dddd [lalu pukul] LT',
	            sameElse : 'L'
	        },
	        relativeTime : {
	            future : 'dalam %s',
	            past : '%s yang lalu',
	            s : 'beberapa detik',
	            m : 'semenit',
	            mm : '%d menit',
	            h : 'sejam',
	            hh : '%d jam',
	            d : 'sehari',
	            dd : '%d hari',
	            M : 'sebulan',
	            MM : '%d bulan',
	            y : 'setahun',
	            yy : '%d tahun'
	        },
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 7  // The week that contains Jan 1st is the first week of the year.
	        }
	    });

	    return id;

	}));

/***/ },
/* 98 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : icelandic (is)
	//! author : Hinrik rn Sigursson : https://github.com/hinrik

	(function (global, factory) {
	    true ? factory(__webpack_require__(56)) :
	   typeof define === 'function' && define.amd ? define(['moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';


	    function plural(n) {
	        if (n % 100 === 11) {
	            return true;
	        } else if (n % 10 === 1) {
	            return false;
	        }
	        return true;
	    }
	    function translate(number, withoutSuffix, key, isFuture) {
	        var result = number + ' ';
	        switch (key) {
	        case 's':
	            return withoutSuffix || isFuture ? 'nokkrar sekndur' : 'nokkrum sekndum';
	        case 'm':
	            return withoutSuffix ? 'mnta' : 'mntu';
	        case 'mm':
	            if (plural(number)) {
	                return result + (withoutSuffix || isFuture ? 'mntur' : 'mntum');
	            } else if (withoutSuffix) {
	                return result + 'mnta';
	            }
	            return result + 'mntu';
	        case 'hh':
	            if (plural(number)) {
	                return result + (withoutSuffix || isFuture ? 'klukkustundir' : 'klukkustundum');
	            }
	            return result + 'klukkustund';
	        case 'd':
	            if (withoutSuffix) {
	                return 'dagur';
	            }
	            return isFuture ? 'dag' : 'degi';
	        case 'dd':
	            if (plural(number)) {
	                if (withoutSuffix) {
	                    return result + 'dagar';
	                }
	                return result + (isFuture ? 'daga' : 'dgum');
	            } else if (withoutSuffix) {
	                return result + 'dagur';
	            }
	            return result + (isFuture ? 'dag' : 'degi');
	        case 'M':
	            if (withoutSuffix) {
	                return 'mnuur';
	            }
	            return isFuture ? 'mnu' : 'mnui';
	        case 'MM':
	            if (plural(number)) {
	                if (withoutSuffix) {
	                    return result + 'mnuir';
	                }
	                return result + (isFuture ? 'mnui' : 'mnuum');
	            } else if (withoutSuffix) {
	                return result + 'mnuur';
	            }
	            return result + (isFuture ? 'mnu' : 'mnui');
	        case 'y':
	            return withoutSuffix || isFuture ? 'r' : 'ri';
	        case 'yy':
	            if (plural(number)) {
	                return result + (withoutSuffix || isFuture ? 'r' : 'rum');
	            }
	            return result + (withoutSuffix || isFuture ? 'r' : 'ri');
	        }
	    }

	    var is = moment.defineLocale('is', {
	        months : 'janar_febrar_mars_aprl_ma_jn_jl_gst_september_oktber_nvember_desember'.split('_'),
	        monthsShort : 'jan_feb_mar_apr_ma_jn_jl_g_sep_okt_nv_des'.split('_'),
	        weekdays : 'sunnudagur_mnudagur_rijudagur_mivikudagur_fimmtudagur_fstudagur_laugardagur'.split('_'),
	        weekdaysShort : 'sun_mn_ri_mi_fim_fs_lau'.split('_'),
	        weekdaysMin : 'Su_M_r_Mi_Fi_F_La'.split('_'),
	        longDateFormat : {
	            LT : 'H:mm',
	            LTS : 'H:mm:ss',
	            L : 'DD/MM/YYYY',
	            LL : 'D. MMMM YYYY',
	            LLL : 'D. MMMM YYYY [kl.] H:mm',
	            LLLL : 'dddd, D. MMMM YYYY [kl.] H:mm'
	        },
	        calendar : {
	            sameDay : '[ dag kl.] LT',
	            nextDay : '[ morgun kl.] LT',
	            nextWeek : 'dddd [kl.] LT',
	            lastDay : '[ gr kl.] LT',
	            lastWeek : '[sasta] dddd [kl.] LT',
	            sameElse : 'L'
	        },
	        relativeTime : {
	            future : 'eftir %s',
	            past : 'fyrir %s san',
	            s : translate,
	            m : translate,
	            mm : translate,
	            h : 'klukkustund',
	            hh : translate,
	            d : translate,
	            dd : translate,
	            M : translate,
	            MM : translate,
	            y : translate,
	            yy : translate
	        },
	        ordinalParse: /\d{1,2}\./,
	        ordinal : '%d.',
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 4  // The week that contains Jan 4th is the first week of the year.
	        }
	    });

	    return is;

	}));

/***/ },
/* 99 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : italian (it)
	//! author : Lorenzo : https://github.com/aliem
	//! author: Mattia Larentis: https://github.com/nostalgiaz

	(function (global, factory) {
	    true ? factory(__webpack_require__(56)) :
	   typeof define === 'function' && define.amd ? define(['moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';


	    var it = moment.defineLocale('it', {
	        months : 'gennaio_febbraio_marzo_aprile_maggio_giugno_luglio_agosto_settembre_ottobre_novembre_dicembre'.split('_'),
	        monthsShort : 'gen_feb_mar_apr_mag_giu_lug_ago_set_ott_nov_dic'.split('_'),
	        weekdays : 'Domenica_Luned_Marted_Mercoled_Gioved_Venerd_Sabato'.split('_'),
	        weekdaysShort : 'Dom_Lun_Mar_Mer_Gio_Ven_Sab'.split('_'),
	        weekdaysMin : 'D_L_Ma_Me_G_V_S'.split('_'),
	        longDateFormat : {
	            LT : 'HH:mm',
	            LTS : 'HH:mm:ss',
	            L : 'DD/MM/YYYY',
	            LL : 'D MMMM YYYY',
	            LLL : 'D MMMM YYYY HH:mm',
	            LLLL : 'dddd, D MMMM YYYY HH:mm'
	        },
	        calendar : {
	            sameDay: '[Oggi alle] LT',
	            nextDay: '[Domani alle] LT',
	            nextWeek: 'dddd [alle] LT',
	            lastDay: '[Ieri alle] LT',
	            lastWeek: function () {
	                switch (this.day()) {
	                    case 0:
	                        return '[la scorsa] dddd [alle] LT';
	                    default:
	                        return '[lo scorso] dddd [alle] LT';
	                }
	            },
	            sameElse: 'L'
	        },
	        relativeTime : {
	            future : function (s) {
	                return ((/^[0-9].+$/).test(s) ? 'tra' : 'in') + ' ' + s;
	            },
	            past : '%s fa',
	            s : 'alcuni secondi',
	            m : 'un minuto',
	            mm : '%d minuti',
	            h : 'un\'ora',
	            hh : '%d ore',
	            d : 'un giorno',
	            dd : '%d giorni',
	            M : 'un mese',
	            MM : '%d mesi',
	            y : 'un anno',
	            yy : '%d anni'
	        },
	        ordinalParse : /\d{1,2}/,
	        ordinal: '%d',
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 4  // The week that contains Jan 4th is the first week of the year.
	        }
	    });

	    return it;

	}));

/***/ },
/* 100 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : japanese (ja)
	//! author : LI Long : https://github.com/baryon

	(function (global, factory) {
	    true ? factory(__webpack_require__(56)) :
	   typeof define === 'function' && define.amd ? define(['moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';


	    var ja = moment.defineLocale('ja', {
	        months : '1_2_3_4_5_6_7_8_9_10_11_12'.split('_'),
	        monthsShort : '1_2_3_4_5_6_7_8_9_10_11_12'.split('_'),
	        weekdays : '______'.split('_'),
	        weekdaysShort : '______'.split('_'),
	        weekdaysMin : '______'.split('_'),
	        longDateFormat : {
	            LT : 'Ahm',
	            LTS : 'Ahms',
	            L : 'YYYY/MM/DD',
	            LL : 'YYYYMD',
	            LLL : 'YYYYMDAhm',
	            LLLL : 'YYYYMDAhm dddd'
	        },
	        meridiemParse: /|/i,
	        isPM : function (input) {
	            return input === '';
	        },
	        meridiem : function (hour, minute, isLower) {
	            if (hour < 12) {
	                return '';
	            } else {
	                return '';
	            }
	        },
	        calendar : {
	            sameDay : '[] LT',
	            nextDay : '[] LT',
	            nextWeek : '[]dddd LT',
	            lastDay : '[] LT',
	            lastWeek : '[]dddd LT',
	            sameElse : 'L'
	        },
	        relativeTime : {
	            future : '%s',
	            past : '%s',
	            s : '',
	            m : '1',
	            mm : '%d',
	            h : '1',
	            hh : '%d',
	            d : '1',
	            dd : '%d',
	            M : '1',
	            MM : '%d',
	            y : '1',
	            yy : '%d'
	        }
	    });

	    return ja;

	}));

/***/ },
/* 101 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Boso Jowo (jv)
	//! author : Rony Lantip : https://github.com/lantip
	//! reference: http://jv.wikipedia.org/wiki/Basa_Jawa

	(function (global, factory) {
	    true ? factory(__webpack_require__(56)) :
	   typeof define === 'function' && define.amd ? define(['moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';


	    var jv = moment.defineLocale('jv', {
	        months : 'Januari_Februari_Maret_April_Mei_Juni_Juli_Agustus_September_Oktober_Nopember_Desember'.split('_'),
	        monthsShort : 'Jan_Feb_Mar_Apr_Mei_Jun_Jul_Ags_Sep_Okt_Nop_Des'.split('_'),
	        weekdays : 'Minggu_Senen_Seloso_Rebu_Kemis_Jemuwah_Septu'.split('_'),
	        weekdaysShort : 'Min_Sen_Sel_Reb_Kem_Jem_Sep'.split('_'),
	        weekdaysMin : 'Mg_Sn_Sl_Rb_Km_Jm_Sp'.split('_'),
	        longDateFormat : {
	            LT : 'HH.mm',
	            LTS : 'HH.mm.ss',
	            L : 'DD/MM/YYYY',
	            LL : 'D MMMM YYYY',
	            LLL : 'D MMMM YYYY [pukul] HH.mm',
	            LLLL : 'dddd, D MMMM YYYY [pukul] HH.mm'
	        },
	        meridiemParse: /enjing|siyang|sonten|ndalu/,
	        meridiemHour : function (hour, meridiem) {
	            if (hour === 12) {
	                hour = 0;
	            }
	            if (meridiem === 'enjing') {
	                return hour;
	            } else if (meridiem === 'siyang') {
	                return hour >= 11 ? hour : hour + 12;
	            } else if (meridiem === 'sonten' || meridiem === 'ndalu') {
	                return hour + 12;
	            }
	        },
	        meridiem : function (hours, minutes, isLower) {
	            if (hours < 11) {
	                return 'enjing';
	            } else if (hours < 15) {
	                return 'siyang';
	            } else if (hours < 19) {
	                return 'sonten';
	            } else {
	                return 'ndalu';
	            }
	        },
	        calendar : {
	            sameDay : '[Dinten puniko pukul] LT',
	            nextDay : '[Mbenjang pukul] LT',
	            nextWeek : 'dddd [pukul] LT',
	            lastDay : '[Kala wingi pukul] LT',
	            lastWeek : 'dddd [kepengker pukul] LT',
	            sameElse : 'L'
	        },
	        relativeTime : {
	            future : 'wonten ing %s',
	            past : '%s ingkang kepengker',
	            s : 'sawetawis detik',
	            m : 'setunggal menit',
	            mm : '%d menit',
	            h : 'setunggal jam',
	            hh : '%d jam',
	            d : 'sedinten',
	            dd : '%d dinten',
	            M : 'sewulan',
	            MM : '%d wulan',
	            y : 'setaun',
	            yy : '%d taun'
	        },
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 7  // The week that contains Jan 1st is the first week of the year.
	        }
	    });

	    return jv;

	}));

/***/ },
/* 102 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Georgian (ka)
	//! author : Irakli Janiashvili : https://github.com/irakli-janiashvili

	(function (global, factory) {
	    true ? factory(__webpack_require__(56)) :
	   typeof define === 'function' && define.amd ? define(['moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';


	    function monthsCaseReplace(m, format) {
	        var months = {
	            'nominative': '___________'.split('_'),
	            'accusative': '___________'.split('_')
	        },
	        nounCase = (/D[oD] *MMMM?/).test(format) ?
	            'accusative' :
	            'nominative';
	        return months[nounCase][m.month()];
	    }
	    function weekdaysCaseReplace(m, format) {
	        var weekdays = {
	            'nominative': '______'.split('_'),
	            'accusative': '______'.split('_')
	        },
	        nounCase = (/(|)/).test(format) ?
	            'accusative' :
	            'nominative';
	        return weekdays[nounCase][m.day()];
	    }

	    var ka = moment.defineLocale('ka', {
	        months : monthsCaseReplace,
	        monthsShort : '___________'.split('_'),
	        weekdays : weekdaysCaseReplace,
	        weekdaysShort : '______'.split('_'),
	        weekdaysMin : '______'.split('_'),
	        longDateFormat : {
	            LT : 'h:mm A',
	            LTS : 'h:mm:ss A',
	            L : 'DD/MM/YYYY',
	            LL : 'D MMMM YYYY',
	            LLL : 'D MMMM YYYY h:mm A',
	            LLLL : 'dddd, D MMMM YYYY h:mm A'
	        },
	        calendar : {
	            sameDay : '[] LT[-]',
	            nextDay : '[] LT[-]',
	            lastDay : '[] LT[-]',
	            nextWeek : '[] dddd LT[-]',
	            lastWeek : '[] dddd LT-',
	            sameElse : 'L'
	        },
	        relativeTime : {
	            future : function (s) {
	                return (/(|||)/).test(s) ?
	                    s.replace(/$/, '') :
	                    s + '';
	            },
	            past : function (s) {
	                if ((/(||||)/).test(s)) {
	                    return s.replace(/(|)$/, ' ');
	                }
	                if ((//).test(s)) {
	                    return s.replace(/$/, ' ');
	                }
	            },
	            s : ' ',
	            m : '',
	            mm : '%d ',
	            h : '',
	            hh : '%d ',
	            d : '',
	            dd : '%d ',
	            M : '',
	            MM : '%d ',
	            y : '',
	            yy : '%d '
	        },
	        ordinalParse: /0|1-|-\d{1,2}|\d{1,2}-/,
	        ordinal : function (number) {
	            if (number === 0) {
	                return number;
	            }
	            if (number === 1) {
	                return number + '-';
	            }
	            if ((number < 20) || (number <= 100 && (number % 20 === 0)) || (number % 100 === 0)) {
	                return '-' + number;
	            }
	            return number + '-';
	        },
	        week : {
	            dow : 1,
	            doy : 7
	        }
	    });

	    return ka;

	}));

/***/ },
/* 103 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : khmer (km)
	//! author : Kruy Vanna : https://github.com/kruyvanna

	(function (global, factory) {
	    true ? factory(__webpack_require__(56)) :
	   typeof define === 'function' && define.amd ? define(['moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';


	    var km = moment.defineLocale('km', {
	        months: '___________'.split('_'),
	        monthsShort: '___________'.split('_'),
	        weekdays: '______'.split('_'),
	        weekdaysShort: '______'.split('_'),
	        weekdaysMin: '______'.split('_'),
	        longDateFormat: {
	            LT: 'HH:mm',
	            LTS : 'HH:mm:ss',
	            L: 'DD/MM/YYYY',
	            LL: 'D MMMM YYYY',
	            LLL: 'D MMMM YYYY HH:mm',
	            LLLL: 'dddd, D MMMM YYYY HH:mm'
	        },
	        calendar: {
	            sameDay: '[ ] LT',
	            nextDay: '[ ] LT',
	            nextWeek: 'dddd [] LT',
	            lastDay: '[ ] LT',
	            lastWeek: 'dddd [] [] LT',
	            sameElse: 'L'
	        },
	        relativeTime: {
	            future: '%s',
	            past: '%s',
	            s: '',
	            m: '',
	            mm: '%d ',
	            h: '',
	            hh: '%d ',
	            d: '',
	            dd: '%d ',
	            M: '',
	            MM: '%d ',
	            y: '',
	            yy: '%d '
	        },
	        week: {
	            dow: 1, // Monday is the first day of the week.
	            doy: 4 // The week that contains Jan 4th is the first week of the year.
	        }
	    });

	    return km;

	}));

/***/ },
/* 104 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : korean (ko)
	//!
	//! authors
	//!
	//! - Kyungwook, Park : https://github.com/kyungw00k
	//! - Jeeeyul Lee <jeeeyul@gmail.com>

	(function (global, factory) {
	    true ? factory(__webpack_require__(56)) :
	   typeof define === 'function' && define.amd ? define(['moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';


	    var ko = moment.defineLocale('ko', {
	        months : '1_2_3_4_5_6_7_8_9_10_11_12'.split('_'),
	        monthsShort : '1_2_3_4_5_6_7_8_9_10_11_12'.split('_'),
	        weekdays : '______'.split('_'),
	        weekdaysShort : '______'.split('_'),
	        weekdaysMin : '______'.split('_'),
	        longDateFormat : {
	            LT : 'A h m',
	            LTS : 'A h m s',
	            L : 'YYYY.MM.DD',
	            LL : 'YYYY MMMM D',
	            LLL : 'YYYY MMMM D A h m',
	            LLLL : 'YYYY MMMM D dddd A h m'
	        },
	        calendar : {
	            sameDay : ' LT',
	            nextDay : ' LT',
	            nextWeek : 'dddd LT',
	            lastDay : ' LT',
	            lastWeek : ' dddd LT',
	            sameElse : 'L'
	        },
	        relativeTime : {
	            future : '%s ',
	            past : '%s ',
	            s : '',
	            ss : '%d',
	            m : '',
	            mm : '%d',
	            h : '',
	            hh : '%d',
	            d : '',
	            dd : '%d',
	            M : '',
	            MM : '%d',
	            y : '',
	            yy : '%d'
	        },
	        ordinalParse : /\d{1,2}/,
	        ordinal : '%d',
	        meridiemParse : /|/,
	        isPM : function (token) {
	            return token === '';
	        },
	        meridiem : function (hour, minute, isUpper) {
	            return hour < 12 ? '' : '';
	        }
	    });

	    return ko;

	}));

/***/ },
/* 105 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Luxembourgish (lb)
	//! author : mweimerskirch : https://github.com/mweimerskirch, David Raison : https://github.com/kwisatz

	(function (global, factory) {
	    true ? factory(__webpack_require__(56)) :
	   typeof define === 'function' && define.amd ? define(['moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';


	    function processRelativeTime(number, withoutSuffix, key, isFuture) {
	        var format = {
	            'm': ['eng Minutt', 'enger Minutt'],
	            'h': ['eng Stonn', 'enger Stonn'],
	            'd': ['een Dag', 'engem Dag'],
	            'M': ['ee Mount', 'engem Mount'],
	            'y': ['ee Joer', 'engem Joer']
	        };
	        return withoutSuffix ? format[key][0] : format[key][1];
	    }
	    function processFutureTime(string) {
	        var number = string.substr(0, string.indexOf(' '));
	        if (eifelerRegelAppliesToNumber(number)) {
	            return 'a ' + string;
	        }
	        return 'an ' + string;
	    }
	    function processPastTime(string) {
	        var number = string.substr(0, string.indexOf(' '));
	        if (eifelerRegelAppliesToNumber(number)) {
	            return 'viru ' + string;
	        }
	        return 'virun ' + string;
	    }
	    /**
	     * Returns true if the word before the given number loses the '-n' ending.
	     * e.g. 'an 10 Deeg' but 'a 5 Deeg'
	     *
	     * @param number {integer}
	     * @returns {boolean}
	     */
	    function eifelerRegelAppliesToNumber(number) {
	        number = parseInt(number, 10);
	        if (isNaN(number)) {
	            return false;
	        }
	        if (number < 0) {
	            // Negative Number --> always true
	            return true;
	        } else if (number < 10) {
	            // Only 1 digit
	            if (4 <= number && number <= 7) {
	                return true;
	            }
	            return false;
	        } else if (number < 100) {
	            // 2 digits
	            var lastDigit = number % 10, firstDigit = number / 10;
	            if (lastDigit === 0) {
	                return eifelerRegelAppliesToNumber(firstDigit);
	            }
	            return eifelerRegelAppliesToNumber(lastDigit);
	        } else if (number < 10000) {
	            // 3 or 4 digits --> recursively check first digit
	            while (number >= 10) {
	                number = number / 10;
	            }
	            return eifelerRegelAppliesToNumber(number);
	        } else {
	            // Anything larger than 4 digits: recursively check first n-3 digits
	            number = number / 1000;
	            return eifelerRegelAppliesToNumber(number);
	        }
	    }

	    var lb = moment.defineLocale('lb', {
	        months: 'Januar_Februar_Merz_Abrll_Mee_Juni_Juli_August_September_Oktober_November_Dezember'.split('_'),
	        monthsShort: 'Jan._Febr._Mrz._Abr._Mee_Jun._Jul._Aug._Sept._Okt._Nov._Dez.'.split('_'),
	        weekdays: 'Sonndeg_Mindeg_Dnschdeg_Mttwoch_Donneschdeg_Freideg_Samschdeg'.split('_'),
	        weekdaysShort: 'So._M._D._M._Do._Fr._Sa.'.split('_'),
	        weekdaysMin: 'So_M_D_M_Do_Fr_Sa'.split('_'),
	        longDateFormat: {
	            LT: 'H:mm [Auer]',
	            LTS: 'H:mm:ss [Auer]',
	            L: 'DD.MM.YYYY',
	            LL: 'D. MMMM YYYY',
	            LLL: 'D. MMMM YYYY H:mm [Auer]',
	            LLLL: 'dddd, D. MMMM YYYY H:mm [Auer]'
	        },
	        calendar: {
	            sameDay: '[Haut um] LT',
	            sameElse: 'L',
	            nextDay: '[Muer um] LT',
	            nextWeek: 'dddd [um] LT',
	            lastDay: '[Gschter um] LT',
	            lastWeek: function () {
	                // Different date string for 'Dnschdeg' (Tuesday) and 'Donneschdeg' (Thursday) due to phonological rule
	                switch (this.day()) {
	                    case 2:
	                    case 4:
	                        return '[Leschten] dddd [um] LT';
	                    default:
	                        return '[Leschte] dddd [um] LT';
	                }
	            }
	        },
	        relativeTime : {
	            future : processFutureTime,
	            past : processPastTime,
	            s : 'e puer Sekonnen',
	            m : processRelativeTime,
	            mm : '%d Minutten',
	            h : processRelativeTime,
	            hh : '%d Stonnen',
	            d : processRelativeTime,
	            dd : '%d Deeg',
	            M : processRelativeTime,
	            MM : '%d Mint',
	            y : processRelativeTime,
	            yy : '%d Joer'
	        },
	        ordinalParse: /\d{1,2}\./,
	        ordinal: '%d.',
	        week: {
	            dow: 1, // Monday is the first day of the week.
	            doy: 4  // The week that contains Jan 4th is the first week of the year.
	        }
	    });

	    return lb;

	}));

/***/ },
/* 106 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Lithuanian (lt)
	//! author : Mindaugas Mozras : https://github.com/mmozuras

	(function (global, factory) {
	    true ? factory(__webpack_require__(56)) :
	   typeof define === 'function' && define.amd ? define(['moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';


	    var units = {
	        'm' : 'minut_minuts_minut',
	        'mm': 'minuts_minui_minutes',
	        'h' : 'valanda_valandos_valand',
	        'hh': 'valandos_valand_valandas',
	        'd' : 'diena_dienos_dien',
	        'dd': 'dienos_dien_dienas',
	        'M' : 'mnuo_mnesio_mnes',
	        'MM': 'mnesiai_mnesi_mnesius',
	        'y' : 'metai_met_metus',
	        'yy': 'metai_met_metus'
	    },
	    weekDays = 'sekmadienis_pirmadienis_antradienis_treiadienis_ketvirtadienis_penktadienis_etadienis'.split('_');
	    function translateSeconds(number, withoutSuffix, key, isFuture) {
	        if (withoutSuffix) {
	            return 'kelios sekunds';
	        } else {
	            return isFuture ? 'keli sekundi' : 'kelias sekundes';
	        }
	    }
	    function monthsCaseReplace(m, format) {
	        var months = {
	                'nominative': 'sausis_vasaris_kovas_balandis_gegu_birelis_liepa_rugpjtis_rugsjis_spalis_lapkritis_gruodis'.split('_'),
	                'accusative': 'sausio_vasario_kovo_balandio_gegus_birelio_liepos_rugpjio_rugsjo_spalio_lapkriio_gruodio'.split('_')
	            },
	            nounCase = (/D[oD]?(\[[^\[\]]*\]|\s+)+MMMM?/).test(format) ?
	                'accusative' :
	                'nominative';
	        return months[nounCase][m.month()];
	    }
	    function translateSingular(number, withoutSuffix, key, isFuture) {
	        return withoutSuffix ? forms(key)[0] : (isFuture ? forms(key)[1] : forms(key)[2]);
	    }
	    function special(number) {
	        return number % 10 === 0 || (number > 10 && number < 20);
	    }
	    function forms(key) {
	        return units[key].split('_');
	    }
	    function translate(number, withoutSuffix, key, isFuture) {
	        var result = number + ' ';
	        if (number === 1) {
	            return result + translateSingular(number, withoutSuffix, key[0], isFuture);
	        } else if (withoutSuffix) {
	            return result + (special(number) ? forms(key)[1] : forms(key)[0]);
	        } else {
	            if (isFuture) {
	                return result + forms(key)[1];
	            } else {
	                return result + (special(number) ? forms(key)[1] : forms(key)[2]);
	            }
	        }
	    }
	    function relativeWeekDay(moment, format) {
	        var nominative = format.indexOf('dddd HH:mm') === -1,
	            weekDay = weekDays[moment.day()];
	        return nominative ? weekDay : weekDay.substring(0, weekDay.length - 2) + '';
	    }

	    var lt = moment.defineLocale('lt', {
	        months : monthsCaseReplace,
	        monthsShort : 'sau_vas_kov_bal_geg_bir_lie_rgp_rgs_spa_lap_grd'.split('_'),
	        weekdays : relativeWeekDay,
	        weekdaysShort : 'Sek_Pir_Ant_Tre_Ket_Pen_e'.split('_'),
	        weekdaysMin : 'S_P_A_T_K_Pn_'.split('_'),
	        longDateFormat : {
	            LT : 'HH:mm',
	            LTS : 'HH:mm:ss',
	            L : 'YYYY-MM-DD',
	            LL : 'YYYY [m.] MMMM D [d.]',
	            LLL : 'YYYY [m.] MMMM D [d.], HH:mm [val.]',
	            LLLL : 'YYYY [m.] MMMM D [d.], dddd, HH:mm [val.]',
	            l : 'YYYY-MM-DD',
	            ll : 'YYYY [m.] MMMM D [d.]',
	            lll : 'YYYY [m.] MMMM D [d.], HH:mm [val.]',
	            llll : 'YYYY [m.] MMMM D [d.], ddd, HH:mm [val.]'
	        },
	        calendar : {
	            sameDay : '[iandien] LT',
	            nextDay : '[Rytoj] LT',
	            nextWeek : 'dddd LT',
	            lastDay : '[Vakar] LT',
	            lastWeek : '[Prajus] dddd LT',
	            sameElse : 'L'
	        },
	        relativeTime : {
	            future : 'po %s',
	            past : 'prie %s',
	            s : translateSeconds,
	            m : translateSingular,
	            mm : translate,
	            h : translateSingular,
	            hh : translate,
	            d : translateSingular,
	            dd : translate,
	            M : translateSingular,
	            MM : translate,
	            y : translateSingular,
	            yy : translate
	        },
	        ordinalParse: /\d{1,2}-oji/,
	        ordinal : function (number) {
	            return number + '-oji';
	        },
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 4  // The week that contains Jan 4th is the first week of the year.
	        }
	    });

	    return lt;

	}));

/***/ },
/* 107 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : latvian (lv)
	//! author : Kristaps Karlsons : https://github.com/skakri
	//! author : Jnis Elmeris : https://github.com/JanisE

	(function (global, factory) {
	    true ? factory(__webpack_require__(56)) :
	   typeof define === 'function' && define.amd ? define(['moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';


	    var units = {
	        'm': 'mintes_mintm_minte_mintes'.split('_'),
	        'mm': 'mintes_mintm_minte_mintes'.split('_'),
	        'h': 'stundas_stundm_stunda_stundas'.split('_'),
	        'hh': 'stundas_stundm_stunda_stundas'.split('_'),
	        'd': 'dienas_dienm_diena_dienas'.split('_'),
	        'dd': 'dienas_dienm_diena_dienas'.split('_'),
	        'M': 'mnea_mneiem_mnesis_mnei'.split('_'),
	        'MM': 'mnea_mneiem_mnesis_mnei'.split('_'),
	        'y': 'gada_gadiem_gads_gadi'.split('_'),
	        'yy': 'gada_gadiem_gads_gadi'.split('_')
	    };
	    /**
	     * @param withoutSuffix boolean true = a length of time; false = before/after a period of time.
	     */
	    function format(forms, number, withoutSuffix) {
	        if (withoutSuffix) {
	            // E.g. "21 minte", "3 mintes".
	            return number % 10 === 1 && number !== 11 ? forms[2] : forms[3];
	        } else {
	            // E.g. "21 mintes" as in "pc 21 mintes".
	            // E.g. "3 mintm" as in "pc 3 mintm".
	            return number % 10 === 1 && number !== 11 ? forms[0] : forms[1];
	        }
	    }
	    function relativeTimeWithPlural(number, withoutSuffix, key) {
	        return number + ' ' + format(units[key], number, withoutSuffix);
	    }
	    function relativeTimeWithSingular(number, withoutSuffix, key) {
	        return format(units[key], number, withoutSuffix);
	    }
	    function relativeSeconds(number, withoutSuffix) {
	        return withoutSuffix ? 'daas sekundes' : 'dam sekundm';
	    }

	    var lv = moment.defineLocale('lv', {
	        months : 'janvris_februris_marts_aprlis_maijs_jnijs_jlijs_augusts_septembris_oktobris_novembris_decembris'.split('_'),
	        monthsShort : 'jan_feb_mar_apr_mai_jn_jl_aug_sep_okt_nov_dec'.split('_'),
	        weekdays : 'svtdiena_pirmdiena_otrdiena_trediena_ceturtdiena_piektdiena_sestdiena'.split('_'),
	        weekdaysShort : 'Sv_P_O_T_C_Pk_S'.split('_'),
	        weekdaysMin : 'Sv_P_O_T_C_Pk_S'.split('_'),
	        longDateFormat : {
	            LT : 'HH:mm',
	            LTS : 'HH:mm:ss',
	            L : 'DD.MM.YYYY.',
	            LL : 'YYYY. [gada] D. MMMM',
	            LLL : 'YYYY. [gada] D. MMMM, HH:mm',
	            LLLL : 'YYYY. [gada] D. MMMM, dddd, HH:mm'
	        },
	        calendar : {
	            sameDay : '[odien pulksten] LT',
	            nextDay : '[Rt pulksten] LT',
	            nextWeek : 'dddd [pulksten] LT',
	            lastDay : '[Vakar pulksten] LT',
	            lastWeek : '[Pagju] dddd [pulksten] LT',
	            sameElse : 'L'
	        },
	        relativeTime : {
	            future : 'pc %s',
	            past : 'pirms %s',
	            s : relativeSeconds,
	            m : relativeTimeWithSingular,
	            mm : relativeTimeWithPlural,
	            h : relativeTimeWithSingular,
	            hh : relativeTimeWithPlural,
	            d : relativeTimeWithSingular,
	            dd : relativeTimeWithPlural,
	            M : relativeTimeWithSingular,
	            MM : relativeTimeWithPlural,
	            y : relativeTimeWithSingular,
	            yy : relativeTimeWithPlural
	        },
	        ordinalParse: /\d{1,2}\./,
	        ordinal : '%d.',
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 4  // The week that contains Jan 4th is the first week of the year.
	        }
	    });

	    return lv;

	}));

/***/ },
/* 108 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Montenegrin (me)
	//! author : Miodrag Nika <miodrag@restartit.me> : https://github.com/miodragnikac

	(function (global, factory) {
	    true ? factory(__webpack_require__(56)) :
	   typeof define === 'function' && define.amd ? define(['moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';


	    var translator = {
	        words: { //Different grammatical cases
	            m: ['jedan minut', 'jednog minuta'],
	            mm: ['minut', 'minuta', 'minuta'],
	            h: ['jedan sat', 'jednog sata'],
	            hh: ['sat', 'sata', 'sati'],
	            dd: ['dan', 'dana', 'dana'],
	            MM: ['mjesec', 'mjeseca', 'mjeseci'],
	            yy: ['godina', 'godine', 'godina']
	        },
	        correctGrammaticalCase: function (number, wordKey) {
	            return number === 1 ? wordKey[0] : (number >= 2 && number <= 4 ? wordKey[1] : wordKey[2]);
	        },
	        translate: function (number, withoutSuffix, key) {
	            var wordKey = translator.words[key];
	            if (key.length === 1) {
	                return withoutSuffix ? wordKey[0] : wordKey[1];
	            } else {
	                return number + ' ' + translator.correctGrammaticalCase(number, wordKey);
	            }
	        }
	    };

	    var me = moment.defineLocale('me', {
	        months: ['januar', 'februar', 'mart', 'april', 'maj', 'jun', 'jul', 'avgust', 'septembar', 'oktobar', 'novembar', 'decembar'],
	        monthsShort: ['jan.', 'feb.', 'mar.', 'apr.', 'maj', 'jun', 'jul', 'avg.', 'sep.', 'okt.', 'nov.', 'dec.'],
	        weekdays: ['nedjelja', 'ponedjeljak', 'utorak', 'srijeda', 'etvrtak', 'petak', 'subota'],
	        weekdaysShort: ['ned.', 'pon.', 'uto.', 'sri.', 'et.', 'pet.', 'sub.'],
	        weekdaysMin: ['ne', 'po', 'ut', 'sr', 'e', 'pe', 'su'],
	        longDateFormat: {
	            LT: 'H:mm',
	            LTS : 'H:mm:ss',
	            L: 'DD. MM. YYYY',
	            LL: 'D. MMMM YYYY',
	            LLL: 'D. MMMM YYYY H:mm',
	            LLLL: 'dddd, D. MMMM YYYY H:mm'
	        },
	        calendar: {
	            sameDay: '[danas u] LT',
	            nextDay: '[sjutra u] LT',

	            nextWeek: function () {
	                switch (this.day()) {
	                case 0:
	                    return '[u] [nedjelju] [u] LT';
	                case 3:
	                    return '[u] [srijedu] [u] LT';
	                case 6:
	                    return '[u] [subotu] [u] LT';
	                case 1:
	                case 2:
	                case 4:
	                case 5:
	                    return '[u] dddd [u] LT';
	                }
	            },
	            lastDay  : '[jue u] LT',
	            lastWeek : function () {
	                var lastWeekDays = [
	                    '[prole] [nedjelje] [u] LT',
	                    '[prolog] [ponedjeljka] [u] LT',
	                    '[prolog] [utorka] [u] LT',
	                    '[prole] [srijede] [u] LT',
	                    '[prolog] [etvrtka] [u] LT',
	                    '[prolog] [petka] [u] LT',
	                    '[prole] [subote] [u] LT'
	                ];
	                return lastWeekDays[this.day()];
	            },
	            sameElse : 'L'
	        },
	        relativeTime : {
	            future : 'za %s',
	            past   : 'prije %s',
	            s      : 'nekoliko sekundi',
	            m      : translator.translate,
	            mm     : translator.translate,
	            h      : translator.translate,
	            hh     : translator.translate,
	            d      : 'dan',
	            dd     : translator.translate,
	            M      : 'mjesec',
	            MM     : translator.translate,
	            y      : 'godinu',
	            yy     : translator.translate
	        },
	        ordinalParse: /\d{1,2}\./,
	        ordinal : '%d.',
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 7  // The week that contains Jan 1st is the first week of the year.
	        }
	    });

	    return me;

	}));

/***/ },
/* 109 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : macedonian (mk)
	//! author : Borislav Mickov : https://github.com/B0k0

	(function (global, factory) {
	    true ? factory(__webpack_require__(56)) :
	   typeof define === 'function' && define.amd ? define(['moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';


	    var mk = moment.defineLocale('mk', {
	        months : '___________'.split('_'),
	        monthsShort : '___________'.split('_'),
	        weekdays : '______'.split('_'),
	        weekdaysShort : '______'.split('_'),
	        weekdaysMin : 'e_o_____a'.split('_'),
	        longDateFormat : {
	            LT : 'H:mm',
	            LTS : 'H:mm:ss',
	            L : 'D.MM.YYYY',
	            LL : 'D MMMM YYYY',
	            LLL : 'D MMMM YYYY H:mm',
	            LLLL : 'dddd, D MMMM YYYY H:mm'
	        },
	        calendar : {
	            sameDay : '[ ] LT',
	            nextDay : '[ ] LT',
	            nextWeek : 'dddd [] LT',
	            lastDay : '[ ] LT',
	            lastWeek : function () {
	                switch (this.day()) {
	                case 0:
	                case 3:
	                case 6:
	                    return '[ ] dddd [] LT';
	                case 1:
	                case 2:
	                case 4:
	                case 5:
	                    return '[ ] dddd [] LT';
	                }
	            },
	            sameElse : 'L'
	        },
	        relativeTime : {
	            future : ' %s',
	            past : ' %s',
	            s : ' ',
	            m : '',
	            mm : '%d ',
	            h : '',
	            hh : '%d ',
	            d : '',
	            dd : '%d ',
	            M : '',
	            MM : '%d ',
	            y : '',
	            yy : '%d '
	        },
	        ordinalParse: /\d{1,2}-(|||||)/,
	        ordinal : function (number) {
	            var lastDigit = number % 10,
	                last2Digits = number % 100;
	            if (number === 0) {
	                return number + '-';
	            } else if (last2Digits === 0) {
	                return number + '-';
	            } else if (last2Digits > 10 && last2Digits < 20) {
	                return number + '-';
	            } else if (lastDigit === 1) {
	                return number + '-';
	            } else if (lastDigit === 2) {
	                return number + '-';
	            } else if (lastDigit === 7 || lastDigit === 8) {
	                return number + '-';
	            } else {
	                return number + '-';
	            }
	        },
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 7  // The week that contains Jan 1st is the first week of the year.
	        }
	    });

	    return mk;

	}));

/***/ },
/* 110 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : malayalam (ml)
	//! author : Floyd Pink : https://github.com/floydpink

	(function (global, factory) {
	    true ? factory(__webpack_require__(56)) :
	   typeof define === 'function' && define.amd ? define(['moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';


	    var ml = moment.defineLocale('ml', {
	        months : '___________'.split('_'),
	        monthsShort : '._._._.___._._._._._.'.split('_'),
	        weekdays : '______'.split('_'),
	        weekdaysShort : '______'.split('_'),
	        weekdaysMin : '______'.split('_'),
	        longDateFormat : {
	            LT : 'A h:mm -',
	            LTS : 'A h:mm:ss -',
	            L : 'DD/MM/YYYY',
	            LL : 'D MMMM YYYY',
	            LLL : 'D MMMM YYYY, A h:mm -',
	            LLLL : 'dddd, D MMMM YYYY, A h:mm -'
	        },
	        calendar : {
	            sameDay : '[] LT',
	            nextDay : '[] LT',
	            nextWeek : 'dddd, LT',
	            lastDay : '[] LT',
	            lastWeek : '[] dddd, LT',
	            sameElse : 'L'
	        },
	        relativeTime : {
	            future : '%s ',
	            past : '%s ',
	            s : ' ',
	            m : ' ',
	            mm : '%d ',
	            h : ' ',
	            hh : '%d ',
	            d : ' ',
	            dd : '%d ',
	            M : ' ',
	            MM : '%d ',
	            y : ' ',
	            yy : '%d '
	        },
	        meridiemParse: /|| ||/i,
	        isPM : function (input) {
	            return /^( ||)$/.test(input);
	        },
	        meridiem : function (hour, minute, isLower) {
	            if (hour < 4) {
	                return '';
	            } else if (hour < 12) {
	                return '';
	            } else if (hour < 17) {
	                return ' ';
	            } else if (hour < 20) {
	                return '';
	            } else {
	                return '';
	            }
	        }
	    });

	    return ml;

	}));

/***/ },
/* 111 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Marathi (mr)
	//! author : Harshad Kale : https://github.com/kalehv

	(function (global, factory) {
	    true ? factory(__webpack_require__(56)) :
	   typeof define === 'function' && define.amd ? define(['moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';


	    var symbolMap = {
	        '1': '',
	        '2': '',
	        '3': '',
	        '4': '',
	        '5': '',
	        '6': '',
	        '7': '',
	        '8': '',
	        '9': '',
	        '0': ''
	    },
	    numberMap = {
	        '': '1',
	        '': '2',
	        '': '3',
	        '': '4',
	        '': '5',
	        '': '6',
	        '': '7',
	        '': '8',
	        '': '9',
	        '': '0'
	    };

	    var mr = moment.defineLocale('mr', {
	        months : '___________'.split('_'),
	        monthsShort: '._._._._._._._._._._._.'.split('_'),
	        weekdays : '______'.split('_'),
	        weekdaysShort : '______'.split('_'),
	        weekdaysMin : '______'.split('_'),
	        longDateFormat : {
	            LT : 'A h:mm ',
	            LTS : 'A h:mm:ss ',
	            L : 'DD/MM/YYYY',
	            LL : 'D MMMM YYYY',
	            LLL : 'D MMMM YYYY, A h:mm ',
	            LLLL : 'dddd, D MMMM YYYY, A h:mm '
	        },
	        calendar : {
	            sameDay : '[] LT',
	            nextDay : '[] LT',
	            nextWeek : 'dddd, LT',
	            lastDay : '[] LT',
	            lastWeek: '[] dddd, LT',
	            sameElse : 'L'
	        },
	        relativeTime : {
	            future : '%s ',
	            past : '%s ',
	            s : '',
	            m: ' ',
	            mm: '%d ',
	            h : ' ',
	            hh : '%d ',
	            d : ' ',
	            dd : '%d ',
	            M : ' ',
	            MM : '%d ',
	            y : ' ',
	            yy : '%d '
	        },
	        preparse: function (string) {
	            return string.replace(/[]/g, function (match) {
	                return numberMap[match];
	            });
	        },
	        postformat: function (string) {
	            return string.replace(/\d/g, function (match) {
	                return symbolMap[match];
	            });
	        },
	        meridiemParse: /|||/,
	        meridiemHour : function (hour, meridiem) {
	            if (hour === 12) {
	                hour = 0;
	            }
	            if (meridiem === '') {
	                return hour < 4 ? hour : hour + 12;
	            } else if (meridiem === '') {
	                return hour;
	            } else if (meridiem === '') {
	                return hour >= 10 ? hour : hour + 12;
	            } else if (meridiem === '') {
	                return hour + 12;
	            }
	        },
	        meridiem: function (hour, minute, isLower) {
	            if (hour < 4) {
	                return '';
	            } else if (hour < 10) {
	                return '';
	            } else if (hour < 17) {
	                return '';
	            } else if (hour < 20) {
	                return '';
	            } else {
	                return '';
	            }
	        },
	        week : {
	            dow : 0, // Sunday is the first day of the week.
	            doy : 6  // The week that contains Jan 1st is the first week of the year.
	        }
	    });

	    return mr;

	}));

/***/ },
/* 112 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Bahasa Malaysia (ms-MY)
	//! author : Weldan Jamili : https://github.com/weldan

	(function (global, factory) {
	    true ? factory(__webpack_require__(56)) :
	   typeof define === 'function' && define.amd ? define(['moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';


	    var ms = moment.defineLocale('ms', {
	        months : 'Januari_Februari_Mac_April_Mei_Jun_Julai_Ogos_September_Oktober_November_Disember'.split('_'),
	        monthsShort : 'Jan_Feb_Mac_Apr_Mei_Jun_Jul_Ogs_Sep_Okt_Nov_Dis'.split('_'),
	        weekdays : 'Ahad_Isnin_Selasa_Rabu_Khamis_Jumaat_Sabtu'.split('_'),
	        weekdaysShort : 'Ahd_Isn_Sel_Rab_Kha_Jum_Sab'.split('_'),
	        weekdaysMin : 'Ah_Is_Sl_Rb_Km_Jm_Sb'.split('_'),
	        longDateFormat : {
	            LT : 'HH.mm',
	            LTS : 'HH.mm.ss',
	            L : 'DD/MM/YYYY',
	            LL : 'D MMMM YYYY',
	            LLL : 'D MMMM YYYY [pukul] HH.mm',
	            LLLL : 'dddd, D MMMM YYYY [pukul] HH.mm'
	        },
	        meridiemParse: /pagi|tengahari|petang|malam/,
	        meridiemHour: function (hour, meridiem) {
	            if (hour === 12) {
	                hour = 0;
	            }
	            if (meridiem === 'pagi') {
	                return hour;
	            } else if (meridiem === 'tengahari') {
	                return hour >= 11 ? hour : hour + 12;
	            } else if (meridiem === 'petang' || meridiem === 'malam') {
	                return hour + 12;
	            }
	        },
	        meridiem : function (hours, minutes, isLower) {
	            if (hours < 11) {
	                return 'pagi';
	            } else if (hours < 15) {
	                return 'tengahari';
	            } else if (hours < 19) {
	                return 'petang';
	            } else {
	                return 'malam';
	            }
	        },
	        calendar : {
	            sameDay : '[Hari ini pukul] LT',
	            nextDay : '[Esok pukul] LT',
	            nextWeek : 'dddd [pukul] LT',
	            lastDay : '[Kelmarin pukul] LT',
	            lastWeek : 'dddd [lepas pukul] LT',
	            sameElse : 'L'
	        },
	        relativeTime : {
	            future : 'dalam %s',
	            past : '%s yang lepas',
	            s : 'beberapa saat',
	            m : 'seminit',
	            mm : '%d minit',
	            h : 'sejam',
	            hh : '%d jam',
	            d : 'sehari',
	            dd : '%d hari',
	            M : 'sebulan',
	            MM : '%d bulan',
	            y : 'setahun',
	            yy : '%d tahun'
	        },
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 7  // The week that contains Jan 1st is the first week of the year.
	        }
	    });

	    return ms;

	}));

/***/ },
/* 113 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Bahasa Malaysia (ms-MY)
	//! author : Weldan Jamili : https://github.com/weldan

	(function (global, factory) {
	    true ? factory(__webpack_require__(56)) :
	   typeof define === 'function' && define.amd ? define(['moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';


	    var ms_my = moment.defineLocale('ms-my', {
	        months : 'Januari_Februari_Mac_April_Mei_Jun_Julai_Ogos_September_Oktober_November_Disember'.split('_'),
	        monthsShort : 'Jan_Feb_Mac_Apr_Mei_Jun_Jul_Ogs_Sep_Okt_Nov_Dis'.split('_'),
	        weekdays : 'Ahad_Isnin_Selasa_Rabu_Khamis_Jumaat_Sabtu'.split('_'),
	        weekdaysShort : 'Ahd_Isn_Sel_Rab_Kha_Jum_Sab'.split('_'),
	        weekdaysMin : 'Ah_Is_Sl_Rb_Km_Jm_Sb'.split('_'),
	        longDateFormat : {
	            LT : 'HH.mm',
	            LTS : 'HH.mm.ss',
	            L : 'DD/MM/YYYY',
	            LL : 'D MMMM YYYY',
	            LLL : 'D MMMM YYYY [pukul] HH.mm',
	            LLLL : 'dddd, D MMMM YYYY [pukul] HH.mm'
	        },
	        meridiemParse: /pagi|tengahari|petang|malam/,
	        meridiemHour: function (hour, meridiem) {
	            if (hour === 12) {
	                hour = 0;
	            }
	            if (meridiem === 'pagi') {
	                return hour;
	            } else if (meridiem === 'tengahari') {
	                return hour >= 11 ? hour : hour + 12;
	            } else if (meridiem === 'petang' || meridiem === 'malam') {
	                return hour + 12;
	            }
	        },
	        meridiem : function (hours, minutes, isLower) {
	            if (hours < 11) {
	                return 'pagi';
	            } else if (hours < 15) {
	                return 'tengahari';
	            } else if (hours < 19) {
	                return 'petang';
	            } else {
	                return 'malam';
	            }
	        },
	        calendar : {
	            sameDay : '[Hari ini pukul] LT',
	            nextDay : '[Esok pukul] LT',
	            nextWeek : 'dddd [pukul] LT',
	            lastDay : '[Kelmarin pukul] LT',
	            lastWeek : 'dddd [lepas pukul] LT',
	            sameElse : 'L'
	        },
	        relativeTime : {
	            future : 'dalam %s',
	            past : '%s yang lepas',
	            s : 'beberapa saat',
	            m : 'seminit',
	            mm : '%d minit',
	            h : 'sejam',
	            hh : '%d jam',
	            d : 'sehari',
	            dd : '%d hari',
	            M : 'sebulan',
	            MM : '%d bulan',
	            y : 'setahun',
	            yy : '%d tahun'
	        },
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 7  // The week that contains Jan 1st is the first week of the year.
	        }
	    });

	    return ms_my;

	}));

/***/ },
/* 114 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Burmese (my)
	//! author : Squar team, mysquar.com

	(function (global, factory) {
	    true ? factory(__webpack_require__(56)) :
	   typeof define === 'function' && define.amd ? define(['moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';


	    var symbolMap = {
	        '1': '',
	        '2': '',
	        '3': '',
	        '4': '',
	        '5': '',
	        '6': '',
	        '7': '',
	        '8': '',
	        '9': '',
	        '0': ''
	    }, numberMap = {
	        '': '1',
	        '': '2',
	        '': '3',
	        '': '4',
	        '': '5',
	        '': '6',
	        '': '7',
	        '': '8',
	        '': '9',
	        '': '0'
	    };

	    var my = moment.defineLocale('my', {
	        months: '___________'.split('_'),
	        monthsShort: '___________'.split('_'),
	        weekdays: '______'.split('_'),
	        weekdaysShort: '______'.split('_'),
	        weekdaysMin: '______'.split('_'),

	        longDateFormat: {
	            LT: 'HH:mm',
	            LTS: 'HH:mm:ss',
	            L: 'DD/MM/YYYY',
	            LL: 'D MMMM YYYY',
	            LLL: 'D MMMM YYYY HH:mm',
	            LLLL: 'dddd D MMMM YYYY HH:mm'
	        },
	        calendar: {
	            sameDay: '[.] LT []',
	            nextDay: '[] LT []',
	            nextWeek: 'dddd LT []',
	            lastDay: '[.] LT []',
	            lastWeek: '[] dddd LT []',
	            sameElse: 'L'
	        },
	        relativeTime: {
	            future: ' %s ',
	            past: ' %s ',
	            s: '.',
	            m: '',
	            mm: '%d ',
	            h: '',
	            hh: '%d ',
	            d: '',
	            dd: '%d ',
	            M: '',
	            MM: '%d ',
	            y: '',
	            yy: '%d '
	        },
	        preparse: function (string) {
	            return string.replace(/[]/g, function (match) {
	                return numberMap[match];
	            });
	        },
	        postformat: function (string) {
	            return string.replace(/\d/g, function (match) {
	                return symbolMap[match];
	            });
	        },
	        week: {
	            dow: 1, // Monday is the first day of the week.
	            doy: 4 // The week that contains Jan 1st is the first week of the year.
	        }
	    });

	    return my;

	}));

/***/ },
/* 115 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : norwegian bokml (nb)
	//! authors : Espen Hovlandsdal : https://github.com/rexxars
	//!           Sigurd Gartmann : https://github.com/sigurdga

	(function (global, factory) {
	    true ? factory(__webpack_require__(56)) :
	   typeof define === 'function' && define.amd ? define(['moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';


	    var nb = moment.defineLocale('nb', {
	        months : 'januar_februar_mars_april_mai_juni_juli_august_september_oktober_november_desember'.split('_'),
	        monthsShort : 'jan_feb_mar_apr_mai_jun_jul_aug_sep_okt_nov_des'.split('_'),
	        weekdays : 'sndag_mandag_tirsdag_onsdag_torsdag_fredag_lrdag'.split('_'),
	        weekdaysShort : 'sn_man_tirs_ons_tors_fre_lr'.split('_'),
	        weekdaysMin : 's_ma_ti_on_to_fr_l'.split('_'),
	        longDateFormat : {
	            LT : 'H.mm',
	            LTS : 'H.mm.ss',
	            L : 'DD.MM.YYYY',
	            LL : 'D. MMMM YYYY',
	            LLL : 'D. MMMM YYYY [kl.] H.mm',
	            LLLL : 'dddd D. MMMM YYYY [kl.] H.mm'
	        },
	        calendar : {
	            sameDay: '[i dag kl.] LT',
	            nextDay: '[i morgen kl.] LT',
	            nextWeek: 'dddd [kl.] LT',
	            lastDay: '[i gr kl.] LT',
	            lastWeek: '[forrige] dddd [kl.] LT',
	            sameElse: 'L'
	        },
	        relativeTime : {
	            future : 'om %s',
	            past : 'for %s siden',
	            s : 'noen sekunder',
	            m : 'ett minutt',
	            mm : '%d minutter',
	            h : 'en time',
	            hh : '%d timer',
	            d : 'en dag',
	            dd : '%d dager',
	            M : 'en mned',
	            MM : '%d mneder',
	            y : 'ett r',
	            yy : '%d r'
	        },
	        ordinalParse: /\d{1,2}\./,
	        ordinal : '%d.',
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 4  // The week that contains Jan 4th is the first week of the year.
	        }
	    });

	    return nb;

	}));

/***/ },
/* 116 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : nepali/nepalese
	//! author : suvash : https://github.com/suvash

	(function (global, factory) {
	    true ? factory(__webpack_require__(56)) :
	   typeof define === 'function' && define.amd ? define(['moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';


	    var symbolMap = {
	        '1': '',
	        '2': '',
	        '3': '',
	        '4': '',
	        '5': '',
	        '6': '',
	        '7': '',
	        '8': '',
	        '9': '',
	        '0': ''
	    },
	    numberMap = {
	        '': '1',
	        '': '2',
	        '': '3',
	        '': '4',
	        '': '5',
	        '': '6',
	        '': '7',
	        '': '8',
	        '': '9',
	        '': '0'
	    };

	    var ne = moment.defineLocale('ne', {
	        months : '___________'.split('_'),
	        monthsShort : '._.__.___._._._._._.'.split('_'),
	        weekdays : '______'.split('_'),
	        weekdaysShort : '._._._._._._.'.split('_'),
	        weekdaysMin : '._.__._._._.'.split('_'),
	        longDateFormat : {
	            LT : 'A h:mm ',
	            LTS : 'A h:mm:ss ',
	            L : 'DD/MM/YYYY',
	            LL : 'D MMMM YYYY',
	            LLL : 'D MMMM YYYY, A h:mm ',
	            LLLL : 'dddd, D MMMM YYYY, A h:mm '
	        },
	        preparse: function (string) {
	            return string.replace(/[]/g, function (match) {
	                return numberMap[match];
	            });
	        },
	        postformat: function (string) {
	            return string.replace(/\d/g, function (match) {
	                return symbolMap[match];
	            });
	        },
	        meridiemParse: /|||||/,
	        meridiemHour : function (hour, meridiem) {
	            if (hour === 12) {
	                hour = 0;
	            }
	            if (meridiem === '') {
	                return hour < 3 ? hour : hour + 12;
	            } else if (meridiem === '') {
	                return hour;
	            } else if (meridiem === '') {
	                return hour >= 10 ? hour : hour + 12;
	            } else if (meridiem === '' || meridiem === '') {
	                return hour + 12;
	            }
	        },
	        meridiem : function (hour, minute, isLower) {
	            if (hour < 3) {
	                return '';
	            } else if (hour < 10) {
	                return '';
	            } else if (hour < 15) {
	                return '';
	            } else if (hour < 18) {
	                return '';
	            } else if (hour < 20) {
	                return '';
	            } else {
	                return '';
	            }
	        },
	        calendar : {
	            sameDay : '[] LT',
	            nextDay : '[] LT',
	            nextWeek : '[] dddd[,] LT',
	            lastDay : '[] LT',
	            lastWeek : '[] dddd[,] LT',
	            sameElse : 'L'
	        },
	        relativeTime : {
	            future : '%s',
	            past : '%s ',
	            s : ' ',
	            m : ' ',
	            mm : '%d ',
	            h : ' ',
	            hh : '%d ',
	            d : ' ',
	            dd : '%d ',
	            M : ' ',
	            MM : '%d ',
	            y : ' ',
	            yy : '%d '
	        },
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 7  // The week that contains Jan 1st is the first week of the year.
	        }
	    });

	    return ne;

	}));

/***/ },
/* 117 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : dutch (nl)
	//! author : Joris Rling : https://github.com/jjupiter

	(function (global, factory) {
	    true ? factory(__webpack_require__(56)) :
	   typeof define === 'function' && define.amd ? define(['moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';


	    var monthsShortWithDots = 'jan._feb._mrt._apr._mei_jun._jul._aug._sep._okt._nov._dec.'.split('_'),
	        monthsShortWithoutDots = 'jan_feb_mrt_apr_mei_jun_jul_aug_sep_okt_nov_dec'.split('_');

	    var nl = moment.defineLocale('nl', {
	        months : 'januari_februari_maart_april_mei_juni_juli_augustus_september_oktober_november_december'.split('_'),
	        monthsShort : function (m, format) {
	            if (/-MMM-/.test(format)) {
	                return monthsShortWithoutDots[m.month()];
	            } else {
	                return monthsShortWithDots[m.month()];
	            }
	        },
	        weekdays : 'zondag_maandag_dinsdag_woensdag_donderdag_vrijdag_zaterdag'.split('_'),
	        weekdaysShort : 'zo._ma._di._wo._do._vr._za.'.split('_'),
	        weekdaysMin : 'Zo_Ma_Di_Wo_Do_Vr_Za'.split('_'),
	        longDateFormat : {
	            LT : 'HH:mm',
	            LTS : 'HH:mm:ss',
	            L : 'DD-MM-YYYY',
	            LL : 'D MMMM YYYY',
	            LLL : 'D MMMM YYYY HH:mm',
	            LLLL : 'dddd D MMMM YYYY HH:mm'
	        },
	        calendar : {
	            sameDay: '[vandaag om] LT',
	            nextDay: '[morgen om] LT',
	            nextWeek: 'dddd [om] LT',
	            lastDay: '[gisteren om] LT',
	            lastWeek: '[afgelopen] dddd [om] LT',
	            sameElse: 'L'
	        },
	        relativeTime : {
	            future : 'over %s',
	            past : '%s geleden',
	            s : 'een paar seconden',
	            m : 'n minuut',
	            mm : '%d minuten',
	            h : 'n uur',
	            hh : '%d uur',
	            d : 'n dag',
	            dd : '%d dagen',
	            M : 'n maand',
	            MM : '%d maanden',
	            y : 'n jaar',
	            yy : '%d jaar'
	        },
	        ordinalParse: /\d{1,2}(ste|de)/,
	        ordinal : function (number) {
	            return number + ((number === 1 || number === 8 || number >= 20) ? 'ste' : 'de');
	        },
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 4  // The week that contains Jan 4th is the first week of the year.
	        }
	    });

	    return nl;

	}));

/***/ },
/* 118 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : norwegian nynorsk (nn)
	//! author : https://github.com/mechuwind

	(function (global, factory) {
	    true ? factory(__webpack_require__(56)) :
	   typeof define === 'function' && define.amd ? define(['moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';


	    var nn = moment.defineLocale('nn', {
	        months : 'januar_februar_mars_april_mai_juni_juli_august_september_oktober_november_desember'.split('_'),
	        monthsShort : 'jan_feb_mar_apr_mai_jun_jul_aug_sep_okt_nov_des'.split('_'),
	        weekdays : 'sundag_mndag_tysdag_onsdag_torsdag_fredag_laurdag'.split('_'),
	        weekdaysShort : 'sun_mn_tys_ons_tor_fre_lau'.split('_'),
	        weekdaysMin : 'su_m_ty_on_to_fr_l'.split('_'),
	        longDateFormat : {
	            LT : 'HH:mm',
	            LTS : 'HH:mm:ss',
	            L : 'DD.MM.YYYY',
	            LL : 'D MMMM YYYY',
	            LLL : 'D MMMM YYYY HH:mm',
	            LLLL : 'dddd D MMMM YYYY HH:mm'
	        },
	        calendar : {
	            sameDay: '[I dag klokka] LT',
	            nextDay: '[I morgon klokka] LT',
	            nextWeek: 'dddd [klokka] LT',
	            lastDay: '[I gr klokka] LT',
	            lastWeek: '[Fregande] dddd [klokka] LT',
	            sameElse: 'L'
	        },
	        relativeTime : {
	            future : 'om %s',
	            past : 'for %s sidan',
	            s : 'nokre sekund',
	            m : 'eit minutt',
	            mm : '%d minutt',
	            h : 'ein time',
	            hh : '%d timar',
	            d : 'ein dag',
	            dd : '%d dagar',
	            M : 'ein mnad',
	            MM : '%d mnader',
	            y : 'eit r',
	            yy : '%d r'
	        },
	        ordinalParse: /\d{1,2}\./,
	        ordinal : '%d.',
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 4  // The week that contains Jan 4th is the first week of the year.
	        }
	    });

	    return nn;

	}));

/***/ },
/* 119 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : polish (pl)
	//! author : Rafal Hirsz : https://github.com/evoL

	(function (global, factory) {
	    true ? factory(__webpack_require__(56)) :
	   typeof define === 'function' && define.amd ? define(['moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';


	    var monthsNominative = 'stycze_luty_marzec_kwiecie_maj_czerwiec_lipiec_sierpie_wrzesie_padziernik_listopad_grudzie'.split('_'),
	        monthsSubjective = 'stycznia_lutego_marca_kwietnia_maja_czerwca_lipca_sierpnia_wrzenia_padziernika_listopada_grudnia'.split('_');
	    function plural(n) {
	        return (n % 10 < 5) && (n % 10 > 1) && ((~~(n / 10) % 10) !== 1);
	    }
	    function translate(number, withoutSuffix, key) {
	        var result = number + ' ';
	        switch (key) {
	        case 'm':
	            return withoutSuffix ? 'minuta' : 'minut';
	        case 'mm':
	            return result + (plural(number) ? 'minuty' : 'minut');
	        case 'h':
	            return withoutSuffix  ? 'godzina'  : 'godzin';
	        case 'hh':
	            return result + (plural(number) ? 'godziny' : 'godzin');
	        case 'MM':
	            return result + (plural(number) ? 'miesice' : 'miesicy');
	        case 'yy':
	            return result + (plural(number) ? 'lata' : 'lat');
	        }
	    }

	    var pl = moment.defineLocale('pl', {
	        months : function (momentToFormat, format) {
	            if (format === '') {
	                // Hack: if format empty we know this is used to generate
	                // RegExp by moment. Give then back both valid forms of months
	                // in RegExp ready format.
	                return '(' + monthsSubjective[momentToFormat.month()] + '|' + monthsNominative[momentToFormat.month()] + ')';
	            } else if (/D MMMM/.test(format)) {
	                return monthsSubjective[momentToFormat.month()];
	            } else {
	                return monthsNominative[momentToFormat.month()];
	            }
	        },
	        monthsShort : 'sty_lut_mar_kwi_maj_cze_lip_sie_wrz_pa_lis_gru'.split('_'),
	        weekdays : 'niedziela_poniedziaek_wtorek_roda_czwartek_pitek_sobota'.split('_'),
	        weekdaysShort : 'nie_pon_wt_r_czw_pt_sb'.split('_'),
	        weekdaysMin : 'N_Pn_Wt_r_Cz_Pt_So'.split('_'),
	        longDateFormat : {
	            LT : 'HH:mm',
	            LTS : 'HH:mm:ss',
	            L : 'DD.MM.YYYY',
	            LL : 'D MMMM YYYY',
	            LLL : 'D MMMM YYYY HH:mm',
	            LLLL : 'dddd, D MMMM YYYY HH:mm'
	        },
	        calendar : {
	            sameDay: '[Dzi o] LT',
	            nextDay: '[Jutro o] LT',
	            nextWeek: '[W] dddd [o] LT',
	            lastDay: '[Wczoraj o] LT',
	            lastWeek: function () {
	                switch (this.day()) {
	                case 0:
	                    return '[W zesz niedziel o] LT';
	                case 3:
	                    return '[W zesz rod o] LT';
	                case 6:
	                    return '[W zesz sobot o] LT';
	                default:
	                    return '[W zeszy] dddd [o] LT';
	                }
	            },
	            sameElse: 'L'
	        },
	        relativeTime : {
	            future : 'za %s',
	            past : '%s temu',
	            s : 'kilka sekund',
	            m : translate,
	            mm : translate,
	            h : translate,
	            hh : translate,
	            d : '1 dzie',
	            dd : '%d dni',
	            M : 'miesic',
	            MM : translate,
	            y : 'rok',
	            yy : translate
	        },
	        ordinalParse: /\d{1,2}\./,
	        ordinal : '%d.',
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 4  // The week that contains Jan 4th is the first week of the year.
	        }
	    });

	    return pl;

	}));

/***/ },
/* 120 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : portuguese (pt)
	//! author : Jefferson : https://github.com/jalex79

	(function (global, factory) {
	    true ? factory(__webpack_require__(56)) :
	   typeof define === 'function' && define.amd ? define(['moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';


	    var pt = moment.defineLocale('pt', {
	        months : 'Janeiro_Fevereiro_Maro_Abril_Maio_Junho_Julho_Agosto_Setembro_Outubro_Novembro_Dezembro'.split('_'),
	        monthsShort : 'Jan_Fev_Mar_Abr_Mai_Jun_Jul_Ago_Set_Out_Nov_Dez'.split('_'),
	        weekdays : 'Domingo_Segunda-Feira_Tera-Feira_Quarta-Feira_Quinta-Feira_Sexta-Feira_Sbado'.split('_'),
	        weekdaysShort : 'Dom_Seg_Ter_Qua_Qui_Sex_Sb'.split('_'),
	        weekdaysMin : 'Dom_2_3_4_5_6_Sb'.split('_'),
	        longDateFormat : {
	            LT : 'HH:mm',
	            LTS : 'HH:mm:ss',
	            L : 'DD/MM/YYYY',
	            LL : 'D [de] MMMM [de] YYYY',
	            LLL : 'D [de] MMMM [de] YYYY HH:mm',
	            LLLL : 'dddd, D [de] MMMM [de] YYYY HH:mm'
	        },
	        calendar : {
	            sameDay: '[Hoje s] LT',
	            nextDay: '[Amanh s] LT',
	            nextWeek: 'dddd [s] LT',
	            lastDay: '[Ontem s] LT',
	            lastWeek: function () {
	                return (this.day() === 0 || this.day() === 6) ?
	                    '[ltimo] dddd [s] LT' : // Saturday + Sunday
	                    '[ltima] dddd [s] LT'; // Monday - Friday
	            },
	            sameElse: 'L'
	        },
	        relativeTime : {
	            future : 'em %s',
	            past : 'h %s',
	            s : 'segundos',
	            m : 'um minuto',
	            mm : '%d minutos',
	            h : 'uma hora',
	            hh : '%d horas',
	            d : 'um dia',
	            dd : '%d dias',
	            M : 'um ms',
	            MM : '%d meses',
	            y : 'um ano',
	            yy : '%d anos'
	        },
	        ordinalParse: /\d{1,2}/,
	        ordinal : '%d',
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 4  // The week that contains Jan 4th is the first week of the year.
	        }
	    });

	    return pt;

	}));

/***/ },
/* 121 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : brazilian portuguese (pt-br)
	//! author : Caio Ribeiro Pereira : https://github.com/caio-ribeiro-pereira

	(function (global, factory) {
	    true ? factory(__webpack_require__(56)) :
	   typeof define === 'function' && define.amd ? define(['moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';


	    var pt_br = moment.defineLocale('pt-br', {
	        months : 'Janeiro_Fevereiro_Maro_Abril_Maio_Junho_Julho_Agosto_Setembro_Outubro_Novembro_Dezembro'.split('_'),
	        monthsShort : 'Jan_Fev_Mar_Abr_Mai_Jun_Jul_Ago_Set_Out_Nov_Dez'.split('_'),
	        weekdays : 'Domingo_Segunda-Feira_Tera-Feira_Quarta-Feira_Quinta-Feira_Sexta-Feira_Sbado'.split('_'),
	        weekdaysShort : 'Dom_Seg_Ter_Qua_Qui_Sex_Sb'.split('_'),
	        weekdaysMin : 'Dom_2_3_4_5_6_Sb'.split('_'),
	        longDateFormat : {
	            LT : 'HH:mm',
	            LTS : 'HH:mm:ss',
	            L : 'DD/MM/YYYY',
	            LL : 'D [de] MMMM [de] YYYY',
	            LLL : 'D [de] MMMM [de] YYYY [s] HH:mm',
	            LLLL : 'dddd, D [de] MMMM [de] YYYY [s] HH:mm'
	        },
	        calendar : {
	            sameDay: '[Hoje s] LT',
	            nextDay: '[Amanh s] LT',
	            nextWeek: 'dddd [s] LT',
	            lastDay: '[Ontem s] LT',
	            lastWeek: function () {
	                return (this.day() === 0 || this.day() === 6) ?
	                    '[ltimo] dddd [s] LT' : // Saturday + Sunday
	                    '[ltima] dddd [s] LT'; // Monday - Friday
	            },
	            sameElse: 'L'
	        },
	        relativeTime : {
	            future : 'em %s',
	            past : '%s atrs',
	            s : 'poucos segundos',
	            m : 'um minuto',
	            mm : '%d minutos',
	            h : 'uma hora',
	            hh : '%d horas',
	            d : 'um dia',
	            dd : '%d dias',
	            M : 'um ms',
	            MM : '%d meses',
	            y : 'um ano',
	            yy : '%d anos'
	        },
	        ordinalParse: /\d{1,2}/,
	        ordinal : '%d'
	    });

	    return pt_br;

	}));

/***/ },
/* 122 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : romanian (ro)
	//! author : Vlad Gurdiga : https://github.com/gurdiga
	//! author : Valentin Agachi : https://github.com/avaly

	(function (global, factory) {
	    true ? factory(__webpack_require__(56)) :
	   typeof define === 'function' && define.amd ? define(['moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';


	    function relativeTimeWithPlural(number, withoutSuffix, key) {
	        var format = {
	                'mm': 'minute',
	                'hh': 'ore',
	                'dd': 'zile',
	                'MM': 'luni',
	                'yy': 'ani'
	            },
	            separator = ' ';
	        if (number % 100 >= 20 || (number >= 100 && number % 100 === 0)) {
	            separator = ' de ';
	        }
	        return number + separator + format[key];
	    }

	    var ro = moment.defineLocale('ro', {
	        months : 'ianuarie_februarie_martie_aprilie_mai_iunie_iulie_august_septembrie_octombrie_noiembrie_decembrie'.split('_'),
	        monthsShort : 'ian._febr._mart._apr._mai_iun._iul._aug._sept._oct._nov._dec.'.split('_'),
	        weekdays : 'duminic_luni_mari_miercuri_joi_vineri_smbt'.split('_'),
	        weekdaysShort : 'Dum_Lun_Mar_Mie_Joi_Vin_Sm'.split('_'),
	        weekdaysMin : 'Du_Lu_Ma_Mi_Jo_Vi_S'.split('_'),
	        longDateFormat : {
	            LT : 'H:mm',
	            LTS : 'H:mm:ss',
	            L : 'DD.MM.YYYY',
	            LL : 'D MMMM YYYY',
	            LLL : 'D MMMM YYYY H:mm',
	            LLLL : 'dddd, D MMMM YYYY H:mm'
	        },
	        calendar : {
	            sameDay: '[azi la] LT',
	            nextDay: '[mine la] LT',
	            nextWeek: 'dddd [la] LT',
	            lastDay: '[ieri la] LT',
	            lastWeek: '[fosta] dddd [la] LT',
	            sameElse: 'L'
	        },
	        relativeTime : {
	            future : 'peste %s',
	            past : '%s n urm',
	            s : 'cteva secunde',
	            m : 'un minut',
	            mm : relativeTimeWithPlural,
	            h : 'o or',
	            hh : relativeTimeWithPlural,
	            d : 'o zi',
	            dd : relativeTimeWithPlural,
	            M : 'o lun',
	            MM : relativeTimeWithPlural,
	            y : 'un an',
	            yy : relativeTimeWithPlural
	        },
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 7  // The week that contains Jan 1st is the first week of the year.
	        }
	    });

	    return ro;

	}));

/***/ },
/* 123 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : russian (ru)
	//! author : Viktorminator : https://github.com/Viktorminator
	//! Author : Menelion Elensle : https://github.com/Oire

	(function (global, factory) {
	    true ? factory(__webpack_require__(56)) :
	   typeof define === 'function' && define.amd ? define(['moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';


	    function plural(word, num) {
	        var forms = word.split('_');
	        return num % 10 === 1 && num % 100 !== 11 ? forms[0] : (num % 10 >= 2 && num % 10 <= 4 && (num % 100 < 10 || num % 100 >= 20) ? forms[1] : forms[2]);
	    }
	    function relativeTimeWithPlural(number, withoutSuffix, key) {
	        var format = {
	            'mm': withoutSuffix ? '__' : '__',
	            'hh': '__',
	            'dd': '__',
	            'MM': '__',
	            'yy': '__'
	        };
	        if (key === 'm') {
	            return withoutSuffix ? '' : '';
	        }
	        else {
	            return number + ' ' + plural(format[key], +number);
	        }
	    }
	    function monthsCaseReplace(m, format) {
	        var months = {
	            'nominative': '___________'.split('_'),
	            'accusative': '___________'.split('_')
	        },
	        nounCase = (/D[oD]?(\[[^\[\]]*\]|\s+)+MMMM?/).test(format) ?
	            'accusative' :
	            'nominative';
	        return months[nounCase][m.month()];
	    }
	    function monthsShortCaseReplace(m, format) {
	        var monthsShort = {
	            'nominative': '___________'.split('_'),
	            'accusative': '___________'.split('_')
	        },
	        nounCase = (/D[oD]?(\[[^\[\]]*\]|\s+)+MMMM?/).test(format) ?
	            'accusative' :
	            'nominative';
	        return monthsShort[nounCase][m.month()];
	    }
	    function weekdaysCaseReplace(m, format) {
	        var weekdays = {
	            'nominative': '______'.split('_'),
	            'accusative': '______'.split('_')
	        },
	        nounCase = (/\[ ?[] ?(?:||)? ?\] ?dddd/).test(format) ?
	            'accusative' :
	            'nominative';
	        return weekdays[nounCase][m.day()];
	    }

	    var ru = moment.defineLocale('ru', {
	        months : monthsCaseReplace,
	        monthsShort : monthsShortCaseReplace,
	        weekdays : weekdaysCaseReplace,
	        weekdaysShort : '______'.split('_'),
	        weekdaysMin : '______'.split('_'),
	        monthsParse : [/^/i, /^/i, /^/i, /^/i, /^[|]/i, /^/i, /^/i, /^/i, /^/i, /^/i, /^/i, /^/i],
	        longDateFormat : {
	            LT : 'HH:mm',
	            LTS : 'HH:mm:ss',
	            L : 'DD.MM.YYYY',
	            LL : 'D MMMM YYYY .',
	            LLL : 'D MMMM YYYY ., HH:mm',
	            LLLL : 'dddd, D MMMM YYYY ., HH:mm'
	        },
	        calendar : {
	            sameDay: '[ ] LT',
	            nextDay: '[ ] LT',
	            lastDay: '[ ] LT',
	            nextWeek: function () {
	                return this.day() === 2 ? '[] dddd [] LT' : '[] dddd [] LT';
	            },
	            lastWeek: function (now) {
	                if (now.week() !== this.week()) {
	                    switch (this.day()) {
	                    case 0:
	                        return '[ ] dddd [] LT';
	                    case 1:
	                    case 2:
	                    case 4:
	                        return '[ ] dddd [] LT';
	                    case 3:
	                    case 5:
	                    case 6:
	                        return '[ ] dddd [] LT';
	                    }
	                } else {
	                    if (this.day() === 2) {
	                        return '[] dddd [] LT';
	                    } else {
	                        return '[] dddd [] LT';
	                    }
	                }
	            },
	            sameElse: 'L'
	        },
	        relativeTime : {
	            future : ' %s',
	            past : '%s ',
	            s : ' ',
	            m : relativeTimeWithPlural,
	            mm : relativeTimeWithPlural,
	            h : '',
	            hh : relativeTimeWithPlural,
	            d : '',
	            dd : relativeTimeWithPlural,
	            M : '',
	            MM : relativeTimeWithPlural,
	            y : '',
	            yy : relativeTimeWithPlural
	        },
	        meridiemParse: /|||/i,
	        isPM : function (input) {
	            return /^(|)$/.test(input);
	        },
	        meridiem : function (hour, minute, isLower) {
	            if (hour < 4) {
	                return '';
	            } else if (hour < 12) {
	                return '';
	            } else if (hour < 17) {
	                return '';
	            } else {
	                return '';
	            }
	        },
	        ordinalParse: /\d{1,2}-(||)/,
	        ordinal: function (number, period) {
	            switch (period) {
	            case 'M':
	            case 'd':
	            case 'DDD':
	                return number + '-';
	            case 'D':
	                return number + '-';
	            case 'w':
	            case 'W':
	                return number + '-';
	            default:
	                return number;
	            }
	        },
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 7  // The week that contains Jan 1st is the first week of the year.
	        }
	    });

	    return ru;

	}));

/***/ },
/* 124 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Sinhalese (si)
	//! author : Sampath Sitinamaluwa : https://github.com/sampathsris

	(function (global, factory) {
	    true ? factory(__webpack_require__(56)) :
	   typeof define === 'function' && define.amd ? define(['moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';


	    var si = moment.defineLocale('si', {
	        months : '___________'.split('_'),
	        monthsShort : '___________'.split('_'),
	        weekdays : '______'.split('_'),
	        weekdaysShort : '______'.split('_'),
	        weekdaysMin : '______'.split('_'),
	        longDateFormat : {
	            LT : 'a h:mm',
	            LTS : 'a h:mm:ss',
	            L : 'YYYY/MM/DD',
	            LL : 'YYYY MMMM D',
	            LLL : 'YYYY MMMM D, a h:mm',
	            LLLL : 'YYYY MMMM D [] dddd, a h:mm:ss'
	        },
	        calendar : {
	            sameDay : '[] LT[]',
	            nextDay : '[] LT[]',
	            nextWeek : 'dddd LT[]',
	            lastDay : '[] LT[]',
	            lastWeek : '[] dddd LT[]',
	            sameElse : 'L'
	        },
	        relativeTime : {
	            future : '%s',
	            past : '%s ',
	            s : ' ',
	            m : '',
	            mm : ' %d',
	            h : '',
	            hh : ' %d',
	            d : '',
	            dd : ' %d',
	            M : '',
	            MM : ' %d',
	            y : '',
	            yy : ' %d'
	        },
	        ordinalParse: /\d{1,2} /,
	        ordinal : function (number) {
	            return number + ' ';
	        },
	        meridiem : function (hours, minutes, isLower) {
	            if (hours > 11) {
	                return isLower ? '..' : ' ';
	            } else {
	                return isLower ? '..' : ' ';
	            }
	        }
	    });

	    return si;

	}));

/***/ },
/* 125 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : slovak (sk)
	//! author : Martin Minka : https://github.com/k2s
	//! based on work of petrbela : https://github.com/petrbela

	(function (global, factory) {
	    true ? factory(__webpack_require__(56)) :
	   typeof define === 'function' && define.amd ? define(['moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';


	    var months = 'janur_februr_marec_aprl_mj_jn_jl_august_september_oktber_november_december'.split('_'),
	        monthsShort = 'jan_feb_mar_apr_mj_jn_jl_aug_sep_okt_nov_dec'.split('_');
	    function plural(n) {
	        return (n > 1) && (n < 5);
	    }
	    function translate(number, withoutSuffix, key, isFuture) {
	        var result = number + ' ';
	        switch (key) {
	        case 's':  // a few seconds / in a few seconds / a few seconds ago
	            return (withoutSuffix || isFuture) ? 'pr seknd' : 'pr sekundami';
	        case 'm':  // a minute / in a minute / a minute ago
	            return withoutSuffix ? 'minta' : (isFuture ? 'mintu' : 'mintou');
	        case 'mm': // 9 minutes / in 9 minutes / 9 minutes ago
	            if (withoutSuffix || isFuture) {
	                return result + (plural(number) ? 'minty' : 'mint');
	            } else {
	                return result + 'mintami';
	            }
	            break;
	        case 'h':  // an hour / in an hour / an hour ago
	            return withoutSuffix ? 'hodina' : (isFuture ? 'hodinu' : 'hodinou');
	        case 'hh': // 9 hours / in 9 hours / 9 hours ago
	            if (withoutSuffix || isFuture) {
	                return result + (plural(number) ? 'hodiny' : 'hodn');
	            } else {
	                return result + 'hodinami';
	            }
	            break;
	        case 'd':  // a day / in a day / a day ago
	            return (withoutSuffix || isFuture) ? 'de' : 'dom';
	        case 'dd': // 9 days / in 9 days / 9 days ago
	            if (withoutSuffix || isFuture) {
	                return result + (plural(number) ? 'dni' : 'dn');
	            } else {
	                return result + 'dami';
	            }
	            break;
	        case 'M':  // a month / in a month / a month ago
	            return (withoutSuffix || isFuture) ? 'mesiac' : 'mesiacom';
	        case 'MM': // 9 months / in 9 months / 9 months ago
	            if (withoutSuffix || isFuture) {
	                return result + (plural(number) ? 'mesiace' : 'mesiacov');
	            } else {
	                return result + 'mesiacmi';
	            }
	            break;
	        case 'y':  // a year / in a year / a year ago
	            return (withoutSuffix || isFuture) ? 'rok' : 'rokom';
	        case 'yy': // 9 years / in 9 years / 9 years ago
	            if (withoutSuffix || isFuture) {
	                return result + (plural(number) ? 'roky' : 'rokov');
	            } else {
	                return result + 'rokmi';
	            }
	            break;
	        }
	    }

	    var sk = moment.defineLocale('sk', {
	        months : months,
	        monthsShort : monthsShort,
	        monthsParse : (function (months, monthsShort) {
	            var i, _monthsParse = [];
	            for (i = 0; i < 12; i++) {
	                // use custom parser to solve problem with July (ervenec)
	                _monthsParse[i] = new RegExp('^' + months[i] + '$|^' + monthsShort[i] + '$', 'i');
	            }
	            return _monthsParse;
	        }(months, monthsShort)),
	        weekdays : 'nedea_pondelok_utorok_streda_tvrtok_piatok_sobota'.split('_'),
	        weekdaysShort : 'ne_po_ut_st_t_pi_so'.split('_'),
	        weekdaysMin : 'ne_po_ut_st_t_pi_so'.split('_'),
	        longDateFormat : {
	            LT: 'H:mm',
	            LTS : 'H:mm:ss',
	            L : 'DD.MM.YYYY',
	            LL : 'D. MMMM YYYY',
	            LLL : 'D. MMMM YYYY H:mm',
	            LLLL : 'dddd D. MMMM YYYY H:mm'
	        },
	        calendar : {
	            sameDay: '[dnes o] LT',
	            nextDay: '[zajtra o] LT',
	            nextWeek: function () {
	                switch (this.day()) {
	                case 0:
	                    return '[v nedeu o] LT';
	                case 1:
	                case 2:
	                    return '[v] dddd [o] LT';
	                case 3:
	                    return '[v stredu o] LT';
	                case 4:
	                    return '[vo tvrtok o] LT';
	                case 5:
	                    return '[v piatok o] LT';
	                case 6:
	                    return '[v sobotu o] LT';
	                }
	            },
	            lastDay: '[vera o] LT',
	            lastWeek: function () {
	                switch (this.day()) {
	                case 0:
	                    return '[minul nedeu o] LT';
	                case 1:
	                case 2:
	                    return '[minul] dddd [o] LT';
	                case 3:
	                    return '[minul stredu o] LT';
	                case 4:
	                case 5:
	                    return '[minul] dddd [o] LT';
	                case 6:
	                    return '[minul sobotu o] LT';
	                }
	            },
	            sameElse: 'L'
	        },
	        relativeTime : {
	            future : 'za %s',
	            past : 'pred %s',
	            s : translate,
	            m : translate,
	            mm : translate,
	            h : translate,
	            hh : translate,
	            d : translate,
	            dd : translate,
	            M : translate,
	            MM : translate,
	            y : translate,
	            yy : translate
	        },
	        ordinalParse: /\d{1,2}\./,
	        ordinal : '%d.',
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 4  // The week that contains Jan 4th is the first week of the year.
	        }
	    });

	    return sk;

	}));

/***/ },
/* 126 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : slovenian (sl)
	//! author : Robert Sedovek : https://github.com/sedovsek

	(function (global, factory) {
	    true ? factory(__webpack_require__(56)) :
	   typeof define === 'function' && define.amd ? define(['moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';


	    function processRelativeTime(number, withoutSuffix, key, isFuture) {
	        var result = number + ' ';
	        switch (key) {
	        case 's':
	            return withoutSuffix || isFuture ? 'nekaj sekund' : 'nekaj sekundami';
	        case 'm':
	            return withoutSuffix ? 'ena minuta' : 'eno minuto';
	        case 'mm':
	            if (number === 1) {
	                result += withoutSuffix ? 'minuta' : 'minuto';
	            } else if (number === 2) {
	                result += withoutSuffix || isFuture ? 'minuti' : 'minutama';
	            } else if (number < 5) {
	                result += withoutSuffix || isFuture ? 'minute' : 'minutami';
	            } else {
	                result += withoutSuffix || isFuture ? 'minut' : 'minutami';
	            }
	            return result;
	        case 'h':
	            return withoutSuffix ? 'ena ura' : 'eno uro';
	        case 'hh':
	            if (number === 1) {
	                result += withoutSuffix ? 'ura' : 'uro';
	            } else if (number === 2) {
	                result += withoutSuffix || isFuture ? 'uri' : 'urama';
	            } else if (number < 5) {
	                result += withoutSuffix || isFuture ? 'ure' : 'urami';
	            } else {
	                result += withoutSuffix || isFuture ? 'ur' : 'urami';
	            }
	            return result;
	        case 'd':
	            return withoutSuffix || isFuture ? 'en dan' : 'enim dnem';
	        case 'dd':
	            if (number === 1) {
	                result += withoutSuffix || isFuture ? 'dan' : 'dnem';
	            } else if (number === 2) {
	                result += withoutSuffix || isFuture ? 'dni' : 'dnevoma';
	            } else {
	                result += withoutSuffix || isFuture ? 'dni' : 'dnevi';
	            }
	            return result;
	        case 'M':
	            return withoutSuffix || isFuture ? 'en mesec' : 'enim mesecem';
	        case 'MM':
	            if (number === 1) {
	                result += withoutSuffix || isFuture ? 'mesec' : 'mesecem';
	            } else if (number === 2) {
	                result += withoutSuffix || isFuture ? 'meseca' : 'mesecema';
	            } else if (number < 5) {
	                result += withoutSuffix || isFuture ? 'mesece' : 'meseci';
	            } else {
	                result += withoutSuffix || isFuture ? 'mesecev' : 'meseci';
	            }
	            return result;
	        case 'y':
	            return withoutSuffix || isFuture ? 'eno leto' : 'enim letom';
	        case 'yy':
	            if (number === 1) {
	                result += withoutSuffix || isFuture ? 'leto' : 'letom';
	            } else if (number === 2) {
	                result += withoutSuffix || isFuture ? 'leti' : 'letoma';
	            } else if (number < 5) {
	                result += withoutSuffix || isFuture ? 'leta' : 'leti';
	            } else {
	                result += withoutSuffix || isFuture ? 'let' : 'leti';
	            }
	            return result;
	        }
	    }

	    var sl = moment.defineLocale('sl', {
	        months : 'januar_februar_marec_april_maj_junij_julij_avgust_september_oktober_november_december'.split('_'),
	        monthsShort : 'jan._feb._mar._apr._maj._jun._jul._avg._sep._okt._nov._dec.'.split('_'),
	        weekdays : 'nedelja_ponedeljek_torek_sreda_etrtek_petek_sobota'.split('_'),
	        weekdaysShort : 'ned._pon._tor._sre._et._pet._sob.'.split('_'),
	        weekdaysMin : 'ne_po_to_sr_e_pe_so'.split('_'),
	        longDateFormat : {
	            LT : 'H:mm',
	            LTS : 'H:mm:ss',
	            L : 'DD. MM. YYYY',
	            LL : 'D. MMMM YYYY',
	            LLL : 'D. MMMM YYYY H:mm',
	            LLLL : 'dddd, D. MMMM YYYY H:mm'
	        },
	        calendar : {
	            sameDay  : '[danes ob] LT',
	            nextDay  : '[jutri ob] LT',

	            nextWeek : function () {
	                switch (this.day()) {
	                case 0:
	                    return '[v] [nedeljo] [ob] LT';
	                case 3:
	                    return '[v] [sredo] [ob] LT';
	                case 6:
	                    return '[v] [soboto] [ob] LT';
	                case 1:
	                case 2:
	                case 4:
	                case 5:
	                    return '[v] dddd [ob] LT';
	                }
	            },
	            lastDay  : '[veraj ob] LT',
	            lastWeek : function () {
	                switch (this.day()) {
	                case 0:
	                    return '[prejnjo] [nedeljo] [ob] LT';
	                case 3:
	                    return '[prejnjo] [sredo] [ob] LT';
	                case 6:
	                    return '[prejnjo] [soboto] [ob] LT';
	                case 1:
	                case 2:
	                case 4:
	                case 5:
	                    return '[prejnji] dddd [ob] LT';
	                }
	            },
	            sameElse : 'L'
	        },
	        relativeTime : {
	            future : 'ez %s',
	            past   : 'pred %s',
	            s      : processRelativeTime,
	            m      : processRelativeTime,
	            mm     : processRelativeTime,
	            h      : processRelativeTime,
	            hh     : processRelativeTime,
	            d      : processRelativeTime,
	            dd     : processRelativeTime,
	            M      : processRelativeTime,
	            MM     : processRelativeTime,
	            y      : processRelativeTime,
	            yy     : processRelativeTime
	        },
	        ordinalParse: /\d{1,2}\./,
	        ordinal : '%d.',
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 7  // The week that contains Jan 1st is the first week of the year.
	        }
	    });

	    return sl;

	}));

/***/ },
/* 127 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Albanian (sq)
	//! author : Flakrim Ismani : https://github.com/flakerimi
	//! author: Menelion Elensle: https://github.com/Oire (tests)
	//! author : Oerd Cukalla : https://github.com/oerd (fixes)

	(function (global, factory) {
	    true ? factory(__webpack_require__(56)) :
	   typeof define === 'function' && define.amd ? define(['moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';


	    var sq = moment.defineLocale('sq', {
	        months : 'Janar_Shkurt_Mars_Prill_Maj_Qershor_Korrik_Gusht_Shtator_Tetor_Nntor_Dhjetor'.split('_'),
	        monthsShort : 'Jan_Shk_Mar_Pri_Maj_Qer_Kor_Gus_Sht_Tet_Nn_Dhj'.split('_'),
	        weekdays : 'E Diel_E Hn_E Mart_E Mrkur_E Enjte_E Premte_E Shtun'.split('_'),
	        weekdaysShort : 'Die_Hn_Mar_Mr_Enj_Pre_Sht'.split('_'),
	        weekdaysMin : 'D_H_Ma_M_E_P_Sh'.split('_'),
	        meridiemParse: /PD|MD/,
	        isPM: function (input) {
	            return input.charAt(0) === 'M';
	        },
	        meridiem : function (hours, minutes, isLower) {
	            return hours < 12 ? 'PD' : 'MD';
	        },
	        longDateFormat : {
	            LT : 'HH:mm',
	            LTS : 'HH:mm:ss',
	            L : 'DD/MM/YYYY',
	            LL : 'D MMMM YYYY',
	            LLL : 'D MMMM YYYY HH:mm',
	            LLLL : 'dddd, D MMMM YYYY HH:mm'
	        },
	        calendar : {
	            sameDay : '[Sot n] LT',
	            nextDay : '[Nesr n] LT',
	            nextWeek : 'dddd [n] LT',
	            lastDay : '[Dje n] LT',
	            lastWeek : 'dddd [e kaluar n] LT',
	            sameElse : 'L'
	        },
	        relativeTime : {
	            future : 'n %s',
	            past : '%s m par',
	            s : 'disa sekonda',
	            m : 'nj minut',
	            mm : '%d minuta',
	            h : 'nj or',
	            hh : '%d or',
	            d : 'nj dit',
	            dd : '%d dit',
	            M : 'nj muaj',
	            MM : '%d muaj',
	            y : 'nj vit',
	            yy : '%d vite'
	        },
	        ordinalParse: /\d{1,2}\./,
	        ordinal : '%d.',
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 4  // The week that contains Jan 4th is the first week of the year.
	        }
	    });

	    return sq;

	}));

/***/ },
/* 128 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Serbian-latin (sr)
	//! author : Milan Janakovi<milanjanackovic@gmail.com> : https://github.com/milan-j

	(function (global, factory) {
	    true ? factory(__webpack_require__(56)) :
	   typeof define === 'function' && define.amd ? define(['moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';


	    var translator = {
	        words: { //Different grammatical cases
	            m: ['jedan minut', 'jedne minute'],
	            mm: ['minut', 'minute', 'minuta'],
	            h: ['jedan sat', 'jednog sata'],
	            hh: ['sat', 'sata', 'sati'],
	            dd: ['dan', 'dana', 'dana'],
	            MM: ['mesec', 'meseca', 'meseci'],
	            yy: ['godina', 'godine', 'godina']
	        },
	        correctGrammaticalCase: function (number, wordKey) {
	            return number === 1 ? wordKey[0] : (number >= 2 && number <= 4 ? wordKey[1] : wordKey[2]);
	        },
	        translate: function (number, withoutSuffix, key) {
	            var wordKey = translator.words[key];
	            if (key.length === 1) {
	                return withoutSuffix ? wordKey[0] : wordKey[1];
	            } else {
	                return number + ' ' + translator.correctGrammaticalCase(number, wordKey);
	            }
	        }
	    };

	    var sr = moment.defineLocale('sr', {
	        months: ['januar', 'februar', 'mart', 'april', 'maj', 'jun', 'jul', 'avgust', 'septembar', 'oktobar', 'novembar', 'decembar'],
	        monthsShort: ['jan.', 'feb.', 'mar.', 'apr.', 'maj', 'jun', 'jul', 'avg.', 'sep.', 'okt.', 'nov.', 'dec.'],
	        weekdays: ['nedelja', 'ponedeljak', 'utorak', 'sreda', 'etvrtak', 'petak', 'subota'],
	        weekdaysShort: ['ned.', 'pon.', 'uto.', 'sre.', 'et.', 'pet.', 'sub.'],
	        weekdaysMin: ['ne', 'po', 'ut', 'sr', 'e', 'pe', 'su'],
	        longDateFormat: {
	            LT: 'H:mm',
	            LTS : 'H:mm:ss',
	            L: 'DD. MM. YYYY',
	            LL: 'D. MMMM YYYY',
	            LLL: 'D. MMMM YYYY H:mm',
	            LLLL: 'dddd, D. MMMM YYYY H:mm'
	        },
	        calendar: {
	            sameDay: '[danas u] LT',
	            nextDay: '[sutra u] LT',
	            nextWeek: function () {
	                switch (this.day()) {
	                case 0:
	                    return '[u] [nedelju] [u] LT';
	                case 3:
	                    return '[u] [sredu] [u] LT';
	                case 6:
	                    return '[u] [subotu] [u] LT';
	                case 1:
	                case 2:
	                case 4:
	                case 5:
	                    return '[u] dddd [u] LT';
	                }
	            },
	            lastDay  : '[jue u] LT',
	            lastWeek : function () {
	                var lastWeekDays = [
	                    '[prole] [nedelje] [u] LT',
	                    '[prolog] [ponedeljka] [u] LT',
	                    '[prolog] [utorka] [u] LT',
	                    '[prole] [srede] [u] LT',
	                    '[prolog] [etvrtka] [u] LT',
	                    '[prolog] [petka] [u] LT',
	                    '[prole] [subote] [u] LT'
	                ];
	                return lastWeekDays[this.day()];
	            },
	            sameElse : 'L'
	        },
	        relativeTime : {
	            future : 'za %s',
	            past   : 'pre %s',
	            s      : 'nekoliko sekundi',
	            m      : translator.translate,
	            mm     : translator.translate,
	            h      : translator.translate,
	            hh     : translator.translate,
	            d      : 'dan',
	            dd     : translator.translate,
	            M      : 'mesec',
	            MM     : translator.translate,
	            y      : 'godinu',
	            yy     : translator.translate
	        },
	        ordinalParse: /\d{1,2}\./,
	        ordinal : '%d.',
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 7  // The week that contains Jan 1st is the first week of the year.
	        }
	    });

	    return sr;

	}));

/***/ },
/* 129 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Serbian-cyrillic (sr-cyrl)
	//! author : Milan Janakovi<milanjanackovic@gmail.com> : https://github.com/milan-j

	(function (global, factory) {
	    true ? factory(__webpack_require__(56)) :
	   typeof define === 'function' && define.amd ? define(['moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';


	    var translator = {
	        words: { //Different grammatical cases
	            m: [' ', ' '],
	            mm: ['', '', ''],
	            h: [' ', ' '],
	            hh: ['', '', ''],
	            dd: ['', '', ''],
	            MM: ['', '', ''],
	            yy: ['', '', '']
	        },
	        correctGrammaticalCase: function (number, wordKey) {
	            return number === 1 ? wordKey[0] : (number >= 2 && number <= 4 ? wordKey[1] : wordKey[2]);
	        },
	        translate: function (number, withoutSuffix, key) {
	            var wordKey = translator.words[key];
	            if (key.length === 1) {
	                return withoutSuffix ? wordKey[0] : wordKey[1];
	            } else {
	                return number + ' ' + translator.correctGrammaticalCase(number, wordKey);
	            }
	        }
	    };

	    var sr_cyrl = moment.defineLocale('sr-cyrl', {
	        months: ['', '', '', '', '', '', '', '', '', '', '', ''],
	        monthsShort: ['.', '.', '.', '.', '', '', '', '.', '.', '.', '.', '.'],
	        weekdays: ['', '', '', '', '', '', ''],
	        weekdaysShort: ['.', '.', '.', '.', '.', '.', '.'],
	        weekdaysMin: ['', '', '', '', '', '', ''],
	        longDateFormat: {
	            LT: 'H:mm',
	            LTS : 'H:mm:ss',
	            L: 'DD. MM. YYYY',
	            LL: 'D. MMMM YYYY',
	            LLL: 'D. MMMM YYYY H:mm',
	            LLLL: 'dddd, D. MMMM YYYY H:mm'
	        },
	        calendar: {
	            sameDay: '[ ] LT',
	            nextDay: '[ ] LT',
	            nextWeek: function () {
	                switch (this.day()) {
	                case 0:
	                    return '[] [] [] LT';
	                case 3:
	                    return '[] [] [] LT';
	                case 6:
	                    return '[] [] [] LT';
	                case 1:
	                case 2:
	                case 4:
	                case 5:
	                    return '[] dddd [] LT';
	                }
	            },
	            lastDay  : '[ ] LT',
	            lastWeek : function () {
	                var lastWeekDays = [
	                    '[] [] [] LT',
	                    '[] [] [] LT',
	                    '[] [] [] LT',
	                    '[] [] [] LT',
	                    '[] [] [] LT',
	                    '[] [] [] LT',
	                    '[] [] [] LT'
	                ];
	                return lastWeekDays[this.day()];
	            },
	            sameElse : 'L'
	        },
	        relativeTime : {
	            future : ' %s',
	            past   : ' %s',
	            s      : ' ',
	            m      : translator.translate,
	            mm     : translator.translate,
	            h      : translator.translate,
	            hh     : translator.translate,
	            d      : '',
	            dd     : translator.translate,
	            M      : '',
	            MM     : translator.translate,
	            y      : '',
	            yy     : translator.translate
	        },
	        ordinalParse: /\d{1,2}\./,
	        ordinal : '%d.',
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 7  // The week that contains Jan 1st is the first week of the year.
	        }
	    });

	    return sr_cyrl;

	}));

/***/ },
/* 130 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : swedish (sv)
	//! author : Jens Alm : https://github.com/ulmus

	(function (global, factory) {
	    true ? factory(__webpack_require__(56)) :
	   typeof define === 'function' && define.amd ? define(['moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';


	    var sv = moment.defineLocale('sv', {
	        months : 'januari_februari_mars_april_maj_juni_juli_augusti_september_oktober_november_december'.split('_'),
	        monthsShort : 'jan_feb_mar_apr_maj_jun_jul_aug_sep_okt_nov_dec'.split('_'),
	        weekdays : 'sndag_mndag_tisdag_onsdag_torsdag_fredag_lrdag'.split('_'),
	        weekdaysShort : 'sn_mn_tis_ons_tor_fre_lr'.split('_'),
	        weekdaysMin : 's_m_ti_on_to_fr_l'.split('_'),
	        longDateFormat : {
	            LT : 'HH:mm',
	            LTS : 'HH:mm:ss',
	            L : 'YYYY-MM-DD',
	            LL : 'D MMMM YYYY',
	            LLL : 'D MMMM YYYY HH:mm',
	            LLLL : 'dddd D MMMM YYYY HH:mm'
	        },
	        calendar : {
	            sameDay: '[Idag] LT',
	            nextDay: '[Imorgon] LT',
	            lastDay: '[Igr] LT',
	            nextWeek: '[P] dddd LT',
	            lastWeek: '[I] dddd[s] LT',
	            sameElse: 'L'
	        },
	        relativeTime : {
	            future : 'om %s',
	            past : 'fr %s sedan',
	            s : 'ngra sekunder',
	            m : 'en minut',
	            mm : '%d minuter',
	            h : 'en timme',
	            hh : '%d timmar',
	            d : 'en dag',
	            dd : '%d dagar',
	            M : 'en mnad',
	            MM : '%d mnader',
	            y : 'ett r',
	            yy : '%d r'
	        },
	        ordinalParse: /\d{1,2}(e|a)/,
	        ordinal : function (number) {
	            var b = number % 10,
	                output = (~~(number % 100 / 10) === 1) ? 'e' :
	                (b === 1) ? 'a' :
	                (b === 2) ? 'a' :
	                (b === 3) ? 'e' : 'e';
	            return number + output;
	        },
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 4  // The week that contains Jan 4th is the first week of the year.
	        }
	    });

	    return sv;

	}));

/***/ },
/* 131 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : tamil (ta)
	//! author : Arjunkumar Krishnamoorthy : https://github.com/tk120404

	(function (global, factory) {
	    true ? factory(__webpack_require__(56)) :
	   typeof define === 'function' && define.amd ? define(['moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';


	    var ta = moment.defineLocale('ta', {
	        months : '___________'.split('_'),
	        monthsShort : '___________'.split('_'),
	        weekdays : '______'.split('_'),
	        weekdaysShort : '______'.split('_'),
	        weekdaysMin : '______'.split('_'),
	        longDateFormat : {
	            LT : 'HH:mm',
	            LTS : 'HH:mm:ss',
	            L : 'DD/MM/YYYY',
	            LL : 'D MMMM YYYY',
	            LLL : 'D MMMM YYYY, HH:mm',
	            LLLL : 'dddd, D MMMM YYYY, HH:mm'
	        },
	        calendar : {
	            sameDay : '[] LT',
	            nextDay : '[] LT',
	            nextWeek : 'dddd, LT',
	            lastDay : '[] LT',
	            lastWeek : '[ ] dddd, LT',
	            sameElse : 'L'
	        },
	        relativeTime : {
	            future : '%s ',
	            past : '%s ',
	            s : '  ',
	            m : ' ',
	            mm : '%d ',
	            h : '  ',
	            hh : '%d  ',
	            d : ' ',
	            dd : '%d ',
	            M : ' ',
	            MM : '%d ',
	            y : ' ',
	            yy : '%d '
	        },
	        ordinalParse: /\d{1,2}/,
	        ordinal : function (number) {
	            return number + '';
	        },
	        // refer http://ta.wikipedia.org/s/1er1
	        meridiemParse: /|||||/,
	        meridiem : function (hour, minute, isLower) {
	            if (hour < 2) {
	                return ' ';
	            } else if (hour < 6) {
	                return ' ';  // 
	            } else if (hour < 10) {
	                return ' '; // 
	            } else if (hour < 14) {
	                return ' '; // 
	            } else if (hour < 18) {
	                return ' '; // 
	            } else if (hour < 22) {
	                return ' '; // 
	            } else {
	                return ' ';
	            }
	        },
	        meridiemHour : function (hour, meridiem) {
	            if (hour === 12) {
	                hour = 0;
	            }
	            if (meridiem === '') {
	                return hour < 2 ? hour : hour + 12;
	            } else if (meridiem === '' || meridiem === '') {
	                return hour;
	            } else if (meridiem === '') {
	                return hour >= 10 ? hour : hour + 12;
	            } else {
	                return hour + 12;
	            }
	        },
	        week : {
	            dow : 0, // Sunday is the first day of the week.
	            doy : 6  // The week that contains Jan 1st is the first week of the year.
	        }
	    });

	    return ta;

	}));

/***/ },
/* 132 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : thai (th)
	//! author : Kridsada Thanabulpong : https://github.com/sirn

	(function (global, factory) {
	    true ? factory(__webpack_require__(56)) :
	   typeof define === 'function' && define.amd ? define(['moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';


	    var th = moment.defineLocale('th', {
	        months : '___________'.split('_'),
	        monthsShort : '___________'.split('_'),
	        weekdays : '______'.split('_'),
	        weekdaysShort : '______'.split('_'), // yes, three characters difference
	        weekdaysMin : '._._._._._._.'.split('_'),
	        longDateFormat : {
	            LT : 'H  m ',
	            LTS : 'H  m  s ',
	            L : 'YYYY/MM/DD',
	            LL : 'D MMMM YYYY',
	            LLL : 'D MMMM YYYY  H  m ',
	            LLLL : 'dddd D MMMM YYYY  H  m '
	        },
	        meridiemParse: /|/,
	        isPM: function (input) {
	            return input === '';
	        },
	        meridiem : function (hour, minute, isLower) {
	            if (hour < 12) {
	                return '';
	            } else {
	                return '';
	            }
	        },
	        calendar : {
	            sameDay : '[ ] LT',
	            nextDay : '[ ] LT',
	            nextWeek : 'dddd[ ] LT',
	            lastDay : '[ ] LT',
	            lastWeek : '[]dddd[ ] LT',
	            sameElse : 'L'
	        },
	        relativeTime : {
	            future : ' %s',
	            past : '%s',
	            s : '',
	            m : '1 ',
	            mm : '%d ',
	            h : '1 ',
	            hh : '%d ',
	            d : '1 ',
	            dd : '%d ',
	            M : '1 ',
	            MM : '%d ',
	            y : '1 ',
	            yy : '%d '
	        }
	    });

	    return th;

	}));

/***/ },
/* 133 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Tagalog/Filipino (tl-ph)
	//! author : Dan Hagman

	(function (global, factory) {
	    true ? factory(__webpack_require__(56)) :
	   typeof define === 'function' && define.amd ? define(['moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';


	    var tl_ph = moment.defineLocale('tl-ph', {
	        months : 'Enero_Pebrero_Marso_Abril_Mayo_Hunyo_Hulyo_Agosto_Setyembre_Oktubre_Nobyembre_Disyembre'.split('_'),
	        monthsShort : 'Ene_Peb_Mar_Abr_May_Hun_Hul_Ago_Set_Okt_Nob_Dis'.split('_'),
	        weekdays : 'Linggo_Lunes_Martes_Miyerkules_Huwebes_Biyernes_Sabado'.split('_'),
	        weekdaysShort : 'Lin_Lun_Mar_Miy_Huw_Biy_Sab'.split('_'),
	        weekdaysMin : 'Li_Lu_Ma_Mi_Hu_Bi_Sab'.split('_'),
	        longDateFormat : {
	            LT : 'HH:mm',
	            LTS : 'HH:mm:ss',
	            L : 'MM/D/YYYY',
	            LL : 'MMMM D, YYYY',
	            LLL : 'MMMM D, YYYY HH:mm',
	            LLLL : 'dddd, MMMM DD, YYYY HH:mm'
	        },
	        calendar : {
	            sameDay: '[Ngayon sa] LT',
	            nextDay: '[Bukas sa] LT',
	            nextWeek: 'dddd [sa] LT',
	            lastDay: '[Kahapon sa] LT',
	            lastWeek: 'dddd [huling linggo] LT',
	            sameElse: 'L'
	        },
	        relativeTime : {
	            future : 'sa loob ng %s',
	            past : '%s ang nakalipas',
	            s : 'ilang segundo',
	            m : 'isang minuto',
	            mm : '%d minuto',
	            h : 'isang oras',
	            hh : '%d oras',
	            d : 'isang araw',
	            dd : '%d araw',
	            M : 'isang buwan',
	            MM : '%d buwan',
	            y : 'isang taon',
	            yy : '%d taon'
	        },
	        ordinalParse: /\d{1,2}/,
	        ordinal : function (number) {
	            return number;
	        },
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 4  // The week that contains Jan 4th is the first week of the year.
	        }
	    });

	    return tl_ph;

	}));

/***/ },
/* 134 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : turkish (tr)
	//! authors : Erhan Gundogan : https://github.com/erhangundogan,
	//!           Burak Yiit Kaya: https://github.com/BYK

	(function (global, factory) {
	    true ? factory(__webpack_require__(56)) :
	   typeof define === 'function' && define.amd ? define(['moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';


	    var suffixes = {
	        1: '\'inci',
	        5: '\'inci',
	        8: '\'inci',
	        70: '\'inci',
	        80: '\'inci',
	        2: '\'nci',
	        7: '\'nci',
	        20: '\'nci',
	        50: '\'nci',
	        3: '\'nc',
	        4: '\'nc',
	        100: '\'nc',
	        6: '\'nc',
	        9: '\'uncu',
	        10: '\'uncu',
	        30: '\'uncu',
	        60: '\'nc',
	        90: '\'nc'
	    };

	    var tr = moment.defineLocale('tr', {
	        months : 'Ocak_ubat_Mart_Nisan_Mays_Haziran_Temmuz_Austos_Eyll_Ekim_Kasm_Aralk'.split('_'),
	        monthsShort : 'Oca_ub_Mar_Nis_May_Haz_Tem_Au_Eyl_Eki_Kas_Ara'.split('_'),
	        weekdays : 'Pazar_Pazartesi_Sal_aramba_Perembe_Cuma_Cumartesi'.split('_'),
	        weekdaysShort : 'Paz_Pts_Sal_ar_Per_Cum_Cts'.split('_'),
	        weekdaysMin : 'Pz_Pt_Sa_a_Pe_Cu_Ct'.split('_'),
	        longDateFormat : {
	            LT : 'HH:mm',
	            LTS : 'HH:mm:ss',
	            L : 'DD.MM.YYYY',
	            LL : 'D MMMM YYYY',
	            LLL : 'D MMMM YYYY HH:mm',
	            LLLL : 'dddd, D MMMM YYYY HH:mm'
	        },
	        calendar : {
	            sameDay : '[bugn saat] LT',
	            nextDay : '[yarn saat] LT',
	            nextWeek : '[haftaya] dddd [saat] LT',
	            lastDay : '[dn] LT',
	            lastWeek : '[geen hafta] dddd [saat] LT',
	            sameElse : 'L'
	        },
	        relativeTime : {
	            future : '%s sonra',
	            past : '%s nce',
	            s : 'birka saniye',
	            m : 'bir dakika',
	            mm : '%d dakika',
	            h : 'bir saat',
	            hh : '%d saat',
	            d : 'bir gn',
	            dd : '%d gn',
	            M : 'bir ay',
	            MM : '%d ay',
	            y : 'bir yl',
	            yy : '%d yl'
	        },
	        ordinalParse: /\d{1,2}'(inci|nci|nc|nc|uncu|nc)/,
	        ordinal : function (number) {
	            if (number === 0) {  // special case for zero
	                return number + '\'nc';
	            }
	            var a = number % 10,
	                b = number % 100 - a,
	                c = number >= 100 ? 100 : null;
	            return number + (suffixes[a] || suffixes[b] || suffixes[c]);
	        },
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 7  // The week that contains Jan 1st is the first week of the year.
	        }
	    });

	    return tr;

	}));

/***/ },
/* 135 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : talossan (tzl)
	//! author : Robin van der Vliet : https://github.com/robin0van0der0v with the help of Iust Canun

	(function (global, factory) {
	    true ? factory(__webpack_require__(56)) :
	   typeof define === 'function' && define.amd ? define(['moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';



	    var tzl = moment.defineLocale('tzl', {
	        months : 'Januar_Fevraglh_Mar_Avru_Mai_Gn_Julia_Guscht_Setemvar_Listopts_Noemvar_Zecemvar'.split('_'),
	        monthsShort : 'Jan_Fev_Mar_Avr_Mai_Gn_Jul_Gus_Set_Lis_Noe_Zec'.split('_'),
	        weekdays : 'Sladi_Lnei_Maitzi_Mrcuri_Xhadi_Vineri_Sturi'.split('_'),
	        weekdaysShort : 'Sl_Ln_Mai_Mr_Xh_Vi_St'.split('_'),
	        weekdaysMin : 'S_L_Ma_M_Xh_Vi_S'.split('_'),
	        longDateFormat : {
	            LT : 'HH.mm',
	            LTS : 'LT.ss',
	            L : 'DD.MM.YYYY',
	            LL : 'D. MMMM [dallas] YYYY',
	            LLL : 'D. MMMM [dallas] YYYY LT',
	            LLLL : 'dddd, [li] D. MMMM [dallas] YYYY LT'
	        },
	        meridiem : function (hours, minutes, isLower) {
	            if (hours > 11) {
	                return isLower ? 'd\'o' : 'D\'O';
	            } else {
	                return isLower ? 'd\'a' : 'D\'A';
	            }
	        },
	        calendar : {
	            sameDay : '[oxhi ] LT',
	            nextDay : '[dem ] LT',
	            nextWeek : 'dddd [] LT',
	            lastDay : '[ieiri ] LT',
	            lastWeek : '[sr el] dddd [lasteu ] LT',
	            sameElse : 'L'
	        },
	        relativeTime : {
	            future : 'osprei %s',
	            past : 'ja%s',
	            s : processRelativeTime,
	            m : processRelativeTime,
	            mm : processRelativeTime,
	            h : processRelativeTime,
	            hh : processRelativeTime,
	            d : processRelativeTime,
	            dd : processRelativeTime,
	            M : processRelativeTime,
	            MM : processRelativeTime,
	            y : processRelativeTime,
	            yy : processRelativeTime
	        },
	        ordinalParse: /\d{1,2}\./,
	        ordinal : '%d.',
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 4  // The week that contains Jan 4th is the first week of the year.
	        }
	    });

	    function processRelativeTime(number, withoutSuffix, key, isFuture) {
	        var format = {
	            's': ['viensas secunds', '\'iensas secunds'],
	            'm': ['\'n mut', '\'iens mut'],
	            'mm': [number + ' muts', ' ' + number + ' muts'],
	            'h': ['\'n ora', '\'iensa ora'],
	            'hh': [number + ' oras', ' ' + number + ' oras'],
	            'd': ['\'n ziua', '\'iensa ziua'],
	            'dd': [number + ' ziuas', ' ' + number + ' ziuas'],
	            'M': ['\'n mes', '\'iens mes'],
	            'MM': [number + ' mesen', ' ' + number + ' mesen'],
	            'y': ['\'n ar', '\'iens ar'],
	            'yy': [number + ' ars', ' ' + number + ' ars']
	        };
	        return isFuture ? format[key][0] : (withoutSuffix ? format[key][0] : format[key][1].trim());
	    }

	    return tzl;

	}));

/***/ },
/* 136 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Morocco Central Atlas Tamazit (tzm)
	//! author : Abdel Said : https://github.com/abdelsaid

	(function (global, factory) {
	    true ? factory(__webpack_require__(56)) :
	   typeof define === 'function' && define.amd ? define(['moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';


	    var tzm = moment.defineLocale('tzm', {
	        months : '___________'.split('_'),
	        monthsShort : '___________'.split('_'),
	        weekdays : '______'.split('_'),
	        weekdaysShort : '______'.split('_'),
	        weekdaysMin : '______'.split('_'),
	        longDateFormat : {
	            LT : 'HH:mm',
	            LTS: 'HH:mm:ss',
	            L : 'DD/MM/YYYY',
	            LL : 'D MMMM YYYY',
	            LLL : 'D MMMM YYYY HH:mm',
	            LLLL : 'dddd D MMMM YYYY HH:mm'
	        },
	        calendar : {
	            sameDay: '[ ] LT',
	            nextDay: '[ ] LT',
	            nextWeek: 'dddd [] LT',
	            lastDay: '[ ] LT',
	            lastWeek: 'dddd [] LT',
	            sameElse: 'L'
	        },
	        relativeTime : {
	            future : '   %s',
	            past : ' %s',
	            s : '',
	            m : '',
	            mm : '%d ',
	            h : '',
	            hh : '%d ',
	            d : '',
	            dd : '%d o',
	            M : 'o',
	            MM : '%d ',
	            y : '',
	            yy : '%d '
	        },
	        week : {
	            dow : 6, // Saturday is the first day of the week.
	            doy : 12  // The week that contains Jan 1st is the first week of the year.
	        }
	    });

	    return tzm;

	}));

/***/ },
/* 137 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Morocco Central Atlas Tamazit in Latin (tzm-latn)
	//! author : Abdel Said : https://github.com/abdelsaid

	(function (global, factory) {
	    true ? factory(__webpack_require__(56)) :
	   typeof define === 'function' && define.amd ? define(['moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';


	    var tzm_latn = moment.defineLocale('tzm-latn', {
	        months : 'innayr_brayr_mars_ibrir_mayyw_ywnyw_ywlywz_wt_wtanbir_ktwbr_nwwanbir_dwjnbir'.split('_'),
	        monthsShort : 'innayr_brayr_mars_ibrir_mayyw_ywnyw_ywlywz_wt_wtanbir_ktwbr_nwwanbir_dwjnbir'.split('_'),
	        weekdays : 'asamas_aynas_asinas_akras_akwas_asimwas_asiyas'.split('_'),
	        weekdaysShort : 'asamas_aynas_asinas_akras_akwas_asimwas_asiyas'.split('_'),
	        weekdaysMin : 'asamas_aynas_asinas_akras_akwas_asimwas_asiyas'.split('_'),
	        longDateFormat : {
	            LT : 'HH:mm',
	            LTS : 'HH:mm:ss',
	            L : 'DD/MM/YYYY',
	            LL : 'D MMMM YYYY',
	            LLL : 'D MMMM YYYY HH:mm',
	            LLLL : 'dddd D MMMM YYYY HH:mm'
	        },
	        calendar : {
	            sameDay: '[asdkh g] LT',
	            nextDay: '[aska g] LT',
	            nextWeek: 'dddd [g] LT',
	            lastDay: '[assant g] LT',
	            lastWeek: 'dddd [g] LT',
	            sameElse: 'L'
	        },
	        relativeTime : {
	            future : 'dadkh s yan %s',
	            past : 'yan %s',
	            s : 'imik',
	            m : 'minu',
	            mm : '%d minu',
	            h : 'saa',
	            hh : '%d tassain',
	            d : 'ass',
	            dd : '%d ossan',
	            M : 'ayowr',
	            MM : '%d iyyirn',
	            y : 'asgas',
	            yy : '%d isgasn'
	        },
	        week : {
	            dow : 6, // Saturday is the first day of the week.
	            doy : 12  // The week that contains Jan 1st is the first week of the year.
	        }
	    });

	    return tzm_latn;

	}));

/***/ },
/* 138 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : ukrainian (uk)
	//! author : zemlanin : https://github.com/zemlanin
	//! Author : Menelion Elensle : https://github.com/Oire

	(function (global, factory) {
	    true ? factory(__webpack_require__(56)) :
	   typeof define === 'function' && define.amd ? define(['moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';


	    function plural(word, num) {
	        var forms = word.split('_');
	        return num % 10 === 1 && num % 100 !== 11 ? forms[0] : (num % 10 >= 2 && num % 10 <= 4 && (num % 100 < 10 || num % 100 >= 20) ? forms[1] : forms[2]);
	    }
	    function relativeTimeWithPlural(number, withoutSuffix, key) {
	        var format = {
	            'mm': '__',
	            'hh': '__',
	            'dd': '__',
	            'MM': '__',
	            'yy': '__'
	        };
	        if (key === 'm') {
	            return withoutSuffix ? '' : '';
	        }
	        else if (key === 'h') {
	            return withoutSuffix ? '' : '';
	        }
	        else {
	            return number + ' ' + plural(format[key], +number);
	        }
	    }
	    function monthsCaseReplace(m, format) {
	        var months = {
	            'nominative': '___________'.split('_'),
	            'accusative': '___________'.split('_')
	        },
	        nounCase = (/D[oD]? *MMMM?/).test(format) ?
	            'accusative' :
	            'nominative';
	        return months[nounCase][m.month()];
	    }
	    function weekdaysCaseReplace(m, format) {
	        var weekdays = {
	            'nominative': '______'.split('_'),
	            'accusative': '______'.split('_'),
	            'genitive': '______'.split('_')
	        },
	        nounCase = (/(\[[]\]) ?dddd/).test(format) ?
	            'accusative' :
	            ((/\[?(?:|)? ?\] ?dddd/).test(format) ?
	                'genitive' :
	                'nominative');
	        return weekdays[nounCase][m.day()];
	    }
	    function processHoursFunction(str) {
	        return function () {
	            return str + '' + (this.hours() === 11 ? '' : '') + '] LT';
	        };
	    }

	    var uk = moment.defineLocale('uk', {
	        months : monthsCaseReplace,
	        monthsShort : '___________'.split('_'),
	        weekdays : weekdaysCaseReplace,
	        weekdaysShort : '______'.split('_'),
	        weekdaysMin : '______'.split('_'),
	        longDateFormat : {
	            LT : 'HH:mm',
	            LTS : 'HH:mm:ss',
	            L : 'DD.MM.YYYY',
	            LL : 'D MMMM YYYY .',
	            LLL : 'D MMMM YYYY ., HH:mm',
	            LLLL : 'dddd, D MMMM YYYY ., HH:mm'
	        },
	        calendar : {
	            sameDay: processHoursFunction('[ '),
	            nextDay: processHoursFunction('[ '),
	            lastDay: processHoursFunction('[ '),
	            nextWeek: processHoursFunction('[] dddd ['),
	            lastWeek: function () {
	                switch (this.day()) {
	                case 0:
	                case 3:
	                case 5:
	                case 6:
	                    return processHoursFunction('[] dddd [').call(this);
	                case 1:
	                case 2:
	                case 4:
	                    return processHoursFunction('[] dddd [').call(this);
	                }
	            },
	            sameElse: 'L'
	        },
	        relativeTime : {
	            future : ' %s',
	            past : '%s ',
	            s : ' ',
	            m : relativeTimeWithPlural,
	            mm : relativeTimeWithPlural,
	            h : '',
	            hh : relativeTimeWithPlural,
	            d : '',
	            dd : relativeTimeWithPlural,
	            M : '',
	            MM : relativeTimeWithPlural,
	            y : '',
	            yy : relativeTimeWithPlural
	        },
	        // M. E.: those two are virtually unused but a user might want to implement them for his/her website for some reason
	        meridiemParse: /|||/,
	        isPM: function (input) {
	            return /^(|)$/.test(input);
	        },
	        meridiem : function (hour, minute, isLower) {
	            if (hour < 4) {
	                return '';
	            } else if (hour < 12) {
	                return '';
	            } else if (hour < 17) {
	                return '';
	            } else {
	                return '';
	            }
	        },
	        ordinalParse: /\d{1,2}-(|)/,
	        ordinal: function (number, period) {
	            switch (period) {
	            case 'M':
	            case 'd':
	            case 'DDD':
	            case 'w':
	            case 'W':
	                return number + '-';
	            case 'D':
	                return number + '-';
	            default:
	                return number;
	            }
	        },
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 7  // The week that contains Jan 1st is the first week of the year.
	        }
	    });

	    return uk;

	}));

/***/ },
/* 139 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : uzbek (uz)
	//! author : Sardor Muminov : https://github.com/muminoff

	(function (global, factory) {
	    true ? factory(__webpack_require__(56)) :
	   typeof define === 'function' && define.amd ? define(['moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';


	    var uz = moment.defineLocale('uz', {
	        months : '___________'.split('_'),
	        monthsShort : '___________'.split('_'),
	        weekdays : '______'.split('_'),
	        weekdaysShort : '______'.split('_'),
	        weekdaysMin : '______'.split('_'),
	        longDateFormat : {
	            LT : 'HH:mm',
	            LTS : 'HH:mm:ss',
	            L : 'DD/MM/YYYY',
	            LL : 'D MMMM YYYY',
	            LLL : 'D MMMM YYYY HH:mm',
	            LLLL : 'D MMMM YYYY, dddd HH:mm'
	        },
	        calendar : {
	            sameDay : '[ ] LT []',
	            nextDay : '[] LT []',
	            nextWeek : 'dddd [ ] LT []',
	            lastDay : '[ ] LT []',
	            lastWeek : '[] dddd [ ] LT []',
	            sameElse : 'L'
	        },
	        relativeTime : {
	            future : ' %s ',
	            past : '  %s ',
	            s : '',
	            m : ' ',
	            mm : '%d ',
	            h : ' ',
	            hh : '%d ',
	            d : ' ',
	            dd : '%d ',
	            M : ' ',
	            MM : '%d ',
	            y : ' ',
	            yy : '%d '
	        },
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 7  // The week that contains Jan 4th is the first week of the year.
	        }
	    });

	    return uz;

	}));

/***/ },
/* 140 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : vietnamese (vi)
	//! author : Bang Nguyen : https://github.com/bangnk

	(function (global, factory) {
	    true ? factory(__webpack_require__(56)) :
	   typeof define === 'function' && define.amd ? define(['moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';


	    var vi = moment.defineLocale('vi', {
	        months : 'thng 1_thng 2_thng 3_thng 4_thng 5_thng 6_thng 7_thng 8_thng 9_thng 10_thng 11_thng 12'.split('_'),
	        monthsShort : 'Th01_Th02_Th03_Th04_Th05_Th06_Th07_Th08_Th09_Th10_Th11_Th12'.split('_'),
	        weekdays : 'ch nht_th hai_th ba_th t_th nm_th su_th by'.split('_'),
	        weekdaysShort : 'CN_T2_T3_T4_T5_T6_T7'.split('_'),
	        weekdaysMin : 'CN_T2_T3_T4_T5_T6_T7'.split('_'),
	        longDateFormat : {
	            LT : 'HH:mm',
	            LTS : 'HH:mm:ss',
	            L : 'DD/MM/YYYY',
	            LL : 'D MMMM [nm] YYYY',
	            LLL : 'D MMMM [nm] YYYY HH:mm',
	            LLLL : 'dddd, D MMMM [nm] YYYY HH:mm',
	            l : 'DD/M/YYYY',
	            ll : 'D MMM YYYY',
	            lll : 'D MMM YYYY HH:mm',
	            llll : 'ddd, D MMM YYYY HH:mm'
	        },
	        calendar : {
	            sameDay: '[Hm nay lc] LT',
	            nextDay: '[Ngy mai lc] LT',
	            nextWeek: 'dddd [tun ti lc] LT',
	            lastDay: '[Hm qua lc] LT',
	            lastWeek: 'dddd [tun ri lc] LT',
	            sameElse: 'L'
	        },
	        relativeTime : {
	            future : '%s ti',
	            past : '%s trc',
	            s : 'vi giy',
	            m : 'mt pht',
	            mm : '%d pht',
	            h : 'mt gi',
	            hh : '%d gi',
	            d : 'mt ngy',
	            dd : '%d ngy',
	            M : 'mt thng',
	            MM : '%d thng',
	            y : 'mt nm',
	            yy : '%d nm'
	        },
	        ordinalParse: /\d{1,2}/,
	        ordinal : function (number) {
	            return number;
	        },
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 4  // The week that contains Jan 4th is the first week of the year.
	        }
	    });

	    return vi;

	}));

/***/ },
/* 141 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : chinese (zh-cn)
	//! author : suupic : https://github.com/suupic
	//! author : Zeno Zeng : https://github.com/zenozeng

	(function (global, factory) {
	    true ? factory(__webpack_require__(56)) :
	   typeof define === 'function' && define.amd ? define(['moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';


	    var zh_cn = moment.defineLocale('zh-cn', {
	        months : '___________'.split('_'),
	        monthsShort : '1_2_3_4_5_6_7_8_9_10_11_12'.split('_'),
	        weekdays : '______'.split('_'),
	        weekdaysShort : '______'.split('_'),
	        weekdaysMin : '______'.split('_'),
	        longDateFormat : {
	            LT : 'Ahmm',
	            LTS : 'Ahms',
	            L : 'YYYY-MM-DD',
	            LL : 'YYYYMMMD',
	            LLL : 'YYYYMMMDAhmm',
	            LLLL : 'YYYYMMMDddddAhmm',
	            l : 'YYYY-MM-DD',
	            ll : 'YYYYMMMD',
	            lll : 'YYYYMMMDAhmm',
	            llll : 'YYYYMMMDddddAhmm'
	        },
	        meridiemParse: /|||||/,
	        meridiemHour: function (hour, meridiem) {
	            if (hour === 12) {
	                hour = 0;
	            }
	            if (meridiem === '' || meridiem === '' ||
	                    meridiem === '') {
	                return hour;
	            } else if (meridiem === '' || meridiem === '') {
	                return hour + 12;
	            } else {
	                // ''
	                return hour >= 11 ? hour : hour + 12;
	            }
	        },
	        meridiem : function (hour, minute, isLower) {
	            var hm = hour * 100 + minute;
	            if (hm < 600) {
	                return '';
	            } else if (hm < 900) {
	                return '';
	            } else if (hm < 1130) {
	                return '';
	            } else if (hm < 1230) {
	                return '';
	            } else if (hm < 1800) {
	                return '';
	            } else {
	                return '';
	            }
	        },
	        calendar : {
	            sameDay : function () {
	                return this.minutes() === 0 ? '[]Ah[]' : '[]LT';
	            },
	            nextDay : function () {
	                return this.minutes() === 0 ? '[]Ah[]' : '[]LT';
	            },
	            lastDay : function () {
	                return this.minutes() === 0 ? '[]Ah[]' : '[]LT';
	            },
	            nextWeek : function () {
	                var startOfWeek, prefix;
	                startOfWeek = moment().startOf('week');
	                prefix = this.unix() - startOfWeek.unix() >= 7 * 24 * 3600 ? '[]' : '[]';
	                return this.minutes() === 0 ? prefix + 'dddAh' : prefix + 'dddAhmm';
	            },
	            lastWeek : function () {
	                var startOfWeek, prefix;
	                startOfWeek = moment().startOf('week');
	                prefix = this.unix() < startOfWeek.unix()  ? '[]' : '[]';
	                return this.minutes() === 0 ? prefix + 'dddAh' : prefix + 'dddAhmm';
	            },
	            sameElse : 'LL'
	        },
	        ordinalParse: /\d{1,2}(||)/,
	        ordinal : function (number, period) {
	            switch (period) {
	            case 'd':
	            case 'D':
	            case 'DDD':
	                return number + '';
	            case 'M':
	                return number + '';
	            case 'w':
	            case 'W':
	                return number + '';
	            default:
	                return number;
	            }
	        },
	        relativeTime : {
	            future : '%s',
	            past : '%s',
	            s : '',
	            m : '1 ',
	            mm : '%d ',
	            h : '1 ',
	            hh : '%d ',
	            d : '1 ',
	            dd : '%d ',
	            M : '1 ',
	            MM : '%d ',
	            y : '1 ',
	            yy : '%d '
	        },
	        week : {
	            // GB/T 7408-1994ISO 8601:1988
	            dow : 1, // Monday is the first day of the week.
	            doy : 4  // The week that contains Jan 4th is the first week of the year.
	        }
	    });

	    return zh_cn;

	}));

/***/ },
/* 142 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : traditional chinese (zh-tw)
	//! author : Ben : https://github.com/ben-lin

	(function (global, factory) {
	    true ? factory(__webpack_require__(56)) :
	   typeof define === 'function' && define.amd ? define(['moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';


	    var zh_tw = moment.defineLocale('zh-tw', {
	        months : '___________'.split('_'),
	        monthsShort : '1_2_3_4_5_6_7_8_9_10_11_12'.split('_'),
	        weekdays : '______'.split('_'),
	        weekdaysShort : '______'.split('_'),
	        weekdaysMin : '______'.split('_'),
	        longDateFormat : {
	            LT : 'Ahmm',
	            LTS : 'Ahms',
	            L : 'YYYYMMMD',
	            LL : 'YYYYMMMD',
	            LLL : 'YYYYMMMDAhmm',
	            LLLL : 'YYYYMMMDddddAhmm',
	            l : 'YYYYMMMD',
	            ll : 'YYYYMMMD',
	            lll : 'YYYYMMMDAhmm',
	            llll : 'YYYYMMMDddddAhmm'
	        },
	        meridiemParse: /||||/,
	        meridiemHour : function (hour, meridiem) {
	            if (hour === 12) {
	                hour = 0;
	            }
	            if (meridiem === '' || meridiem === '') {
	                return hour;
	            } else if (meridiem === '') {
	                return hour >= 11 ? hour : hour + 12;
	            } else if (meridiem === '' || meridiem === '') {
	                return hour + 12;
	            }
	        },
	        meridiem : function (hour, minute, isLower) {
	            var hm = hour * 100 + minute;
	            if (hm < 900) {
	                return '';
	            } else if (hm < 1130) {
	                return '';
	            } else if (hm < 1230) {
	                return '';
	            } else if (hm < 1800) {
	                return '';
	            } else {
	                return '';
	            }
	        },
	        calendar : {
	            sameDay : '[]LT',
	            nextDay : '[]LT',
	            nextWeek : '[]ddddLT',
	            lastDay : '[]LT',
	            lastWeek : '[]ddddLT',
	            sameElse : 'L'
	        },
	        ordinalParse: /\d{1,2}(||)/,
	        ordinal : function (number, period) {
	            switch (period) {
	            case 'd' :
	            case 'D' :
	            case 'DDD' :
	                return number + '';
	            case 'M' :
	                return number + '';
	            case 'w' :
	            case 'W' :
	                return number + '';
	            default :
	                return number;
	            }
	        },
	        relativeTime : {
	            future : '%s',
	            past : '%s',
	            s : '',
	            m : '',
	            mm : '%d',
	            h : '',
	            hh : '%d',
	            d : '',
	            dd : '%d',
	            M : '',
	            MM : '%d',
	            y : '',
	            yy : '%d'
	        }
	    });

	    return zh_tw;

	}));

/***/ },
/* 143 */
/***/ function(module, exports, __webpack_require__) {

	var _ = __webpack_require__(144);

	var Vindication = {
		requiredFn: function( object, cvalue ) {
			return !cvalue || object;
		},
		minlengthFn: function( object, cvalue ) {
			return object && object.length >= cvalue;
		},
		maxlengthFn: function( object, cvalue ) {
			return !object || object.length <= cvalue;
		},
		lengthFn: function( object, cvalue ) {
			if( _.isString(cvalue) ){ cvalue = JSON.parse( cvalue ); }
			return this.minlengthFn( object, cvalue[ 0 ] ) && this.maxlengthFn( object, cvalue[ 1 ] );
		},
		elementFn: function( object, cvalue ) {
			return Array.isArray(cvalue) && cvalue.indexOf( object ) !== -1;
		},
		minFn: function( object, cvalue ) {
			return object && Number( object ) >= cvalue;
		},
		maxFn: function( object, cvalue ) {
			return object && Number( object ) <= cvalue;
		},
		rangeFn: function( object, cvalue ) {
			return object && object >= cvalue[ 0 ] && object <= cvalue[ 1 ];
		},
		patternFn: function( object, cvalue ) {
			return new RegExp( cvalue ).test( object );
		},
		equaltoFn: function( object, cvalue ) {
			return object === cvalue;
		},
		notblank: function( object, cvalue ) {
			return !cvalue || this.minlengthFn( object, 1 );
		},
		beforeFn: function( object, cvalue ) {
			return this.maxFn( object.getTime ? object.getTime() : object, cvalue.getTime ? cvalue.getTime() : cvalue );
		},
		afterFn: function( object, cvalue ) {
			return this.minFn( object.getTime ? object.getTime() : object, cvalue.getTime ? cvalue.getTime() : cvalue );
		},
		typeFn: function( object, cvalue ) {
			var regExp;

			switch ( cvalue ) {
				case 'number':
					regExp = /^-?(?:\d+|\d{1,3}(?:,\d{3})+)?(?:\.\d+)?$/;
					break;
				case 'digits':
					regExp = /^\d+$/;
					break;
				case 'integer':
					regExp = /^-?\d+$/;
					break;
				case 'alphanum':
					regExp = /^\w+$/;
					break;
				case 'email':
					regExp = /^((([a-z]|\d|[!#\$%&'\*\+\-\/=\?\^_`{\|}~]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])+(\.([a-z]|\d|[!#\$%&'\*\+\-\/=\?\^_`{\|}~]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])+)*)|((\x22)((((\x20|\x09)*(\x0d\x0a))?(\x20|\x09)+)?(([\x01-\x08\x0b\x0c\x0e-\x1f\x7f]|\x21|[\x23-\x5b]|[\x5d-\x7e]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(\\([\x01-\x09\x0b\x0c\x0d-\x7f]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]))))*(((\x20|\x09)*(\x0d\x0a))?(\x20|\x09)+)?(\x22)))@((([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))\.)+(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))$/i;
					break;
				case 'url':
					regExp = new RegExp('(https?:\\/\\/)?(www\\.)?[-a-zA-Z0-9@:%._\\+~#=]{2,256}\\.[a-z]{2,4}\\b([-a-zA-Z0-9@:%_\\+.~#?&//=]*)', 'i');
					break;
				case 'dateIso':
					regExp = /^(\d{4})\D?(0[1-9]|1[0-2])\D?([12]\d|0[1-9]|3[01])$/;
					break;
				case 'phone':
					regExp = /^((\+\d{1,3}(-| )?\(?\d\)?(-| )?\d{1,5})|(\(?\d{2,6}\)?))(-| )?(\d{3,4})(-| )?(\d{4})(( x| ext)\d{1,5}){0,1}$/;
					break;
				default:
					return false;
			}

			return object ? regExp.test( object ) : false;
		},

		checkConstraints: function( root, object, constraints, context ) {
			var self = this;
			if( _.isFunction( constraints ) ){
				if( !constraints.call( context, object ) )
					return 'This value seems to be invalid:' + ' ' + object;
			}
			else for (var key in constraints){
				if( key !== 'message' ){
					var constraint = constraints[key];
					if( constraint.params && constraint.condition ){
						/*city: { equalto: {
							params: "Monaco", condition: function(viewModel){ return viewModel.address.country() === 'France'; }
						} },*/
						if( constraint.condition( root ) ){
							var cresp = self[ key + 'Fn' ](object, constraint.params) ? null : (constraints.message || 'This value seems to be invalid:') + ' ' + object;
							if( cresp )
								return cresp;
						}
					}
					else{
						var resp = self[ key + 'Fn' ](object, constraint) ? null : (constraints.message || 'This value seems to be invalid:') + ' ' + object;
						if( resp )
							return resp;
					}
				}
			}
		},
		walk: function( root, object, constraints, context ) {
			var self = this, res;
			if ( _.isString( object ) ){
				return self.checkConstraints( root, object, constraints, context );
			}
			else if ( _.isBoolean( object ) ){
				return self.checkConstraints( root, object, constraints, context );
			}
			else if ( _.isNumber( object ) ){
				return self.checkConstraints( root, object, constraints, context );
			}
			else if ( _.isDate( object ) ){
				return self.checkConstraints( root, object, constraints, context );
			}
			else if ( _.isRegExp( object ) ){
				return null;
			}
			else if ( Array.isArray( object ) ){
				res = [];
				object.forEach(function(element){
					var result = self.walk( root, element, constraints, context );
					if( result )
						res.push( result );
				});
				return res.length === 0 ? null : res;
			}
			else if ( _.isFunction( object ) ){
				return self.checkConstraints( root, object.call( context ), constraints, context );
			}
			else if ( _.isObject( object ) ){
				if( _.isFunction( constraints ) ){
					return self.checkConstraints( root, object, constraints, context );
				}
				else{
					res = {};
					for(var key in object){
						if( key && constraints[key] ){
							var n = object[key];
							var result = self.walk( root, n, constraints[key], context );
							if( result )
								res[key] = result;
						}
					}
					return Object.keys(res).length === 0 ? null : res;
				}
			}
			return null;
		}
	};

	module.exports = {
		version: '3.0.2',
		validate: function(object, constraints, context) {
			return Vindication.walk( object, object, constraints || {}, context || object );
		},
		validateAll: function(objects, constraints, context) {
			if( !Array.isArray( objects ) ) return this.validate( objects, constraints, context );
			var res = [];
			objects.forEach(function(object){
				res.push( Vindication.walk( object, object, constraints || {}, context || object ) );
			});
			return res;
		}
	};


/***/ },
/* 144 */
/***/ function(module, exports) {

	var arrayTag = '[object Array]',
		boolTag = '[object Boolean]',
		dateTag = '[object Date]',
		errorTag = '[object Error]',
		funcTag = '[object Function]',
		numberTag = '[object Number]',
		objectTag = '[object Object]',
		regexpTag = '[object RegExp]',
		stringTag = '[object String]';

	var arrayProto = Array.prototype,
		objectProto = Object.prototype,
		stringProto = String.prototype;

	var objToString = objectProto.toString;
	var fnToString = Function.prototype.toString;
	var objCtorString = fnToString.call(Object);

	module.exports = {
		getPrototypeOf: Object.getPrototypeOf,
		isHostObject: function(value) {
			var result = false;
			if (value !== null && typeof value.toString != 'function') {
				try {
					result = !!(value + '');
				} catch (e) {}
			}
			return result;
		},
		isPlainObject: function(value) {
			if (!this.isObjectLike(value) || objToString.call(value) != objectTag || this.isHostObject(value)) {
				return false;
			}
			var proto = typeof value.constructor == 'function' ? this.getPrototypeOf(value) : objectProto;

			if (proto === null) {
				return true;
			}
			var Ctor = proto.constructor;
			return (typeof Ctor == 'function' && Ctor instanceof Ctor && fnToString.call(Ctor) == objCtorString);
		},
		isObjectLike: function(value) {
			return !!value && typeof value == 'object';
		},
		isArray: Array.isArray,
		isObject: function(value) {
			var type = typeof value;
			return !!value && (type == 'object' || type == 'function');
		},
		isError: function(value) {
			return this.isObjectLike(value) && typeof value.message == 'string' && objToString.call(value) == errorTag;
		},
		isNumber: function(value) {
			return typeof value == 'number' || (this.isObjectLike(value) && objToString.call(value) == numberTag);
		},
		isDate: function(value) {
			return this.isObjectLike(value) && objToString.call(value) == dateTag;
		},
		isFunction: function(value) {
			return this.isObject(value) && objToString.call(value) == funcTag;
		},
		isBoolean: function(value) {
			return value === true || value === false || (this.isObjectLike(value) && objToString.call(value) == boolTag);
		},
		isString: function(value) {
			return typeof value == 'string' || ( this.isObjectLike(value) && objToString.call(value) == stringTag);
		},
		isRegExp: function(value) {
			return this.isObject(value) && objToString.call(value) == regexpTag;
		}
	};


/***/ },
/* 145 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*! Hammer.JS - v2.0.4 - 2014-09-28
	 * http://hammerjs.github.io/
	 *
	 * Copyright (c) 2014 Jorik Tangelder;
	 * Licensed under the MIT license */
	(function(window, document, exportName, undefined) {
	  'use strict';

	var VENDOR_PREFIXES = ['', 'webkit', 'moz', 'MS', 'ms', 'o'];
	var TEST_ELEMENT = document.createElement('div');

	var TYPE_FUNCTION = 'function';

	var round = Math.round;
	var abs = Math.abs;
	var now = Date.now;

	/**
	 * set a timeout with a given scope
	 * @param {Function} fn
	 * @param {Number} timeout
	 * @param {Object} context
	 * @returns {number}
	 */
	function setTimeoutContext(fn, timeout, context) {
	    return setTimeout(bindFn(fn, context), timeout);
	}

	/**
	 * if the argument is an array, we want to execute the fn on each entry
	 * if it aint an array we don't want to do a thing.
	 * this is used by all the methods that accept a single and array argument.
	 * @param {*|Array} arg
	 * @param {String} fn
	 * @param {Object} [context]
	 * @returns {Boolean}
	 */
	function invokeArrayArg(arg, fn, context) {
	    if (Array.isArray(arg)) {
	        each(arg, context[fn], context);
	        return true;
	    }
	    return false;
	}

	/**
	 * walk objects and arrays
	 * @param {Object} obj
	 * @param {Function} iterator
	 * @param {Object} context
	 */
	function each(obj, iterator, context) {
	    var i;

	    if (!obj) {
	        return;
	    }

	    if (obj.forEach) {
	        obj.forEach(iterator, context);
	    } else if (obj.length !== undefined) {
	        i = 0;
	        while (i < obj.length) {
	            iterator.call(context, obj[i], i, obj);
	            i++;
	        }
	    } else {
	        for (i in obj) {
	            obj.hasOwnProperty(i) && iterator.call(context, obj[i], i, obj);
	        }
	    }
	}

	/**
	 * extend object.
	 * means that properties in dest will be overwritten by the ones in src.
	 * @param {Object} dest
	 * @param {Object} src
	 * @param {Boolean} [merge]
	 * @returns {Object} dest
	 */
	function extend(dest, src, merge) {
	    var keys = Object.keys(src);
	    var i = 0;
	    while (i < keys.length) {
	        if (!merge || (merge && dest[keys[i]] === undefined)) {
	            dest[keys[i]] = src[keys[i]];
	        }
	        i++;
	    }
	    return dest;
	}

	/**
	 * merge the values from src in the dest.
	 * means that properties that exist in dest will not be overwritten by src
	 * @param {Object} dest
	 * @param {Object} src
	 * @returns {Object} dest
	 */
	function merge(dest, src) {
	    return extend(dest, src, true);
	}

	/**
	 * simple class inheritance
	 * @param {Function} child
	 * @param {Function} base
	 * @param {Object} [properties]
	 */
	function inherit(child, base, properties) {
	    var baseP = base.prototype,
	        childP;

	    childP = child.prototype = Object.create(baseP);
	    childP.constructor = child;
	    childP._super = baseP;

	    if (properties) {
	        extend(childP, properties);
	    }
	}

	/**
	 * simple function bind
	 * @param {Function} fn
	 * @param {Object} context
	 * @returns {Function}
	 */
	function bindFn(fn, context) {
	    return function boundFn() {
	        return fn.apply(context, arguments);
	    };
	}

	/**
	 * let a boolean value also be a function that must return a boolean
	 * this first item in args will be used as the context
	 * @param {Boolean|Function} val
	 * @param {Array} [args]
	 * @returns {Boolean}
	 */
	function boolOrFn(val, args) {
	    if (typeof val == TYPE_FUNCTION) {
	        return val.apply(args ? args[0] || undefined : undefined, args);
	    }
	    return val;
	}

	/**
	 * use the val2 when val1 is undefined
	 * @param {*} val1
	 * @param {*} val2
	 * @returns {*}
	 */
	function ifUndefined(val1, val2) {
	    return (val1 === undefined) ? val2 : val1;
	}

	/**
	 * addEventListener with multiple events at once
	 * @param {EventTarget} target
	 * @param {String} types
	 * @param {Function} handler
	 */
	function addEventListeners(target, types, handler) {
	    each(splitStr(types), function(type) {
	        target.addEventListener(type, handler, false);
	    });
	}

	/**
	 * removeEventListener with multiple events at once
	 * @param {EventTarget} target
	 * @param {String} types
	 * @param {Function} handler
	 */
	function removeEventListeners(target, types, handler) {
	    each(splitStr(types), function(type) {
	        target.removeEventListener(type, handler, false);
	    });
	}

	/**
	 * find if a node is in the given parent
	 * @method hasParent
	 * @param {HTMLElement} node
	 * @param {HTMLElement} parent
	 * @return {Boolean} found
	 */
	function hasParent(node, parent) {
	    while (node) {
	        if (node == parent) {
	            return true;
	        }
	        node = node.parentNode;
	    }
	    return false;
	}

	/**
	 * small indexOf wrapper
	 * @param {String} str
	 * @param {String} find
	 * @returns {Boolean} found
	 */
	function inStr(str, find) {
	    return str.indexOf(find) > -1;
	}

	/**
	 * split string on whitespace
	 * @param {String} str
	 * @returns {Array} words
	 */
	function splitStr(str) {
	    return str.trim().split(/\s+/g);
	}

	/**
	 * find if a array contains the object using indexOf or a simple polyFill
	 * @param {Array} src
	 * @param {String} find
	 * @param {String} [findByKey]
	 * @return {Boolean|Number} false when not found, or the index
	 */
	function inArray(src, find, findByKey) {
	    if (src.indexOf && !findByKey) {
	        return src.indexOf(find);
	    } else {
	        var i = 0;
	        while (i < src.length) {
	            if ((findByKey && src[i][findByKey] == find) || (!findByKey && src[i] === find)) {
	                return i;
	            }
	            i++;
	        }
	        return -1;
	    }
	}

	/**
	 * convert array-like objects to real arrays
	 * @param {Object} obj
	 * @returns {Array}
	 */
	function toArray(obj) {
	    return Array.prototype.slice.call(obj, 0);
	}

	/**
	 * unique array with objects based on a key (like 'id') or just by the array's value
	 * @param {Array} src [{id:1},{id:2},{id:1}]
	 * @param {String} [key]
	 * @param {Boolean} [sort=False]
	 * @returns {Array} [{id:1},{id:2}]
	 */
	function uniqueArray(src, key, sort) {
	    var results = [];
	    var values = [];
	    var i = 0;

	    while (i < src.length) {
	        var val = key ? src[i][key] : src[i];
	        if (inArray(values, val) < 0) {
	            results.push(src[i]);
	        }
	        values[i] = val;
	        i++;
	    }

	    if (sort) {
	        if (!key) {
	            results = results.sort();
	        } else {
	            results = results.sort(function sortUniqueArray(a, b) {
	                return a[key] > b[key];
	            });
	        }
	    }

	    return results;
	}

	/**
	 * get the prefixed property
	 * @param {Object} obj
	 * @param {String} property
	 * @returns {String|Undefined} prefixed
	 */
	function prefixed(obj, property) {
	    var prefix, prop;
	    var camelProp = property[0].toUpperCase() + property.slice(1);

	    var i = 0;
	    while (i < VENDOR_PREFIXES.length) {
	        prefix = VENDOR_PREFIXES[i];
	        prop = (prefix) ? prefix + camelProp : property;

	        if (prop in obj) {
	            return prop;
	        }
	        i++;
	    }
	    return undefined;
	}

	/**
	 * get a unique id
	 * @returns {number} uniqueId
	 */
	var _uniqueId = 1;
	function uniqueId() {
	    return _uniqueId++;
	}

	/**
	 * get the window object of an element
	 * @param {HTMLElement} element
	 * @returns {DocumentView|Window}
	 */
	function getWindowForElement(element) {
	    var doc = element.ownerDocument;
	    return (doc.defaultView || doc.parentWindow);
	}

	var MOBILE_REGEX = /mobile|tablet|ip(ad|hone|od)|android/i;

	var SUPPORT_TOUCH = ('ontouchstart' in window);
	var SUPPORT_POINTER_EVENTS = prefixed(window, 'PointerEvent') !== undefined;
	var SUPPORT_ONLY_TOUCH = SUPPORT_TOUCH && MOBILE_REGEX.test(navigator.userAgent);

	var INPUT_TYPE_TOUCH = 'touch';
	var INPUT_TYPE_PEN = 'pen';
	var INPUT_TYPE_MOUSE = 'mouse';
	var INPUT_TYPE_KINECT = 'kinect';

	var COMPUTE_INTERVAL = 25;

	var INPUT_START = 1;
	var INPUT_MOVE = 2;
	var INPUT_END = 4;
	var INPUT_CANCEL = 8;

	var DIRECTION_NONE = 1;
	var DIRECTION_LEFT = 2;
	var DIRECTION_RIGHT = 4;
	var DIRECTION_UP = 8;
	var DIRECTION_DOWN = 16;

	var DIRECTION_HORIZONTAL = DIRECTION_LEFT | DIRECTION_RIGHT;
	var DIRECTION_VERTICAL = DIRECTION_UP | DIRECTION_DOWN;
	var DIRECTION_ALL = DIRECTION_HORIZONTAL | DIRECTION_VERTICAL;

	var PROPS_XY = ['x', 'y'];
	var PROPS_CLIENT_XY = ['clientX', 'clientY'];

	/**
	 * create new input type manager
	 * @param {Manager} manager
	 * @param {Function} callback
	 * @returns {Input}
	 * @constructor
	 */
	function Input(manager, callback) {
	    var self = this;
	    this.manager = manager;
	    this.callback = callback;
	    this.element = manager.element;
	    this.target = manager.options.inputTarget;

	    // smaller wrapper around the handler, for the scope and the enabled state of the manager,
	    // so when disabled the input events are completely bypassed.
	    this.domHandler = function(ev) {
	        if (boolOrFn(manager.options.enable, [manager])) {
	            self.handler(ev);
	        }
	    };

	    this.init();

	}

	Input.prototype = {
	    /**
	     * should handle the inputEvent data and trigger the callback
	     * @virtual
	     */
	    handler: function() { },

	    /**
	     * bind the events
	     */
	    init: function() {
	        this.evEl && addEventListeners(this.element, this.evEl, this.domHandler);
	        this.evTarget && addEventListeners(this.target, this.evTarget, this.domHandler);
	        this.evWin && addEventListeners(getWindowForElement(this.element), this.evWin, this.domHandler);
	    },

	    /**
	     * unbind the events
	     */
	    destroy: function() {
	        this.evEl && removeEventListeners(this.element, this.evEl, this.domHandler);
	        this.evTarget && removeEventListeners(this.target, this.evTarget, this.domHandler);
	        this.evWin && removeEventListeners(getWindowForElement(this.element), this.evWin, this.domHandler);
	    }
	};

	/**
	 * create new input type manager
	 * called by the Manager constructor
	 * @param {Hammer} manager
	 * @returns {Input}
	 */
	function createInputInstance(manager) {
	    var Type;
	    var inputClass = manager.options.inputClass;

	    if (inputClass) {
	        Type = inputClass;
	    } else if (SUPPORT_POINTER_EVENTS) {
	        Type = PointerEventInput;
	    } else if (SUPPORT_ONLY_TOUCH) {
	        Type = TouchInput;
	    } else if (!SUPPORT_TOUCH) {
	        Type = MouseInput;
	    } else {
	        Type = TouchMouseInput;
	    }
	    return new (Type)(manager, inputHandler);
	}

	/**
	 * handle input events
	 * @param {Manager} manager
	 * @param {String} eventType
	 * @param {Object} input
	 */
	function inputHandler(manager, eventType, input) {
	    var pointersLen = input.pointers.length;
	    var changedPointersLen = input.changedPointers.length;
	    var isFirst = (eventType & INPUT_START && (pointersLen - changedPointersLen === 0));
	    var isFinal = (eventType & (INPUT_END | INPUT_CANCEL) && (pointersLen - changedPointersLen === 0));

	    input.isFirst = !!isFirst;
	    input.isFinal = !!isFinal;

	    if (isFirst) {
	        manager.session = {};
	    }

	    // source event is the normalized value of the domEvents
	    // like 'touchstart, mouseup, pointerdown'
	    input.eventType = eventType;

	    // compute scale, rotation etc
	    computeInputData(manager, input);

	    // emit secret event
	    manager.emit('hammer.input', input);

	    manager.recognize(input);
	    manager.session.prevInput = input;
	}

	/**
	 * extend the data with some usable properties like scale, rotate, velocity etc
	 * @param {Object} manager
	 * @param {Object} input
	 */
	function computeInputData(manager, input) {
	    var session = manager.session;
	    var pointers = input.pointers;
	    var pointersLength = pointers.length;

	    // store the first input to calculate the distance and direction
	    if (!session.firstInput) {
	        session.firstInput = simpleCloneInputData(input);
	    }

	    // to compute scale and rotation we need to store the multiple touches
	    if (pointersLength > 1 && !session.firstMultiple) {
	        session.firstMultiple = simpleCloneInputData(input);
	    } else if (pointersLength === 1) {
	        session.firstMultiple = false;
	    }

	    var firstInput = session.firstInput;
	    var firstMultiple = session.firstMultiple;
	    var offsetCenter = firstMultiple ? firstMultiple.center : firstInput.center;

	    var center = input.center = getCenter(pointers);
	    input.timeStamp = now();
	    input.deltaTime = input.timeStamp - firstInput.timeStamp;

	    input.angle = getAngle(offsetCenter, center);
	    input.distance = getDistance(offsetCenter, center);

	    computeDeltaXY(session, input);
	    input.offsetDirection = getDirection(input.deltaX, input.deltaY);

	    input.scale = firstMultiple ? getScale(firstMultiple.pointers, pointers) : 1;
	    input.rotation = firstMultiple ? getRotation(firstMultiple.pointers, pointers) : 0;

	    computeIntervalInputData(session, input);

	    // find the correct target
	    var target = manager.element;
	    if (hasParent(input.srcEvent.target, target)) {
	        target = input.srcEvent.target;
	    }
	    input.target = target;
	}

	function computeDeltaXY(session, input) {
	    var center = input.center;
	    var offset = session.offsetDelta || {};
	    var prevDelta = session.prevDelta || {};
	    var prevInput = session.prevInput || {};

	    if (input.eventType === INPUT_START || prevInput.eventType === INPUT_END) {
	        prevDelta = session.prevDelta = {
	            x: prevInput.deltaX || 0,
	            y: prevInput.deltaY || 0
	        };

	        offset = session.offsetDelta = {
	            x: center.x,
	            y: center.y
	        };
	    }

	    input.deltaX = prevDelta.x + (center.x - offset.x);
	    input.deltaY = prevDelta.y + (center.y - offset.y);
	}

	/**
	 * velocity is calculated every x ms
	 * @param {Object} session
	 * @param {Object} input
	 */
	function computeIntervalInputData(session, input) {
	    var last = session.lastInterval || input,
	        deltaTime = input.timeStamp - last.timeStamp,
	        velocity, velocityX, velocityY, direction;

	    if (input.eventType != INPUT_CANCEL && (deltaTime > COMPUTE_INTERVAL || last.velocity === undefined)) {
	        var deltaX = last.deltaX - input.deltaX;
	        var deltaY = last.deltaY - input.deltaY;

	        var v = getVelocity(deltaTime, deltaX, deltaY);
	        velocityX = v.x;
	        velocityY = v.y;
	        velocity = (abs(v.x) > abs(v.y)) ? v.x : v.y;
	        direction = getDirection(deltaX, deltaY);

	        session.lastInterval = input;
	    } else {
	        // use latest velocity info if it doesn't overtake a minimum period
	        velocity = last.velocity;
	        velocityX = last.velocityX;
	        velocityY = last.velocityY;
	        direction = last.direction;
	    }

	    input.velocity = velocity;
	    input.velocityX = velocityX;
	    input.velocityY = velocityY;
	    input.direction = direction;
	}

	/**
	 * create a simple clone from the input used for storage of firstInput and firstMultiple
	 * @param {Object} input
	 * @returns {Object} clonedInputData
	 */
	function simpleCloneInputData(input) {
	    // make a simple copy of the pointers because we will get a reference if we don't
	    // we only need clientXY for the calculations
	    var pointers = [];
	    var i = 0;
	    while (i < input.pointers.length) {
	        pointers[i] = {
	            clientX: round(input.pointers[i].clientX),
	            clientY: round(input.pointers[i].clientY)
	        };
	        i++;
	    }

	    return {
	        timeStamp: now(),
	        pointers: pointers,
	        center: getCenter(pointers),
	        deltaX: input.deltaX,
	        deltaY: input.deltaY
	    };
	}

	/**
	 * get the center of all the pointers
	 * @param {Array} pointers
	 * @return {Object} center contains `x` and `y` properties
	 */
	function getCenter(pointers) {
	    var pointersLength = pointers.length;

	    // no need to loop when only one touch
	    if (pointersLength === 1) {
	        return {
	            x: round(pointers[0].clientX),
	            y: round(pointers[0].clientY)
	        };
	    }

	    var x = 0, y = 0, i = 0;
	    while (i < pointersLength) {
	        x += pointers[i].clientX;
	        y += pointers[i].clientY;
	        i++;
	    }

	    return {
	        x: round(x / pointersLength),
	        y: round(y / pointersLength)
	    };
	}

	/**
	 * calculate the velocity between two points. unit is in px per ms.
	 * @param {Number} deltaTime
	 * @param {Number} x
	 * @param {Number} y
	 * @return {Object} velocity `x` and `y`
	 */
	function getVelocity(deltaTime, x, y) {
	    return {
	        x: x / deltaTime || 0,
	        y: y / deltaTime || 0
	    };
	}

	/**
	 * get the direction between two points
	 * @param {Number} x
	 * @param {Number} y
	 * @return {Number} direction
	 */
	function getDirection(x, y) {
	    if (x === y) {
	        return DIRECTION_NONE;
	    }

	    if (abs(x) >= abs(y)) {
	        return x > 0 ? DIRECTION_LEFT : DIRECTION_RIGHT;
	    }
	    return y > 0 ? DIRECTION_UP : DIRECTION_DOWN;
	}

	/**
	 * calculate the absolute distance between two points
	 * @param {Object} p1 {x, y}
	 * @param {Object} p2 {x, y}
	 * @param {Array} [props] containing x and y keys
	 * @return {Number} distance
	 */
	function getDistance(p1, p2, props) {
	    if (!props) {
	        props = PROPS_XY;
	    }
	    var x = p2[props[0]] - p1[props[0]],
	        y = p2[props[1]] - p1[props[1]];

	    return Math.sqrt((x * x) + (y * y));
	}

	/**
	 * calculate the angle between two coordinates
	 * @param {Object} p1
	 * @param {Object} p2
	 * @param {Array} [props] containing x and y keys
	 * @return {Number} angle
	 */
	function getAngle(p1, p2, props) {
	    if (!props) {
	        props = PROPS_XY;
	    }
	    var x = p2[props[0]] - p1[props[0]],
	        y = p2[props[1]] - p1[props[1]];
	    return Math.atan2(y, x) * 180 / Math.PI;
	}

	/**
	 * calculate the rotation degrees between two pointersets
	 * @param {Array} start array of pointers
	 * @param {Array} end array of pointers
	 * @return {Number} rotation
	 */
	function getRotation(start, end) {
	    return getAngle(end[1], end[0], PROPS_CLIENT_XY) - getAngle(start[1], start[0], PROPS_CLIENT_XY);
	}

	/**
	 * calculate the scale factor between two pointersets
	 * no scale is 1, and goes down to 0 when pinched together, and bigger when pinched out
	 * @param {Array} start array of pointers
	 * @param {Array} end array of pointers
	 * @return {Number} scale
	 */
	function getScale(start, end) {
	    return getDistance(end[0], end[1], PROPS_CLIENT_XY) / getDistance(start[0], start[1], PROPS_CLIENT_XY);
	}

	var MOUSE_INPUT_MAP = {
	    mousedown: INPUT_START,
	    mousemove: INPUT_MOVE,
	    mouseup: INPUT_END
	};

	var MOUSE_ELEMENT_EVENTS = 'mousedown';
	var MOUSE_WINDOW_EVENTS = 'mousemove mouseup';

	/**
	 * Mouse events input
	 * @constructor
	 * @extends Input
	 */
	function MouseInput() {
	    this.evEl = MOUSE_ELEMENT_EVENTS;
	    this.evWin = MOUSE_WINDOW_EVENTS;

	    this.allow = true; // used by Input.TouchMouse to disable mouse events
	    this.pressed = false; // mousedown state

	    Input.apply(this, arguments);
	}

	inherit(MouseInput, Input, {
	    /**
	     * handle mouse events
	     * @param {Object} ev
	     */
	    handler: function MEhandler(ev) {
	        var eventType = MOUSE_INPUT_MAP[ev.type];

	        // on start we want to have the left mouse button down
	        if (eventType & INPUT_START && ev.button === 0) {
	            this.pressed = true;
	        }

	        if (eventType & INPUT_MOVE && ev.which !== 1) {
	            eventType = INPUT_END;
	        }

	        // mouse must be down, and mouse events are allowed (see the TouchMouse input)
	        if (!this.pressed || !this.allow) {
	            return;
	        }

	        if (eventType & INPUT_END) {
	            this.pressed = false;
	        }

	        this.callback(this.manager, eventType, {
	            pointers: [ev],
	            changedPointers: [ev],
	            pointerType: INPUT_TYPE_MOUSE,
	            srcEvent: ev
	        });
	    }
	});

	var POINTER_INPUT_MAP = {
	    pointerdown: INPUT_START,
	    pointermove: INPUT_MOVE,
	    pointerup: INPUT_END,
	    pointercancel: INPUT_CANCEL,
	    pointerout: INPUT_CANCEL
	};

	// in IE10 the pointer types is defined as an enum
	var IE10_POINTER_TYPE_ENUM = {
	    2: INPUT_TYPE_TOUCH,
	    3: INPUT_TYPE_PEN,
	    4: INPUT_TYPE_MOUSE,
	    5: INPUT_TYPE_KINECT // see https://twitter.com/jacobrossi/status/480596438489890816
	};

	var POINTER_ELEMENT_EVENTS = 'pointerdown';
	var POINTER_WINDOW_EVENTS = 'pointermove pointerup pointercancel';

	// IE10 has prefixed support, and case-sensitive
	if (window.MSPointerEvent) {
	    POINTER_ELEMENT_EVENTS = 'MSPointerDown';
	    POINTER_WINDOW_EVENTS = 'MSPointerMove MSPointerUp MSPointerCancel';
	}

	/**
	 * Pointer events input
	 * @constructor
	 * @extends Input
	 */
	function PointerEventInput() {
	    this.evEl = POINTER_ELEMENT_EVENTS;
	    this.evWin = POINTER_WINDOW_EVENTS;

	    Input.apply(this, arguments);

	    this.store = (this.manager.session.pointerEvents = []);
	}

	inherit(PointerEventInput, Input, {
	    /**
	     * handle mouse events
	     * @param {Object} ev
	     */
	    handler: function PEhandler(ev) {
	        var store = this.store;
	        var removePointer = false;

	        var eventTypeNormalized = ev.type.toLowerCase().replace('ms', '');
	        var eventType = POINTER_INPUT_MAP[eventTypeNormalized];
	        var pointerType = IE10_POINTER_TYPE_ENUM[ev.pointerType] || ev.pointerType;

	        var isTouch = (pointerType == INPUT_TYPE_TOUCH);

	        // get index of the event in the store
	        var storeIndex = inArray(store, ev.pointerId, 'pointerId');

	        // start and mouse must be down
	        if (eventType & INPUT_START && (ev.button === 0 || isTouch)) {
	            if (storeIndex < 0) {
	                store.push(ev);
	                storeIndex = store.length - 1;
	            }
	        } else if (eventType & (INPUT_END | INPUT_CANCEL)) {
	            removePointer = true;
	        }

	        // it not found, so the pointer hasn't been down (so it's probably a hover)
	        if (storeIndex < 0) {
	            return;
	        }

	        // update the event in the store
	        store[storeIndex] = ev;

	        this.callback(this.manager, eventType, {
	            pointers: store,
	            changedPointers: [ev],
	            pointerType: pointerType,
	            srcEvent: ev
	        });

	        if (removePointer) {
	            // remove from the store
	            store.splice(storeIndex, 1);
	        }
	    }
	});

	var SINGLE_TOUCH_INPUT_MAP = {
	    touchstart: INPUT_START,
	    touchmove: INPUT_MOVE,
	    touchend: INPUT_END,
	    touchcancel: INPUT_CANCEL
	};

	var SINGLE_TOUCH_TARGET_EVENTS = 'touchstart';
	var SINGLE_TOUCH_WINDOW_EVENTS = 'touchstart touchmove touchend touchcancel';

	/**
	 * Touch events input
	 * @constructor
	 * @extends Input
	 */
	function SingleTouchInput() {
	    this.evTarget = SINGLE_TOUCH_TARGET_EVENTS;
	    this.evWin = SINGLE_TOUCH_WINDOW_EVENTS;
	    this.started = false;

	    Input.apply(this, arguments);
	}

	inherit(SingleTouchInput, Input, {
	    handler: function TEhandler(ev) {
	        var type = SINGLE_TOUCH_INPUT_MAP[ev.type];

	        // should we handle the touch events?
	        if (type === INPUT_START) {
	            this.started = true;
	        }

	        if (!this.started) {
	            return;
	        }

	        var touches = normalizeSingleTouches.call(this, ev, type);

	        // when done, reset the started state
	        if (type & (INPUT_END | INPUT_CANCEL) && touches[0].length - touches[1].length === 0) {
	            this.started = false;
	        }

	        this.callback(this.manager, type, {
	            pointers: touches[0],
	            changedPointers: touches[1],
	            pointerType: INPUT_TYPE_TOUCH,
	            srcEvent: ev
	        });
	    }
	});

	/**
	 * @this {TouchInput}
	 * @param {Object} ev
	 * @param {Number} type flag
	 * @returns {undefined|Array} [all, changed]
	 */
	function normalizeSingleTouches(ev, type) {
	    var all = toArray(ev.touches);
	    var changed = toArray(ev.changedTouches);

	    if (type & (INPUT_END | INPUT_CANCEL)) {
	        all = uniqueArray(all.concat(changed), 'identifier', true);
	    }

	    return [all, changed];
	}

	var TOUCH_INPUT_MAP = {
	    touchstart: INPUT_START,
	    touchmove: INPUT_MOVE,
	    touchend: INPUT_END,
	    touchcancel: INPUT_CANCEL
	};

	var TOUCH_TARGET_EVENTS = 'touchstart touchmove touchend touchcancel';

	/**
	 * Multi-user touch events input
	 * @constructor
	 * @extends Input
	 */
	function TouchInput() {
	    this.evTarget = TOUCH_TARGET_EVENTS;
	    this.targetIds = {};

	    Input.apply(this, arguments);
	}

	inherit(TouchInput, Input, {
	    handler: function MTEhandler(ev) {
	        var type = TOUCH_INPUT_MAP[ev.type];
	        var touches = getTouches.call(this, ev, type);
	        if (!touches) {
	            return;
	        }

	        this.callback(this.manager, type, {
	            pointers: touches[0],
	            changedPointers: touches[1],
	            pointerType: INPUT_TYPE_TOUCH,
	            srcEvent: ev
	        });
	    }
	});

	/**
	 * @this {TouchInput}
	 * @param {Object} ev
	 * @param {Number} type flag
	 * @returns {undefined|Array} [all, changed]
	 */
	function getTouches(ev, type) {
	    var allTouches = toArray(ev.touches);
	    var targetIds = this.targetIds;

	    // when there is only one touch, the process can be simplified
	    if (type & (INPUT_START | INPUT_MOVE) && allTouches.length === 1) {
	        targetIds[allTouches[0].identifier] = true;
	        return [allTouches, allTouches];
	    }

	    var i,
	        targetTouches,
	        changedTouches = toArray(ev.changedTouches),
	        changedTargetTouches = [],
	        target = this.target;

	    // get target touches from touches
	    targetTouches = allTouches.filter(function(touch) {
	        return hasParent(touch.target, target);
	    });

	    // collect touches
	    if (type === INPUT_START) {
	        i = 0;
	        while (i < targetTouches.length) {
	            targetIds[targetTouches[i].identifier] = true;
	            i++;
	        }
	    }

	    // filter changed touches to only contain touches that exist in the collected target ids
	    i = 0;
	    while (i < changedTouches.length) {
	        if (targetIds[changedTouches[i].identifier]) {
	            changedTargetTouches.push(changedTouches[i]);
	        }

	        // cleanup removed touches
	        if (type & (INPUT_END | INPUT_CANCEL)) {
	            delete targetIds[changedTouches[i].identifier];
	        }
	        i++;
	    }

	    if (!changedTargetTouches.length) {
	        return;
	    }

	    return [
	        // merge targetTouches with changedTargetTouches so it contains ALL touches, including 'end' and 'cancel'
	        uniqueArray(targetTouches.concat(changedTargetTouches), 'identifier', true),
	        changedTargetTouches
	    ];
	}

	/**
	 * Combined touch and mouse input
	 *
	 * Touch has a higher priority then mouse, and while touching no mouse events are allowed.
	 * This because touch devices also emit mouse events while doing a touch.
	 *
	 * @constructor
	 * @extends Input
	 */
	function TouchMouseInput() {
	    Input.apply(this, arguments);

	    var handler = bindFn(this.handler, this);
	    this.touch = new TouchInput(this.manager, handler);
	    this.mouse = new MouseInput(this.manager, handler);
	}

	inherit(TouchMouseInput, Input, {
	    /**
	     * handle mouse and touch events
	     * @param {Hammer} manager
	     * @param {String} inputEvent
	     * @param {Object} inputData
	     */
	    handler: function TMEhandler(manager, inputEvent, inputData) {
	        var isTouch = (inputData.pointerType == INPUT_TYPE_TOUCH),
	            isMouse = (inputData.pointerType == INPUT_TYPE_MOUSE);

	        // when we're in a touch event, so  block all upcoming mouse events
	        // most mobile browser also emit mouseevents, right after touchstart
	        if (isTouch) {
	            this.mouse.allow = false;
	        } else if (isMouse && !this.mouse.allow) {
	            return;
	        }

	        // reset the allowMouse when we're done
	        if (inputEvent & (INPUT_END | INPUT_CANCEL)) {
	            this.mouse.allow = true;
	        }

	        this.callback(manager, inputEvent, inputData);
	    },

	    /**
	     * remove the event listeners
	     */
	    destroy: function destroy() {
	        this.touch.destroy();
	        this.mouse.destroy();
	    }
	});

	var PREFIXED_TOUCH_ACTION = prefixed(TEST_ELEMENT.style, 'touchAction');
	var NATIVE_TOUCH_ACTION = PREFIXED_TOUCH_ACTION !== undefined;

	// magical touchAction value
	var TOUCH_ACTION_COMPUTE = 'compute';
	var TOUCH_ACTION_AUTO = 'auto';
	var TOUCH_ACTION_MANIPULATION = 'manipulation'; // not implemented
	var TOUCH_ACTION_NONE = 'none';
	var TOUCH_ACTION_PAN_X = 'pan-x';
	var TOUCH_ACTION_PAN_Y = 'pan-y';

	/**
	 * Touch Action
	 * sets the touchAction property or uses the js alternative
	 * @param {Manager} manager
	 * @param {String} value
	 * @constructor
	 */
	function TouchAction(manager, value) {
	    this.manager = manager;
	    this.set(value);
	}

	TouchAction.prototype = {
	    /**
	     * set the touchAction value on the element or enable the polyfill
	     * @param {String} value
	     */
	    set: function(value) {
	        // find out the touch-action by the event handlers
	        if (value == TOUCH_ACTION_COMPUTE) {
	            value = this.compute();
	        }

	        if (NATIVE_TOUCH_ACTION) {
	            this.manager.element.style[PREFIXED_TOUCH_ACTION] = value;
	        }
	        this.actions = value.toLowerCase().trim();
	    },

	    /**
	     * just re-set the touchAction value
	     */
	    update: function() {
	        this.set(this.manager.options.touchAction);
	    },

	    /**
	     * compute the value for the touchAction property based on the recognizer's settings
	     * @returns {String} value
	     */
	    compute: function() {
	        var actions = [];
	        each(this.manager.recognizers, function(recognizer) {
	            if (boolOrFn(recognizer.options.enable, [recognizer])) {
	                actions = actions.concat(recognizer.getTouchAction());
	            }
	        });
	        return cleanTouchActions(actions.join(' '));
	    },

	    /**
	     * this method is called on each input cycle and provides the preventing of the browser behavior
	     * @param {Object} input
	     */
	    preventDefaults: function(input) {
	        // not needed with native support for the touchAction property
	        if (NATIVE_TOUCH_ACTION) {
	            return;
	        }

	        var srcEvent = input.srcEvent;
	        var direction = input.offsetDirection;

	        // if the touch action did prevented once this session
	        if (this.manager.session.prevented) {
	            srcEvent.preventDefault();
	            return;
	        }

	        var actions = this.actions;
	        var hasNone = inStr(actions, TOUCH_ACTION_NONE);
	        var hasPanY = inStr(actions, TOUCH_ACTION_PAN_Y);
	        var hasPanX = inStr(actions, TOUCH_ACTION_PAN_X);

	        if (hasNone ||
	            (hasPanY && direction & DIRECTION_HORIZONTAL) ||
	            (hasPanX && direction & DIRECTION_VERTICAL)) {
	            return this.preventSrc(srcEvent);
	        }
	    },

	    /**
	     * call preventDefault to prevent the browser's default behavior (scrolling in most cases)
	     * @param {Object} srcEvent
	     */
	    preventSrc: function(srcEvent) {
	        this.manager.session.prevented = true;
	        srcEvent.preventDefault();
	    }
	};

	/**
	 * when the touchActions are collected they are not a valid value, so we need to clean things up. *
	 * @param {String} actions
	 * @returns {*}
	 */
	function cleanTouchActions(actions) {
	    // none
	    if (inStr(actions, TOUCH_ACTION_NONE)) {
	        return TOUCH_ACTION_NONE;
	    }

	    var hasPanX = inStr(actions, TOUCH_ACTION_PAN_X);
	    var hasPanY = inStr(actions, TOUCH_ACTION_PAN_Y);

	    // pan-x and pan-y can be combined
	    if (hasPanX && hasPanY) {
	        return TOUCH_ACTION_PAN_X + ' ' + TOUCH_ACTION_PAN_Y;
	    }

	    // pan-x OR pan-y
	    if (hasPanX || hasPanY) {
	        return hasPanX ? TOUCH_ACTION_PAN_X : TOUCH_ACTION_PAN_Y;
	    }

	    // manipulation
	    if (inStr(actions, TOUCH_ACTION_MANIPULATION)) {
	        return TOUCH_ACTION_MANIPULATION;
	    }

	    return TOUCH_ACTION_AUTO;
	}

	/**
	 * Recognizer flow explained; *
	 * All recognizers have the initial state of POSSIBLE when a input session starts.
	 * The definition of a input session is from the first input until the last input, with all it's movement in it. *
	 * Example session for mouse-input: mousedown -> mousemove -> mouseup
	 *
	 * On each recognizing cycle (see Manager.recognize) the .recognize() method is executed
	 * which determines with state it should be.
	 *
	 * If the recognizer has the state FAILED, CANCELLED or RECOGNIZED (equals ENDED), it is reset to
	 * POSSIBLE to give it another change on the next cycle.
	 *
	 *               Possible
	 *                  |
	 *            +-----+---------------+
	 *            |                     |
	 *      +-----+-----+               |
	 *      |           |               |
	 *   Failed      Cancelled          |
	 *                          +-------+------+
	 *                          |              |
	 *                      Recognized       Began
	 *                                         |
	 *                                      Changed
	 *                                         |
	 *                                  Ended/Recognized
	 */
	var STATE_POSSIBLE = 1;
	var STATE_BEGAN = 2;
	var STATE_CHANGED = 4;
	var STATE_ENDED = 8;
	var STATE_RECOGNIZED = STATE_ENDED;
	var STATE_CANCELLED = 16;
	var STATE_FAILED = 32;

	/**
	 * Recognizer
	 * Every recognizer needs to extend from this class.
	 * @constructor
	 * @param {Object} options
	 */
	function Recognizer(options) {
	    this.id = uniqueId();

	    this.manager = null;
	    this.options = merge(options || {}, this.defaults);

	    // default is enable true
	    this.options.enable = ifUndefined(this.options.enable, true);

	    this.state = STATE_POSSIBLE;

	    this.simultaneous = {};
	    this.requireFail = [];
	}

	Recognizer.prototype = {
	    /**
	     * @virtual
	     * @type {Object}
	     */
	    defaults: {},

	    /**
	     * set options
	     * @param {Object} options
	     * @return {Recognizer}
	     */
	    set: function(options) {
	        extend(this.options, options);

	        // also update the touchAction, in case something changed about the directions/enabled state
	        this.manager && this.manager.touchAction.update();
	        return this;
	    },

	    /**
	     * recognize simultaneous with an other recognizer.
	     * @param {Recognizer} otherRecognizer
	     * @returns {Recognizer} this
	     */
	    recognizeWith: function(otherRecognizer) {
	        if (invokeArrayArg(otherRecognizer, 'recognizeWith', this)) {
	            return this;
	        }

	        var simultaneous = this.simultaneous;
	        otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
	        if (!simultaneous[otherRecognizer.id]) {
	            simultaneous[otherRecognizer.id] = otherRecognizer;
	            otherRecognizer.recognizeWith(this);
	        }
	        return this;
	    },

	    /**
	     * drop the simultaneous link. it doesnt remove the link on the other recognizer.
	     * @param {Recognizer} otherRecognizer
	     * @returns {Recognizer} this
	     */
	    dropRecognizeWith: function(otherRecognizer) {
	        if (invokeArrayArg(otherRecognizer, 'dropRecognizeWith', this)) {
	            return this;
	        }

	        otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
	        delete this.simultaneous[otherRecognizer.id];
	        return this;
	    },

	    /**
	     * recognizer can only run when an other is failing
	     * @param {Recognizer} otherRecognizer
	     * @returns {Recognizer} this
	     */
	    requireFailure: function(otherRecognizer) {
	        if (invokeArrayArg(otherRecognizer, 'requireFailure', this)) {
	            return this;
	        }

	        var requireFail = this.requireFail;
	        otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
	        if (inArray(requireFail, otherRecognizer) === -1) {
	            requireFail.push(otherRecognizer);
	            otherRecognizer.requireFailure(this);
	        }
	        return this;
	    },

	    /**
	     * drop the requireFailure link. it does not remove the link on the other recognizer.
	     * @param {Recognizer} otherRecognizer
	     * @returns {Recognizer} this
	     */
	    dropRequireFailure: function(otherRecognizer) {
	        if (invokeArrayArg(otherRecognizer, 'dropRequireFailure', this)) {
	            return this;
	        }

	        otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
	        var index = inArray(this.requireFail, otherRecognizer);
	        if (index > -1) {
	            this.requireFail.splice(index, 1);
	        }
	        return this;
	    },

	    /**
	     * has require failures boolean
	     * @returns {boolean}
	     */
	    hasRequireFailures: function() {
	        return this.requireFail.length > 0;
	    },

	    /**
	     * if the recognizer can recognize simultaneous with an other recognizer
	     * @param {Recognizer} otherRecognizer
	     * @returns {Boolean}
	     */
	    canRecognizeWith: function(otherRecognizer) {
	        return !!this.simultaneous[otherRecognizer.id];
	    },

	    /**
	     * You should use `tryEmit` instead of `emit` directly to check
	     * that all the needed recognizers has failed before emitting.
	     * @param {Object} input
	     */
	    emit: function(input) {
	        var self = this;
	        var state = this.state;

	        function emit(withState) {
	            self.manager.emit(self.options.event + (withState ? stateStr(state) : ''), input);
	        }

	        // 'panstart' and 'panmove'
	        if (state < STATE_ENDED) {
	            emit(true);
	        }

	        emit(); // simple 'eventName' events

	        // panend and pancancel
	        if (state >= STATE_ENDED) {
	            emit(true);
	        }
	    },

	    /**
	     * Check that all the require failure recognizers has failed,
	     * if true, it emits a gesture event,
	     * otherwise, setup the state to FAILED.
	     * @param {Object} input
	     */
	    tryEmit: function(input) {
	        if (this.canEmit()) {
	            return this.emit(input);
	        }
	        // it's failing anyway
	        this.state = STATE_FAILED;
	    },

	    /**
	     * can we emit?
	     * @returns {boolean}
	     */
	    canEmit: function() {
	        var i = 0;
	        while (i < this.requireFail.length) {
	            if (!(this.requireFail[i].state & (STATE_FAILED | STATE_POSSIBLE))) {
	                return false;
	            }
	            i++;
	        }
	        return true;
	    },

	    /**
	     * update the recognizer
	     * @param {Object} inputData
	     */
	    recognize: function(inputData) {
	        // make a new copy of the inputData
	        // so we can change the inputData without messing up the other recognizers
	        var inputDataClone = extend({}, inputData);

	        // is is enabled and allow recognizing?
	        if (!boolOrFn(this.options.enable, [this, inputDataClone])) {
	            this.reset();
	            this.state = STATE_FAILED;
	            return;
	        }

	        // reset when we've reached the end
	        if (this.state & (STATE_RECOGNIZED | STATE_CANCELLED | STATE_FAILED)) {
	            this.state = STATE_POSSIBLE;
	        }

	        this.state = this.process(inputDataClone);

	        // the recognizer has recognized a gesture
	        // so trigger an event
	        if (this.state & (STATE_BEGAN | STATE_CHANGED | STATE_ENDED | STATE_CANCELLED)) {
	            this.tryEmit(inputDataClone);
	        }
	    },

	    /**
	     * return the state of the recognizer
	     * the actual recognizing happens in this method
	     * @virtual
	     * @param {Object} inputData
	     * @returns {Const} STATE
	     */
	    process: function(inputData) { }, // jshint ignore:line

	    /**
	     * return the preferred touch-action
	     * @virtual
	     * @returns {Array}
	     */
	    getTouchAction: function() { },

	    /**
	     * called when the gesture isn't allowed to recognize
	     * like when another is being recognized or it is disabled
	     * @virtual
	     */
	    reset: function() { }
	};

	/**
	 * get a usable string, used as event postfix
	 * @param {Const} state
	 * @returns {String} state
	 */
	function stateStr(state) {
	    if (state & STATE_CANCELLED) {
	        return 'cancel';
	    } else if (state & STATE_ENDED) {
	        return 'end';
	    } else if (state & STATE_CHANGED) {
	        return 'move';
	    } else if (state & STATE_BEGAN) {
	        return 'start';
	    }
	    return '';
	}

	/**
	 * direction cons to string
	 * @param {Const} direction
	 * @returns {String}
	 */
	function directionStr(direction) {
	    if (direction == DIRECTION_DOWN) {
	        return 'down';
	    } else if (direction == DIRECTION_UP) {
	        return 'up';
	    } else if (direction == DIRECTION_LEFT) {
	        return 'left';
	    } else if (direction == DIRECTION_RIGHT) {
	        return 'right';
	    }
	    return '';
	}

	/**
	 * get a recognizer by name if it is bound to a manager
	 * @param {Recognizer|String} otherRecognizer
	 * @param {Recognizer} recognizer
	 * @returns {Recognizer}
	 */
	function getRecognizerByNameIfManager(otherRecognizer, recognizer) {
	    var manager = recognizer.manager;
	    if (manager) {
	        return manager.get(otherRecognizer);
	    }
	    return otherRecognizer;
	}

	/**
	 * This recognizer is just used as a base for the simple attribute recognizers.
	 * @constructor
	 * @extends Recognizer
	 */
	function AttrRecognizer() {
	    Recognizer.apply(this, arguments);
	}

	inherit(AttrRecognizer, Recognizer, {
	    /**
	     * @namespace
	     * @memberof AttrRecognizer
	     */
	    defaults: {
	        /**
	         * @type {Number}
	         * @default 1
	         */
	        pointers: 1
	    },

	    /**
	     * Used to check if it the recognizer receives valid input, like input.distance > 10.
	     * @memberof AttrRecognizer
	     * @param {Object} input
	     * @returns {Boolean} recognized
	     */
	    attrTest: function(input) {
	        var optionPointers = this.options.pointers;
	        return optionPointers === 0 || input.pointers.length === optionPointers;
	    },

	    /**
	     * Process the input and return the state for the recognizer
	     * @memberof AttrRecognizer
	     * @param {Object} input
	     * @returns {*} State
	     */
	    process: function(input) {
	        var state = this.state;
	        var eventType = input.eventType;

	        var isRecognized = state & (STATE_BEGAN | STATE_CHANGED);
	        var isValid = this.attrTest(input);

	        // on cancel input and we've recognized before, return STATE_CANCELLED
	        if (isRecognized && (eventType & INPUT_CANCEL || !isValid)) {
	            return state | STATE_CANCELLED;
	        } else if (isRecognized || isValid) {
	            if (eventType & INPUT_END) {
	                return state | STATE_ENDED;
	            } else if (!(state & STATE_BEGAN)) {
	                return STATE_BEGAN;
	            }
	            return state | STATE_CHANGED;
	        }
	        return STATE_FAILED;
	    }
	});

	/**
	 * Pan
	 * Recognized when the pointer is down and moved in the allowed direction.
	 * @constructor
	 * @extends AttrRecognizer
	 */
	function PanRecognizer() {
	    AttrRecognizer.apply(this, arguments);

	    this.pX = null;
	    this.pY = null;
	}

	inherit(PanRecognizer, AttrRecognizer, {
	    /**
	     * @namespace
	     * @memberof PanRecognizer
	     */
	    defaults: {
	        event: 'pan',
	        threshold: 10,
	        pointers: 1,
	        direction: DIRECTION_ALL
	    },

	    getTouchAction: function() {
	        var direction = this.options.direction;
	        var actions = [];
	        if (direction & DIRECTION_HORIZONTAL) {
	            actions.push(TOUCH_ACTION_PAN_Y);
	        }
	        if (direction & DIRECTION_VERTICAL) {
	            actions.push(TOUCH_ACTION_PAN_X);
	        }
	        return actions;
	    },

	    directionTest: function(input) {
	        var options = this.options;
	        var hasMoved = true;
	        var distance = input.distance;
	        var direction = input.direction;
	        var x = input.deltaX;
	        var y = input.deltaY;

	        // lock to axis?
	        if (!(direction & options.direction)) {
	            if (options.direction & DIRECTION_HORIZONTAL) {
	                direction = (x === 0) ? DIRECTION_NONE : (x < 0) ? DIRECTION_LEFT : DIRECTION_RIGHT;
	                hasMoved = x != this.pX;
	                distance = Math.abs(input.deltaX);
	            } else {
	                direction = (y === 0) ? DIRECTION_NONE : (y < 0) ? DIRECTION_UP : DIRECTION_DOWN;
	                hasMoved = y != this.pY;
	                distance = Math.abs(input.deltaY);
	            }
	        }
	        input.direction = direction;
	        return hasMoved && distance > options.threshold && direction & options.direction;
	    },

	    attrTest: function(input) {
	        return AttrRecognizer.prototype.attrTest.call(this, input) &&
	            (this.state & STATE_BEGAN || (!(this.state & STATE_BEGAN) && this.directionTest(input)));
	    },

	    emit: function(input) {
	        this.pX = input.deltaX;
	        this.pY = input.deltaY;

	        var direction = directionStr(input.direction);
	        if (direction) {
	            this.manager.emit(this.options.event + direction, input);
	        }

	        this._super.emit.call(this, input);
	    }
	});

	/**
	 * Pinch
	 * Recognized when two or more pointers are moving toward (zoom-in) or away from each other (zoom-out).
	 * @constructor
	 * @extends AttrRecognizer
	 */
	function PinchRecognizer() {
	    AttrRecognizer.apply(this, arguments);
	}

	inherit(PinchRecognizer, AttrRecognizer, {
	    /**
	     * @namespace
	     * @memberof PinchRecognizer
	     */
	    defaults: {
	        event: 'pinch',
	        threshold: 0,
	        pointers: 2
	    },

	    getTouchAction: function() {
	        return [TOUCH_ACTION_NONE];
	    },

	    attrTest: function(input) {
	        return this._super.attrTest.call(this, input) &&
	            (Math.abs(input.scale - 1) > this.options.threshold || this.state & STATE_BEGAN);
	    },

	    emit: function(input) {
	        this._super.emit.call(this, input);
	        if (input.scale !== 1) {
	            var inOut = input.scale < 1 ? 'in' : 'out';
	            this.manager.emit(this.options.event + inOut, input);
	        }
	    }
	});

	/**
	 * Press
	 * Recognized when the pointer is down for x ms without any movement.
	 * @constructor
	 * @extends Recognizer
	 */
	function PressRecognizer() {
	    Recognizer.apply(this, arguments);

	    this._timer = null;
	    this._input = null;
	}

	inherit(PressRecognizer, Recognizer, {
	    /**
	     * @namespace
	     * @memberof PressRecognizer
	     */
	    defaults: {
	        event: 'press',
	        pointers: 1,
	        time: 500, // minimal time of the pointer to be pressed
	        threshold: 5 // a minimal movement is ok, but keep it low
	    },

	    getTouchAction: function() {
	        return [TOUCH_ACTION_AUTO];
	    },

	    process: function(input) {
	        var options = this.options;
	        var validPointers = input.pointers.length === options.pointers;
	        var validMovement = input.distance < options.threshold;
	        var validTime = input.deltaTime > options.time;

	        this._input = input;

	        // we only allow little movement
	        // and we've reached an end event, so a tap is possible
	        if (!validMovement || !validPointers || (input.eventType & (INPUT_END | INPUT_CANCEL) && !validTime)) {
	            this.reset();
	        } else if (input.eventType & INPUT_START) {
	            this.reset();
	            this._timer = setTimeoutContext(function() {
	                this.state = STATE_RECOGNIZED;
	                this.tryEmit();
	            }, options.time, this);
	        } else if (input.eventType & INPUT_END) {
	            return STATE_RECOGNIZED;
	        }
	        return STATE_FAILED;
	    },

	    reset: function() {
	        clearTimeout(this._timer);
	    },

	    emit: function(input) {
	        if (this.state !== STATE_RECOGNIZED) {
	            return;
	        }

	        if (input && (input.eventType & INPUT_END)) {
	            this.manager.emit(this.options.event + 'up', input);
	        } else {
	            this._input.timeStamp = now();
	            this.manager.emit(this.options.event, this._input);
	        }
	    }
	});

	/**
	 * Rotate
	 * Recognized when two or more pointer are moving in a circular motion.
	 * @constructor
	 * @extends AttrRecognizer
	 */
	function RotateRecognizer() {
	    AttrRecognizer.apply(this, arguments);
	}

	inherit(RotateRecognizer, AttrRecognizer, {
	    /**
	     * @namespace
	     * @memberof RotateRecognizer
	     */
	    defaults: {
	        event: 'rotate',
	        threshold: 0,
	        pointers: 2
	    },

	    getTouchAction: function() {
	        return [TOUCH_ACTION_NONE];
	    },

	    attrTest: function(input) {
	        return this._super.attrTest.call(this, input) &&
	            (Math.abs(input.rotation) > this.options.threshold || this.state & STATE_BEGAN);
	    }
	});

	/**
	 * Swipe
	 * Recognized when the pointer is moving fast (velocity), with enough distance in the allowed direction.
	 * @constructor
	 * @extends AttrRecognizer
	 */
	function SwipeRecognizer() {
	    AttrRecognizer.apply(this, arguments);
	}

	inherit(SwipeRecognizer, AttrRecognizer, {
	    /**
	     * @namespace
	     * @memberof SwipeRecognizer
	     */
	    defaults: {
	        event: 'swipe',
	        threshold: 10,
	        velocity: 0.65,
	        direction: DIRECTION_HORIZONTAL | DIRECTION_VERTICAL,
	        pointers: 1
	    },

	    getTouchAction: function() {
	        return PanRecognizer.prototype.getTouchAction.call(this);
	    },

	    attrTest: function(input) {
	        var direction = this.options.direction;
	        var velocity;

	        if (direction & (DIRECTION_HORIZONTAL | DIRECTION_VERTICAL)) {
	            velocity = input.velocity;
	        } else if (direction & DIRECTION_HORIZONTAL) {
	            velocity = input.velocityX;
	        } else if (direction & DIRECTION_VERTICAL) {
	            velocity = input.velocityY;
	        }

	        return this._super.attrTest.call(this, input) &&
	            direction & input.direction &&
	            input.distance > this.options.threshold &&
	            abs(velocity) > this.options.velocity && input.eventType & INPUT_END;
	    },

	    emit: function(input) {
	        var direction = directionStr(input.direction);
	        if (direction) {
	            this.manager.emit(this.options.event + direction, input);
	        }

	        this.manager.emit(this.options.event, input);
	    }
	});

	/**
	 * A tap is ecognized when the pointer is doing a small tap/click. Multiple taps are recognized if they occur
	 * between the given interval and position. The delay option can be used to recognize multi-taps without firing
	 * a single tap.
	 *
	 * The eventData from the emitted event contains the property `tapCount`, which contains the amount of
	 * multi-taps being recognized.
	 * @constructor
	 * @extends Recognizer
	 */
	function TapRecognizer() {
	    Recognizer.apply(this, arguments);

	    // previous time and center,
	    // used for tap counting
	    this.pTime = false;
	    this.pCenter = false;

	    this._timer = null;
	    this._input = null;
	    this.count = 0;
	}

	inherit(TapRecognizer, Recognizer, {
	    /**
	     * @namespace
	     * @memberof PinchRecognizer
	     */
	    defaults: {
	        event: 'tap',
	        pointers: 1,
	        taps: 1,
	        interval: 300, // max time between the multi-tap taps
	        time: 250, // max time of the pointer to be down (like finger on the screen)
	        threshold: 2, // a minimal movement is ok, but keep it low
	        posThreshold: 10 // a multi-tap can be a bit off the initial position
	    },

	    getTouchAction: function() {
	        return [TOUCH_ACTION_MANIPULATION];
	    },

	    process: function(input) {
	        var options = this.options;

	        var validPointers = input.pointers.length === options.pointers;
	        var validMovement = input.distance < options.threshold;
	        var validTouchTime = input.deltaTime < options.time;

	        this.reset();

	        if ((input.eventType & INPUT_START) && (this.count === 0)) {
	            return this.failTimeout();
	        }

	        // we only allow little movement
	        // and we've reached an end event, so a tap is possible
	        if (validMovement && validTouchTime && validPointers) {
	            if (input.eventType != INPUT_END) {
	                return this.failTimeout();
	            }

	            var validInterval = this.pTime ? (input.timeStamp - this.pTime < options.interval) : true;
	            var validMultiTap = !this.pCenter || getDistance(this.pCenter, input.center) < options.posThreshold;

	            this.pTime = input.timeStamp;
	            this.pCenter = input.center;

	            if (!validMultiTap || !validInterval) {
	                this.count = 1;
	            } else {
	                this.count += 1;
	            }

	            this._input = input;

	            // if tap count matches we have recognized it,
	            // else it has began recognizing...
	            var tapCount = this.count % options.taps;
	            if (tapCount === 0) {
	                // no failing requirements, immediately trigger the tap event
	                // or wait as long as the multitap interval to trigger
	                if (!this.hasRequireFailures()) {
	                    return STATE_RECOGNIZED;
	                } else {
	                    this._timer = setTimeoutContext(function() {
	                        this.state = STATE_RECOGNIZED;
	                        this.tryEmit();
	                    }, options.interval, this);
	                    return STATE_BEGAN;
	                }
	            }
	        }
	        return STATE_FAILED;
	    },

	    failTimeout: function() {
	        this._timer = setTimeoutContext(function() {
	            this.state = STATE_FAILED;
	        }, this.options.interval, this);
	        return STATE_FAILED;
	    },

	    reset: function() {
	        clearTimeout(this._timer);
	    },

	    emit: function() {
	        if (this.state == STATE_RECOGNIZED ) {
	            this._input.tapCount = this.count;
	            this.manager.emit(this.options.event, this._input);
	        }
	    }
	});

	/**
	 * Simple way to create an manager with a default set of recognizers.
	 * @param {HTMLElement} element
	 * @param {Object} [options]
	 * @constructor
	 */
	function Hammer(element, options) {
	    options = options || {};
	    options.recognizers = ifUndefined(options.recognizers, Hammer.defaults.preset);
	    return new Manager(element, options);
	}

	/**
	 * @const {string}
	 */
	Hammer.VERSION = '2.0.4';

	/**
	 * default settings
	 * @namespace
	 */
	Hammer.defaults = {
	    /**
	     * set if DOM events are being triggered.
	     * But this is slower and unused by simple implementations, so disabled by default.
	     * @type {Boolean}
	     * @default false
	     */
	    domEvents: false,

	    /**
	     * The value for the touchAction property/fallback.
	     * When set to `compute` it will magically set the correct value based on the added recognizers.
	     * @type {String}
	     * @default compute
	     */
	    touchAction: TOUCH_ACTION_COMPUTE,

	    /**
	     * @type {Boolean}
	     * @default true
	     */
	    enable: true,

	    /**
	     * EXPERIMENTAL FEATURE -- can be removed/changed
	     * Change the parent input target element.
	     * If Null, then it is being set the to main element.
	     * @type {Null|EventTarget}
	     * @default null
	     */
	    inputTarget: null,

	    /**
	     * force an input class
	     * @type {Null|Function}
	     * @default null
	     */
	    inputClass: null,

	    /**
	     * Default recognizer setup when calling `Hammer()`
	     * When creating a new Manager these will be skipped.
	     * @type {Array}
	     */
	    preset: [
	        // RecognizerClass, options, [recognizeWith, ...], [requireFailure, ...]
	        [RotateRecognizer, { enable: false }],
	        [PinchRecognizer, { enable: false }, ['rotate']],
	        [SwipeRecognizer,{ direction: DIRECTION_HORIZONTAL }],
	        [PanRecognizer, { direction: DIRECTION_HORIZONTAL }, ['swipe']],
	        [TapRecognizer],
	        [TapRecognizer, { event: 'doubletap', taps: 2 }, ['tap']],
	        [PressRecognizer]
	    ],

	    /**
	     * Some CSS properties can be used to improve the working of Hammer.
	     * Add them to this method and they will be set when creating a new Manager.
	     * @namespace
	     */
	    cssProps: {
	        /**
	         * Disables text selection to improve the dragging gesture. Mainly for desktop browsers.
	         * @type {String}
	         * @default 'none'
	         */
	        userSelect: 'none',

	        /**
	         * Disable the Windows Phone grippers when pressing an element.
	         * @type {String}
	         * @default 'none'
	         */
	        touchSelect: 'none',

	        /**
	         * Disables the default callout shown when you touch and hold a touch target.
	         * On iOS, when you touch and hold a touch target such as a link, Safari displays
	         * a callout containing information about the link. This property allows you to disable that callout.
	         * @type {String}
	         * @default 'none'
	         */
	        touchCallout: 'none',

	        /**
	         * Specifies whether zooming is enabled. Used by IE10>
	         * @type {String}
	         * @default 'none'
	         */
	        contentZooming: 'none',

	        /**
	         * Specifies that an entire element should be draggable instead of its contents. Mainly for desktop browsers.
	         * @type {String}
	         * @default 'none'
	         */
	        userDrag: 'none',

	        /**
	         * Overrides the highlight color shown when the user taps a link or a JavaScript
	         * clickable element in iOS. This property obeys the alpha value, if specified.
	         * @type {String}
	         * @default 'rgba(0,0,0,0)'
	         */
	        tapHighlightColor: 'rgba(0,0,0,0)'
	    }
	};

	var STOP = 1;
	var FORCED_STOP = 2;

	/**
	 * Manager
	 * @param {HTMLElement} element
	 * @param {Object} [options]
	 * @constructor
	 */
	function Manager(element, options) {
	    options = options || {};

	    this.options = merge(options, Hammer.defaults);
	    this.options.inputTarget = this.options.inputTarget || element;

	    this.handlers = {};
	    this.session = {};
	    this.recognizers = [];

	    this.element = element;
	    this.input = createInputInstance(this);
	    this.touchAction = new TouchAction(this, this.options.touchAction);

	    toggleCssProps(this, true);

	    each(options.recognizers, function(item) {
	        var recognizer = this.add(new (item[0])(item[1]));
	        item[2] && recognizer.recognizeWith(item[2]);
	        item[3] && recognizer.requireFailure(item[3]);
	    }, this);
	}

	Manager.prototype = {
	    /**
	     * set options
	     * @param {Object} options
	     * @returns {Manager}
	     */
	    set: function(options) {
	        extend(this.options, options);

	        // Options that need a little more setup
	        if (options.touchAction) {
	            this.touchAction.update();
	        }
	        if (options.inputTarget) {
	            // Clean up existing event listeners and reinitialize
	            this.input.destroy();
	            this.input.target = options.inputTarget;
	            this.input.init();
	        }
	        return this;
	    },

	    /**
	     * stop recognizing for this session.
	     * This session will be discarded, when a new [input]start event is fired.
	     * When forced, the recognizer cycle is stopped immediately.
	     * @param {Boolean} [force]
	     */
	    stop: function(force) {
	        this.session.stopped = force ? FORCED_STOP : STOP;
	    },

	    /**
	     * run the recognizers!
	     * called by the inputHandler function on every movement of the pointers (touches)
	     * it walks through all the recognizers and tries to detect the gesture that is being made
	     * @param {Object} inputData
	     */
	    recognize: function(inputData) {
	        var session = this.session;
	        if (session.stopped) {
	            return;
	        }

	        // run the touch-action polyfill
	        this.touchAction.preventDefaults(inputData);

	        var recognizer;
	        var recognizers = this.recognizers;

	        // this holds the recognizer that is being recognized.
	        // so the recognizer's state needs to be BEGAN, CHANGED, ENDED or RECOGNIZED
	        // if no recognizer is detecting a thing, it is set to `null`
	        var curRecognizer = session.curRecognizer;

	        // reset when the last recognizer is recognized
	        // or when we're in a new session
	        if (!curRecognizer || (curRecognizer && curRecognizer.state & STATE_RECOGNIZED)) {
	            curRecognizer = session.curRecognizer = null;
	        }

	        var i = 0;
	        while (i < recognizers.length) {
	            recognizer = recognizers[i];

	            // find out if we are allowed try to recognize the input for this one.
	            // 1.   allow if the session is NOT forced stopped (see the .stop() method)
	            // 2.   allow if we still haven't recognized a gesture in this session, or the this recognizer is the one
	            //      that is being recognized.
	            // 3.   allow if the recognizer is allowed to run simultaneous with the current recognized recognizer.
	            //      this can be setup with the `recognizeWith()` method on the recognizer.
	            if (session.stopped !== FORCED_STOP && ( // 1
	                    !curRecognizer || recognizer == curRecognizer || // 2
	                    recognizer.canRecognizeWith(curRecognizer))) { // 3
	                recognizer.recognize(inputData);
	            } else {
	                recognizer.reset();
	            }

	            // if the recognizer has been recognizing the input as a valid gesture, we want to store this one as the
	            // current active recognizer. but only if we don't already have an active recognizer
	            if (!curRecognizer && recognizer.state & (STATE_BEGAN | STATE_CHANGED | STATE_ENDED)) {
	                curRecognizer = session.curRecognizer = recognizer;
	            }
	            i++;
	        }
	    },

	    /**
	     * get a recognizer by its event name.
	     * @param {Recognizer|String} recognizer
	     * @returns {Recognizer|Null}
	     */
	    get: function(recognizer) {
	        if (recognizer instanceof Recognizer) {
	            return recognizer;
	        }

	        var recognizers = this.recognizers;
	        for (var i = 0; i < recognizers.length; i++) {
	            if (recognizers[i].options.event == recognizer) {
	                return recognizers[i];
	            }
	        }
	        return null;
	    },

	    /**
	     * add a recognizer to the manager
	     * existing recognizers with the same event name will be removed
	     * @param {Recognizer} recognizer
	     * @returns {Recognizer|Manager}
	     */
	    add: function(recognizer) {
	        if (invokeArrayArg(recognizer, 'add', this)) {
	            return this;
	        }

	        // remove existing
	        var existing = this.get(recognizer.options.event);
	        if (existing) {
	            this.remove(existing);
	        }

	        this.recognizers.push(recognizer);
	        recognizer.manager = this;

	        this.touchAction.update();
	        return recognizer;
	    },

	    /**
	     * remove a recognizer by name or instance
	     * @param {Recognizer|String} recognizer
	     * @returns {Manager}
	     */
	    remove: function(recognizer) {
	        if (invokeArrayArg(recognizer, 'remove', this)) {
	            return this;
	        }

	        var recognizers = this.recognizers;
	        recognizer = this.get(recognizer);
	        recognizers.splice(inArray(recognizers, recognizer), 1);

	        this.touchAction.update();
	        return this;
	    },

	    /**
	     * bind event
	     * @param {String} events
	     * @param {Function} handler
	     * @returns {EventEmitter} this
	     */
	    on: function(events, handler) {
	        var handlers = this.handlers;
	        each(splitStr(events), function(event) {
	            handlers[event] = handlers[event] || [];
	            handlers[event].push(handler);
	        });
	        return this;
	    },

	    /**
	     * unbind event, leave emit blank to remove all handlers
	     * @param {String} events
	     * @param {Function} [handler]
	     * @returns {EventEmitter} this
	     */
	    off: function(events, handler) {
	        var handlers = this.handlers;
	        each(splitStr(events), function(event) {
	            if (!handler) {
	                delete handlers[event];
	            } else {
	                handlers[event].splice(inArray(handlers[event], handler), 1);
	            }
	        });
	        return this;
	    },

	    /**
	     * emit event to the listeners
	     * @param {String} event
	     * @param {Object} data
	     */
	    emit: function(event, data) {
	        // we also want to trigger dom events
	        if (this.options.domEvents) {
	            triggerDomEvent(event, data);
	        }

	        // no handlers, so skip it all
	        var handlers = this.handlers[event] && this.handlers[event].slice();
	        if (!handlers || !handlers.length) {
	            return;
	        }

	        data.type = event;
	        data.preventDefault = function() {
	            data.srcEvent.preventDefault();
	        };

	        var i = 0;
	        while (i < handlers.length) {
	            handlers[i](data);
	            i++;
	        }
	    },

	    /**
	     * destroy the manager and unbinds all events
	     * it doesn't unbind dom events, that is the user own responsibility
	     */
	    destroy: function() {
	        this.element && toggleCssProps(this, false);

	        this.handlers = {};
	        this.session = {};
	        this.input.destroy();
	        this.element = null;
	    }
	};

	/**
	 * add/remove the css properties as defined in manager.options.cssProps
	 * @param {Manager} manager
	 * @param {Boolean} add
	 */
	function toggleCssProps(manager, add) {
	    var element = manager.element;
	    each(manager.options.cssProps, function(value, name) {
	        element.style[prefixed(element.style, name)] = add ? value : '';
	    });
	}

	/**
	 * trigger dom event
	 * @param {String} event
	 * @param {Object} data
	 */
	function triggerDomEvent(event, data) {
	    var gestureEvent = document.createEvent('Event');
	    gestureEvent.initEvent(event, true, true);
	    gestureEvent.gesture = data;
	    data.target.dispatchEvent(gestureEvent);
	}

	extend(Hammer, {
	    INPUT_START: INPUT_START,
	    INPUT_MOVE: INPUT_MOVE,
	    INPUT_END: INPUT_END,
	    INPUT_CANCEL: INPUT_CANCEL,

	    STATE_POSSIBLE: STATE_POSSIBLE,
	    STATE_BEGAN: STATE_BEGAN,
	    STATE_CHANGED: STATE_CHANGED,
	    STATE_ENDED: STATE_ENDED,
	    STATE_RECOGNIZED: STATE_RECOGNIZED,
	    STATE_CANCELLED: STATE_CANCELLED,
	    STATE_FAILED: STATE_FAILED,

	    DIRECTION_NONE: DIRECTION_NONE,
	    DIRECTION_LEFT: DIRECTION_LEFT,
	    DIRECTION_RIGHT: DIRECTION_RIGHT,
	    DIRECTION_UP: DIRECTION_UP,
	    DIRECTION_DOWN: DIRECTION_DOWN,
	    DIRECTION_HORIZONTAL: DIRECTION_HORIZONTAL,
	    DIRECTION_VERTICAL: DIRECTION_VERTICAL,
	    DIRECTION_ALL: DIRECTION_ALL,

	    Manager: Manager,
	    Input: Input,
	    TouchAction: TouchAction,

	    TouchInput: TouchInput,
	    MouseInput: MouseInput,
	    PointerEventInput: PointerEventInput,
	    TouchMouseInput: TouchMouseInput,
	    SingleTouchInput: SingleTouchInput,

	    Recognizer: Recognizer,
	    AttrRecognizer: AttrRecognizer,
	    Tap: TapRecognizer,
	    Pan: PanRecognizer,
	    Swipe: SwipeRecognizer,
	    Pinch: PinchRecognizer,
	    Rotate: RotateRecognizer,
	    Press: PressRecognizer,

	    on: addEventListeners,
	    off: removeEventListeners,
	    each: each,
	    merge: merge,
	    extend: extend,
	    inherit: inherit,
	    bindFn: bindFn,
	    prefixed: prefixed
	});

	if ("function" == TYPE_FUNCTION && __webpack_require__(146)) {
	    !(__WEBPACK_AMD_DEFINE_RESULT__ = function() {
	        return Hammer;
	    }.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	} else if (typeof module != 'undefined' && module.exports) {
	    module.exports = Hammer;
	} else {
	    window[exportName] = Hammer;
	}

	})(window, document, 'Hammer');


/***/ },
/* 146 */
/***/ function(module, exports) {

	/* WEBPACK VAR INJECTION */(function(__webpack_amd_options__) {module.exports = __webpack_amd_options__;

	/* WEBPACK VAR INJECTION */}.call(exports, {}))

/***/ }
/******/ ]);